<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>狐狸反走矣</title><id>https://blog.southfox.me/feed.xml</id><subtitle>Recent Posts</subtitle><updated>2025-10-13T06:07:29Z</updated><link href="https://blog.southfox.me/feed.xml" rel="self" /><link href="https://blog.southfox.me" /><entry><title>FoxThinking #0: 元思考与幽默</title><id>https://blog.southfox.me/2025/10/fox-thinking-0/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2025-10-12T14:09:00Z</updated><link href="https://blog.southfox.me/2025/10/fox-thinking-0/.html" rel="alternate" /><content type="html">&lt;p&gt;周刊计划正式启动。&lt;/p&gt;&lt;p&gt;因为我想要维护一个有强烈结构性的形式来作为现世生活的「锚点」,其实很多人都有一个不稀奇的锚点那就是上班。
但是对于我来说这个「锚点」开始逐渐沉闷和生锈了，所以想要想要找寻一个新的。自从最近看了挺多博客网站和类
似的每周总结或者是周刊这种形式后我也逐渐动了想写个周刊的念头。&lt;/p&gt;&lt;p&gt;名字来源业是又一次来霍霍「胡」字开头的成语「狐思乱想」对应的英文名 &lt;code&gt;Fox thinking&lt;/code&gt; 。&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;h2 id=&quot;创刊&quot;&gt;创刊&lt;/h2&gt;&lt;p&gt;毕竟也是创刊期还是简要列一下我对这个周刊的特点吧：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;「狐」言乱语：这个周刊应该是私人向的，记载一些我看的东西和最近我想的一些主题。&lt;/li&gt;&lt;li&gt;回溯优先：很多文章都会记载一些最近的事并想昭示什么，做出一些预测，但预测是个很难又很「随便」的事，
我不太想蹚水然后「濡其尾」，更多想往身后看弄懂过去发生了什么。&lt;/li&gt;&lt;li&gt;我不知道：立足过去也有个好处就是能够接触更多的「低本底钢」 &lt;a href=&quot;#1&quot; id=&quot;1r&quot;&gt;1&lt;/a&gt; 。在大模型狂潮后，已经很难弄清
网上内容背后到底有多少是大模型嚼过的了。我对大模型的不满在于不会承认自己的无知，而这其实是深深植根
语人类文本「为赋新词强说愁」而很难做到。毕竟，很多时候都想占着坑先啊，直接说「我不知道」不就断绝了
后续可能嘛。而智慧在于知道自己不知道 &lt;a href=&quot;#2&quot; id=&quot;2r&quot;&gt;2&lt;/a&gt; ，&lt;/li&gt;&lt;li&gt;尽力生产：与其做信息爱好者，不如做独一无二的原创信息的生产者，哪怕产出的东西再拙劣也无妨。&lt;a href=&quot;#3&quot; id=&quot;3r&quot;&gt;3&lt;/a&gt;
当然这是个很难的事所以我也只能说尽量了。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不过这些特点也只是现在臆想的，可能随着时间发展后有所不同，因为预测是个很难的事啊。在更新上我对于
一周写一篇的产出也有很大怀疑，不过我希望至少至少在三个月的试运行阶段能够进行产出吧，在三个月后看看要
不要转成半月更或是不定时更新（一种弃坑的体面说法）。&lt;/p&gt;&lt;h2 id=&quot;元思考与幽默&quot;&gt;元思考与幽默&lt;/h2&gt;&lt;p&gt;最近在 B 站上流行的「从夯到拉」：一种类似国外 19 年 tierlist 的对世间万物的打分排行的风潮，对于这种潮
流我也只是看个乐子，但是在越来越流传之后不可避免的出现了对「从夯到拉」的「从夯到拉」的「元」事物。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://media.southfox.me/attachment/2025-10-12_15-22-screenshot.jpg&quot;&gt;https://media.southfox.me/attachment/2025-10-12_15-22-screenshot.jpg&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这种谈论事物本身的「自指」讨论通常都是挺有幽默感的 &lt;a href=&quot;#4&quot; id=&quot;4r&quot;&gt;4&lt;/a&gt; ，但是为什么呢？可以将拉塔和莫瑞尔的研究模型和
弗洛伊德的理论结合，能发现幽默有以下的六个特征 &lt;a href=&quot;#5&quot; id=&quot;5r&quot;&gt;5&lt;/a&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;一种抽离，使人们可以远离认真严肃的讨论&lt;/li&gt;&lt;li&gt;与一开始预期的矛盾或 &lt;strong&gt;失望&lt;/strong&gt; ，通常是由&lt;/li&gt;&lt;li&gt;&lt;strong&gt;不协调&lt;/strong&gt; 的事例引起的，这种不协调通过矛盾、反讽和荒缪产生&lt;/li&gt;&lt;li&gt;一种对紧张或强烈情绪的 &lt;strong&gt;放松&lt;/strong&gt; 以及&lt;/li&gt;&lt;li&gt;从这种放松的 &lt;strong&gt;愉悦&lt;/strong&gt; 之情&lt;/li&gt;&lt;li&gt;对精神能量的节约或者在精神层面 &lt;strong&gt;毫不费力&lt;/strong&gt; 的体验&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;根据以上的特征，可以发现这种「自指」的元思考给人一种不协调感，哪怕很多「从夯到拉」的排行都有一种戏谑感但是
通过元思考更加深了这种戏谑感带来了一种放松。这种「高高在上」的「抽离」感可能就是这种元事物的幽默感吧。&lt;/p&gt;&lt;p&gt;可是为什么这种精神能量的节约会让人放松发笑呢，难道又要搬出神话般的意象「采集时代的远古社会」吗？又是说什么在
当时的恶劣环境下有着抽象能力的元思考能让整个社群存活机率更高所以在这样一些那些的自然选择下人类就会更偏好这种
元思考？或许我们知道的一种事就是有可能永远不知道能知道有这一种事，还是少霍霍点「远古采集者」吧。&lt;/p&gt;&lt;h2 id=&quot;Presentday,Presenttime&quot;&gt;Present day, Present time&lt;/h2&gt;&lt;p&gt;月初长假时白天一直要出去「保养」人际关系导致没做什么然后回来时报复性熬夜到凌晨四五点然后到了白天又要出去的……这个
丝滑循环成功打崩了我九月末有点好转的结构性。现在长假结束后又得慢慢校准一下我的现世体验，下个星期先从整理东西开始
吧。整理东西是挺有舒适感的但我会一直拖着不做导致环境越来越凌乱然后也是破坏结构性（我的结构性就像叠叠乐游戏一样建
好之后不停的抽出一块游一块构件然后崩塌之后重新叠好……）。&lt;/p&gt;&lt;p&gt;这周一直在为这个周刊做准备，完成了 org-mode 脚注的语法和图片插入，不得不说换了个只有「砖头」的静态站点框架后也
是不能偷懒了啊，因为 markdown 没有支持所以无论折腾 markdown 还是 org-mode 的工作量都是一样的。
而在现在打算写点啥就是会首选 org-mode ，因为 org-mode 背靠的 emacs 产生了一种之后我要再做操作什么都很方便的
错觉。&lt;/p&gt;&lt;h2 id=&quot;阅读&quot;&gt;阅读&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://jandan.net/p/120846&quot;&gt;睡眠是最被低估的投资 - 煎蛋&lt;/a&gt;&lt;/p&gt;&lt;p&gt;这周没什么太多有感想的东西，可能是因为没有保持睡眠吧。为了之后的「游戏体验」，还是多睡点吧。&lt;/p&gt;&lt;h2 id=&quot;脚注&quot;&gt;脚注&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;#1r&quot; id=&quot;1&quot;&gt;1&lt;/a&gt; 低本底钢（英语：Low-background steel），或译“低背景钢”，亦称先原子钢（pre-atomic steel）与二战前钢（pre-war steel），是在1940年代和1950年代第一代原子弹爆炸前生产的钢材。由于在1945年，随着三位一体核试验、广岛、长崎核轰炸，以及冷战早期一系列核武器试验的进行，世界背景辐射量有明显升高。现代生产的钢铁由于普遍使用大气气体而被放射性同位素污染，低本底钢的称呼由此而来。因为其没有受到过此类污染，这种钢材被使用在高精度放射性同位素检测设备上。 -- &lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E4%BD%8E%E6%9C%AC%E5%BA%95%E9%92%A2&quot;&gt;维基百科&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#2r&quot; id=&quot;2&quot;&gt;2&lt;/a&gt; 唯有苏格拉底这样的人最有智慧，因为他知其智实在不算什么。 苏格拉底的申辩，23b.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#3r&quot; id=&quot;3&quot;&gt;3&lt;/a&gt; 上野千鹤子. 从提问到输出. 文汇出版社, 2024, 第 2 页.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#4r&quot; id=&quot;4&quot;&gt;4&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV19u4y1D7GT/&quot;&gt;【毕导】这个视频里说的都是真的，但你却永远无法证明_哔哩哔哩_bilibili&lt;/a&gt; 26:20&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;#5r&quot; id=&quot;5&quot;&gt;5&lt;/a&gt; 汉斯-格奥尔格·梅勒. 游心之路. 北京联合出版公司. 2019, 第 98 页.&lt;/p&gt;</content></entry><entry><title>Hello Haunt, 又一次换了博客框架</title><id>https://blog.southfox.me/2025/09/hello-haunt/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2025-09-22T16:53:00Z</updated><link href="https://blog.southfox.me/2025/09/hello-haunt/.html" rel="alternate" /><content type="html">&lt;p&gt;鼓捣了大半个月，终于将本博客切换到新的框架上了。看到上一次为 &lt;a href=&quot;/2019/12/hello-world/&quot;&gt;Hexo&lt;/a&gt;
写的博文，发现已经快六年过去了，徒留一阵感慨啊……&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;h2 id=&quot;Hexo&quot;&gt;Hexo&lt;/h2&gt;&lt;p&gt;六年下来我对于对于之前搭建在 Hexo 上的博客还是小有微辞的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Hexo 是 npm 生态下的应用，所以安装就会引入 node_modules 这个重力黑洞。&lt;/li&gt;&lt;li&gt;node_modules 里面的依赖经常触发漏洞扫描告警，我只是用来本地生成点 HTML 页面结果为什么要这么「轰炸」我啊……&lt;/li&gt;&lt;li&gt;我一直想用 org-mode 来写博文的但是 hexo 不原生支持所以……额，npm install something ？&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;然后是对于 &lt;a href=&quot;https://github.com/blackshow/hexo-theme-freemind.386&quot;&gt;Freemide.386&lt;/a&gt; 这个主题，这个主题很好，也很有风格。可能这个博客 80% 的惊奇都来源于这个主题，但它也有
一些不足：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;它还在用着 15 年时的技术栈，为了实现响应式布局不惜引入几百 K 的 js 和 css 文件
（bootstrap 3.1.1 版本，2014-02-13 发行）。
但现在已经可以用现代 css 标准写很少的样式来实现响应式布局了。&lt;/li&gt;&lt;li&gt;「年少轻狂」的我在上面折腾了很多东西，例如直接硬写 min.css 样式文件啥的。
经过这么多年的硬整，已经变成了用来藏污纳垢的地毯，我已经没有勇气掀开它了。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;不过说了这些，其实最主要还是我没有对着某个不知名教程鼓捣一通然后用了六年的 hexo 产生什么「感情」（什么虐恋 BE 文学），
最近甚至还出现了在 ci 中连 npm install 都报错的情况（好像是镜像源的问题），索性就打算换个新框架了。&lt;/p&gt;&lt;h2 id=&quot;Haunt&quot;&gt;Haunt&lt;/h2&gt;&lt;p&gt;所以换啥呢，这世面上的静态博客生成框架已经差不多五百个了（参见： &lt;a href=&quot;https://staticsitegenerators.bevry.me/&quot;&gt;Static Site Generators&lt;/a&gt; ），我其实有点想
多加上一个，不过一想到要折腾的量导致也只是想了想。&lt;/p&gt;&lt;p&gt;那么用 Hugo 吗？但是感觉体验跟 Hexo 有点大差不差，尤其对于我这种古旧设计来说，无非就是将从 EJS 模板语法换
成 Go 模板语法。&lt;/p&gt;&lt;p&gt;在不断翻列表和按星星数、按语言排序后，最后看上了 &lt;a href=&quot;https://dthompson.us/projects/haunt.html&quot;&gt;Haunt&lt;/a&gt; ，一个用 Guile Scheme 写的静态网站生成器。在体验了几下后我决定，
就选它了（很难说当时是不是「鬼迷心窍」了），原因为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;简单；对于我这个没什么需求的设计，只需要一些简单的能直接在心智上记住的流程就够了，而 Haunt 的设计根本上也只是一些简单函数拼接而已。&lt;/li&gt;&lt;li&gt;直接；其实静态网站生成只是解析一下文本文件然后根据节点类型往内容「粘」上对应的 HTML 标签而已，而对于 Haunt ，依托于 Scheme
后面的 SXML （下文会介绍到）让这个过程更直接了。&lt;/li&gt;&lt;li&gt;灵活；Haunt 本身只是一些函数的拼接，所以我也可以往里拼自己的内容，在复杂度还没失控之前这个流程还是很让人心情愉快的。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;Lisp速成课&quot;&gt;Lisp 速成课&lt;/h2&gt;&lt;p&gt;上文列出的原因其实还有一个根本原因 —— Scheme ，一种 Lisp 方言 ，简单、直接、灵活。但可能很多人都会畏惧这个有着古怪圆括号语法的语言被
劝退，为了本就稀少来阅读本文的读者，所以我打算花亿点时间来介绍 Lisp ：&lt;/p&gt;&lt;h3 id=&quot;语法&quot;&gt;语法&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Python, Java, C, 里的运行一个函数 (或者叫方法，过程等等)： &lt;code&gt;print(&amp;quot;Hello World!&amp;quot;)&lt;/code&gt;&lt;/li&gt;&lt;li&gt;Lisp 里运行一个函数(在 Scheme 里一般叫过程)： &lt;code&gt;(print &amp;quot;Hello World!&amp;quot;)&lt;/code&gt;&lt;/li&gt;&lt;li&gt;好了，你已经掌握了 Lisp 百分之九十的语法了，结课！&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;好吧，其实这样子说有点像是在说：围棋的规则是一方的棋子围住另一方的棋子就能吃掉然后谁占地盘多谁就赢好了现在你去跟阿尔法狗对弈一样。
不过其实 Lisp 家族语言的语法就是这么简单，第一项是函数（或者叫……你知道的，就是那种「东西」），剩下的为函数的参数。如：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;(+ 1 1) ;; =&amp;gt; 2
;; PS: Lisp 系列语言通常拿 ; 作为注释
(* 2 (+ 1 1)) ;; =&amp;gt; 4
;; PPS: 一个函数调用的参数可以是另一个函数调用&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;数据即代码&quot;&gt;数据即代码&lt;/h3&gt;&lt;p&gt;如果知道 Lisp 其实可以视作「列表处理」（list processing）的缩写，
你可能会更加注意到 Lisp 里代码就是放在 Lisp 列表中：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;;; 生成一个有着 1, 2 两个元素的列表
(list 1 (+ 1 1)) ;; =&amp;gt; (1 2)
;; 生成一个有着 +, 1, 1 三个元素的列表，结果看起来和 (+ 1 1) 函数调用一模一样？！
(list + 1 1) ;; =&amp;gt; (+ 1 1)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好吧，这有什么用呢？通常来说要有用一般会跟另一个设定结合在一起，就是引用。&lt;/p&gt;&lt;p&gt;引用的非常贴合现实的例子就是双引号“”，例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;说出你的名字&lt;/li&gt;&lt;li&gt;说出“你的名字”&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那么两者的意义是不同的，说出你的名字背后指代的名字和“你的名字”这个符号本身。
而在 Lisp 中一般用 &lt;code&gt;quote&lt;/code&gt; 来实现“引用”的效果。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;;; 定义一个符号叫你的名字指代 SouthFox
(define 你的名字 &amp;quot;SouthFox&amp;quot;)
你的名字 ;; =&amp;gt; &amp;quot;SouthFox&amp;quot;
;; 注意是 你的名字 符号本身而不是 &amp;quot;你的名字&amp;quot; 字符串
(quote 你的名字) ;; =&amp;gt; 你的名字
(quote (1 2 3)) ;; =&amp;gt; (1 2 3)
(quote (list 1 2 3)) ;; =&amp;gt; (list 1 2 3)&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;实践，以Python为例&quot;&gt;实践，以 Python 为例&lt;/h4&gt;&lt;p&gt;好吧好吧，现在有了构建在列表上的语言还有“引用”，那么这又有什么用呢？
现在就有用了：可以将代码和数据「混为一谈」。&lt;/p&gt;&lt;p&gt;为了降低点圆括号恐惧和尽量贴合「现代」开发者，
接下来以 Python 结合 Lisp 语法类比一个叫 Lithon 的语言（如有雷同纯属巧合），那么看起来像是这样的：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;[+, 1, 1] # =&amp;gt; 2
[list, 1, [+, 1, 1]] # =&amp;gt; [1, 2]
[list, +, 1, 1] # =&amp;gt; [+, 1, 1]
[=, 你的名字, &amp;quot;SouthFox&amp;quot;] # 你的名字 = &amp;quot;SouthFox&amp;quot;
你的名字 # =&amp;gt; &amp;quot;SouthFox&amp;quot;
[quote, 你的名字] # =&amp;gt; 你的名字&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后想一下，在 Python 中有多少次写下 &lt;code&gt;if not ...:&lt;/code&gt; 了呢？看到相应的代码总会卡顿一下来想一下对应逻辑，如果想要更贴近自然语言
声明一个叫做 unless（除非） 的语法,当后面的判断不为真时才运行后面代码。在 Python 中，可能只能提个 PEP 祈祷委员会能够通过吧，
不过应该也不太可能了……&lt;/p&gt;&lt;p&gt;但在 Lithon 中，通过数据即代码和引用机制再配上一个叫做宏的机制，可以轻松定义属于自己的语法。宏的定义很简单，可以粗略理解成特化的
函数，不过将传进来的参数当作 &lt;strong&gt;数据&lt;/strong&gt; 而不是当成 &lt;strong&gt;代码&lt;/strong&gt; ，如：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 定义一个叫 unless 的宏，接收两个列表参数，判断体 test 、逻辑体 body
[def-macro, unless, [test, body],
    [return,
     [list,
      # if 和 not 需要被当成数据而不是一个调用，所以需要被 quote
      [[quote, if], [[quote, not], test],
       body]]]
]

# 如果 1 + 1 不等于 2 ，那么……
[unless, [==, [+, 1, 1], 2],
    [print, &amp;quot;数学不存在了！&amp;quot;],
]

# 背后会被宏操作成
[if, [not, [==, [+, 1, 1], 2]],
    [print, &amp;quot;数学不存在了！&amp;quot;],
]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就是 Lisp 的将代码当成数据的好处，如果有什么地方感到不便那就让它方便，不需要求助于什么语言委员会的讨论、协商、发布。&lt;/p&gt;&lt;h5 id=&quot;一个更复杂的例子&quot;&gt;一个更复杂的例子&lt;/h5&gt;&lt;p&gt;考虑 Lisp 是一个可以像俄罗斯套娃的叠叠乐的语言，所以可能一不小心写出让人眼晕的代码，例如以我现在的博客一个真实例子，
将 &lt;code&gt;posts/2025/09/hello-haunt.org&lt;/code&gt; 这样的文件路径处理成 &lt;code&gt;2025/09/hello-haunt/&lt;/code&gt; 的形式来作为博客文章的 uri，
用 Lithon 来写可能会出这样的代码：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 规定用 [.bar, foo] 来表示调用 foo 实例下的 bar ，如 foo.bar -&amp;gt; [.bar foo]
# 规定取一个数组的元素有 get 函数，如 foo[1] -&amp;gt; [get, foo, 1]
[+,
 [.strip,
  [get,
   [.split &amp;quot;posts/2025/09/hello-haunt.org&amp;quot; &amp;quot;posts/&amp;quot;], -1],
  &amp;quot;.org&amp;quot;],
 &amp;quot;/&amp;quot;,]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到因为 Lisp 的表示法形成了一个由内到外的执行顺序,但盯着这串括括又号号可以注意到实际上里层的调用都会处在外层
调用的第一个参数上，那么有这样规律就可以请出宏了。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# 还记得 python 的函数声明的不定长参数吗，* 在函数参数声明上表示将元素收集进一个元组里
# 同时也可以用 * 在列表旁来表示对一个列表将其「展平」
# def test_args(first, *rest):
#     print(&amp;quot;first is:&amp;quot;, first)
#     print(&amp;quot;rest is:&amp;quot;, rest)
#
# test_args(1, 2, 3)
# =&amp;gt; &amp;quot;first is: 1&amp;quot;
# =&amp;gt; &amp;quot;rest is: (2, 3)&amp;quot;
#
# test_args(1)
# =&amp;gt; &amp;quot;first is: 1&amp;quot;
# =&amp;gt; &amp;quot;rest is: ()&amp;quot;
#
# test_args(*[1, 2, 3]) 等价于 test_args(1, 2, 3)
# =&amp;gt; &amp;quot;first is: 1&amp;quot;
# =&amp;gt; &amp;quot;rest is: (2, 3)&amp;quot;

[def-macro, -&amp;gt;, [first, *body],
 [if, [==, 0, [len, body]],
      [return, [list, first]],
  else,
      # 递归处理剩下的元素
      [return,
       [list,
        [quote, -&amp;gt;],
        [list,
         # 将第一个元素的第一项作为一个调用的函数部分
         [get, [get, body, 0], 0],
         # 将 -&amp;gt; 宏的第一个参数作为调用的第一个参数
         first,
          # 将第一个元素的剩余元素作为调用的剩余参数「粘」到后面
         *[get, [get, body, 0], 1:]],
        # 剩余元素作为下一个 -&amp;gt; 调用的不定长参数
        *[get, body, 1:],
       ],
 ],
]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起来有点绕，但其实思想很简单。将传进来的列表进行判断，如果只传进来一个参数则返回本身，如果不为一个就处理一下
将第一个参数作为后续的第一个调用的参数，然后相同逻辑处理剩下的部分。接下来用这个定义的 &lt;code&gt;-&amp;gt;&lt;/code&gt; 宏来重写那个处理
文章路径的例子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;[-&amp;gt;, [.split, &amp;quot;posts/2025/09/hello-haunt.org&amp;quot;, &amp;quot;posts/&amp;quot;],
     [get, -1],
     [.strip, &amp;quot;.org&amp;quot;],
     [+, &amp;quot;/&amp;quot;],
 ]

# 一步步展开，实际上等于以下过程……
[-&amp;gt;, [get, [.split, &amp;quot;posts/2025/09/hello-haunt.org&amp;quot; &amp;quot;posts/&amp;quot;], -1],
     [.strip, &amp;quot;.org&amp;quot;],
     [+, &amp;quot;/&amp;quot;],
]

[-&amp;gt;, [.strip, [get, [.split, &amp;quot;posts/2025/09/hello-haunt.org&amp;quot;, &amp;quot;posts/&amp;quot;], -1], &amp;quot;.org&amp;quot;],
     [+, &amp;quot;/&amp;quot;],
]

[-&amp;gt;, [+, [.strip, [get, [.split, &amp;quot;posts/2025/09/hello-haunt.org&amp;quot;, &amp;quot;posts/&amp;quot;], -1], &amp;quot;.org&amp;quot;], &amp;quot;/&amp;quot;]
]

[+, [.strip, [get, [.split, &amp;quot;posts/2025/09/hello-haunt.org&amp;quot;, &amp;quot;posts/&amp;quot;], -1], &amp;quot;.org&amp;quot;], &amp;quot;/&amp;quot;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 &lt;code&gt;-&amp;gt;&lt;/code&gt; 宏，可以将嵌套的表示调整为并排的表示，能做到这样也是因为可以将代码和数据混在一起。
如果更有想象力一点，捣鼓出类似 Shell 管道 &lt;code&gt;|&lt;/code&gt; 的表示形式也是可以的，我就不把这个作为课后作业了（&lt;/p&gt;&lt;h2 id=&quot;SXML&quot;&gt;SXML&lt;/h2&gt;&lt;p&gt;当然数据即代码首先也得有数据才行， Haunt 实际上对博文所用的文本格式并没有什么限制，只要提供一个分析器将文本解析成 SXML 形式的数
据就可以了。
SXML 实际就是在用 Scheme 的形式来描述 XML （HTML 也是一种 XML）。最后通过 sxml-&amp;gt;html 的函数将 SXML 形式的数据
转换成 HTML 文档：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;;; 因为 quote 很常用所以很多 Lisp 语言都提供便捷形式 ' 来方便操作
;; 如 '(+ 1 1) 等价于 (quote (+ 1 1))

(define doc
  '(html
    (body
     (h1 &amp;quot;Hello World!&amp;quot;)
     (p
      ;; sxml 用 @ 来表示标签内的属性
      (a (@ (href &amp;quot;https://blog.southfox.me&amp;quot;))
           &amp;quot;My Blog.&amp;quot;)))))

(sxml-&amp;gt;html doc)
;; =&amp;gt; &amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;lt;p&amp;gt;&amp;lt;a href=&amp;quot;https://blog.southfox.me&amp;quot;&amp;gt;My Blog.&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;doc&lt;/code&gt; 数据里面的 &lt;code&gt;h1&lt;/code&gt; 、 &lt;code&gt;p&lt;/code&gt; 等并不是函数，而只是用来表述 HTML 标签，数据和代码的分界线就此模糊了……&lt;/p&gt;&lt;h3 id=&quot;模板&quot;&gt;模板&lt;/h3&gt;&lt;p&gt;当然一个合格的静态博客生成器还需要一个模板系统来管理复杂度并进行复用，但 Scheme 作为一个 Lisp 模板已
经天然支持了，这就是 &lt;code&gt;准引用&lt;/code&gt; （quasiquote）系统。行为其实跟 &lt;code&gt;'&lt;/code&gt; 类似，但会在遇到 &lt;code&gt;,&lt;/code&gt; 逗号的时候对
后面的部分进行调用，例如：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;`(1 2 3) ; =&amp;gt; (1 2 3)
`(1 2 ,(+ 1 2)) ; =&amp;gt; (1 2 3)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有这种语法，就不需要什么 EJS 或者 GO 模板文件还有什么 &lt;code&gt;${...}&lt;/code&gt; 了，模板和代码可以轻松交织在一起：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;(define (page-template content)
  `(div (@ (class &amp;quot;page&amp;quot;))
    (div (@ (class &amp;quot;content&amp;quot;))
         ,content)))

(sxml-&amp;gt;html (page-template '(p &amp;quot;Hello world!&amp;quot;)))
;; =&amp;gt; &amp;lt;div class=&amp;quot;page&amp;quot;&amp;gt;&amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过这种不知天地为何物的序列反序列法，在心智上还是挺让人愉悦的，因为可以使用一种一致的方式来统合整个站点。
不过还是让我赶快谈谈自己鼓捣的玩意吧。&lt;/p&gt;&lt;h2 id=&quot;博客之折腾&quot;&gt;博客之折腾&lt;/h2&gt;&lt;h3 id=&quot;shortcode&quot;&gt;shortcode&lt;/h3&gt;&lt;p&gt;Haunt 默认用的解析器只支持基本的语法在功能上非常欠缺，例如一直用到现在的摘要功能，Haunt 是没有原生支持的。
不过还好里面的流程是可以替换的，所以我往文本解析器的加了 &lt;code&gt;shortcode&lt;/code&gt; （叫法来源 Hugo) 的规则，匹配类似
&lt;code&gt;,(...)&lt;/code&gt; 这样的形式。在匹配到的后根据里面的内容，例如： &lt;code&gt;,(read-more)&lt;/code&gt; 就会生成转化成 id 为 more 的
span 数据 &lt;code&gt;`(span (@ (id &amp;quot;more&amp;quot;)))&lt;/code&gt; 来方便后续生成主页的时候进行根据文章的 sxml 进行判断。&lt;/p&gt;&lt;p&gt;当然除了阅读更多我还额外鼓捣了个嵌入长毛象帖文的 &lt;code&gt;shortcode&lt;/code&gt; ，调用类似于 &lt;code&gt;,(mastodon-embed ...)&lt;/code&gt;
其实底层只是把 mastodon embed 的 HTML 转成 sxml 而已……&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-scheme&quot;&gt;(define (mastodon-embed url)
  `(div
    (blockquote
     (@ (style &amp;quot;background: #FCF8FF; border-radius: 8px; border: 1px solid #C9C4DA; margin: 0; max-width: 540px; min-width: 270px; overflow: hidden; padding: 0;&amp;quot;)
        (data-embed-url ,(string-append url &amp;quot;/embed&amp;quot;))
        (class &amp;quot;mastodon-embed&amp;quot;)) &amp;quot; &amp;quot;
     (a (@ (target &amp;quot;_blank&amp;quot;)
           (style &amp;quot;align-items: center; color: #1C1A25; display: flex; flex-direction: column; font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Oxygen, Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', Roboto, sans-serif; font-size: 14px; justify-content: center; letter-spacing: 0.25px; line-height: 20px; padding: 24px; text-decoration: none;&amp;quot;)
           (href ,url)) &amp;quot; &amp;quot;
           (svg
            (@ (xmlns &amp;quot;http://www.w3.org/2000/svg:svg&amp;quot; )
               (xmlns:xlink &amp;quot;http://www.w3.org/1999/xlink&amp;quot;)
               (width &amp;quot;32&amp;quot;)
               (viewBox &amp;quot;0 0 79 75&amp;quot;)
               (height &amp;quot;32&amp;quot;))
            (path
             (@ (fill &amp;quot;currentColor&amp;quot;)
                (d &amp;quot;M63 45.3v-20c0-4.1-1-7.3-3.2-9.7-2.1-2.4-5-3.7-8.5-3.7-4.1 0-7.2 1.6-9.3 4.7l-2 3.3-2-3.3c-2-3.1-5.1-4.7-9.2-4.7-3.5 0-6.4 1.3-8.6 3.7-2.1 2.4-3.1 5.6-3.1 9.7v20h8V25.9c0-4.1 1.7-6.2 5.2-6.2 3.8 0 5.8 2.5 5.8 7.4V37.7H44V27.1c0-4.9 1.9-7.4 5.8-7.4 3.5 0 5.2 2.1 5.2 6.2V45.3h8ZM74.7 16.6c.6 6 .1 15.7.1 17.3 0 .5-.1 4.8-.1 5.3-.7 11.5-8 16-15.6 17.5-.1 0-.2 0-.3 0-4.9 1-10 1.2-14.9 1.4-1.2 0-2.4 0-3.6 0-4.8 0-9.7-.6-14.4-1.7-.1 0-.1 0-.1 0s-.1 0-.1 0 0 .1 0 .1 0 0 0 0c.1 1.6.4 3.1 1 4.5.6 1.7 2.9 5.7 11.4 5.7 5 0 9.9-.6 14.8-1.7 0 0 0 0 0 0 .1 0 .1 0 .1 0 0 .1 0 .1 0 .1.1 0 .1 0 .1.1v5.6s0 .1-.1.1c0 0 0 0 0 .1-1.6 1.1-3.7 1.7-5.6 2.3-.8.3-1.6.5-2.4.7-7.5 1.7-15.4 1.3-22.7-1.2-6.8-2.4-13.8-8.2-15.5-15.2-.9-3.8-1.6-7.6-1.9-11.5-.6-5.8-.6-11.7-.8-17.5C3.9 24.5 4 20 4.9 16 6.7 7.9 14.1 2.2 22.3 1c1.4-.2 4.1-1 16.5-1h.1C51.4 0 56.7.8 58.1 1c8.4 1.2 15.5 7.5 16.6 15.6Z&amp;quot;))))
           &amp;quot; &amp;quot;
           (div (@ (style &amp;quot;color: #787588; margin-top: 16px;&amp;quot;)) &amp;quot;Post by SouthFox&amp;quot;) &amp;quot; &amp;quot;
           (div (@ (style &amp;quot;font-weight: 500;&amp;quot;)) &amp;quot;View on Mastodon&amp;quot;) &amp;quot; &amp;quot;) &amp;quot; &amp;quot;)
    (script (@ (data-allowed-prefixes &amp;quot;https://foxsay.southfox.me/&amp;quot;)
               (async &amp;quot;true&amp;quot;)
               (src &amp;quot;https://foxsay.southfox.me/embed.js&amp;quot;)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样我在文章里写出 &lt;code&gt;,(mastodon-embed https://foxsay.southfox.me/@SouthFox/115167732215186876)&lt;/code&gt;
时就会产生类似下面的效果。&lt;/p&gt;&lt;div&gt;&lt;blockquote style=&quot;background: #FCF8FF; border-radius: 8px; border: 1px solid #C9C4DA; margin: 0; max-width: 540px; min-width: 270px; overflow: hidden; padding: 0;&quot; data-embed-url=&quot;https://foxsay.southfox.me/@SouthFox/115167732215186876/embed&quot; class=&quot;mastodon-embed&quot;&gt; &lt;a target=&quot;_blank&quot; style=&quot;align-items: center; color: #1C1A25; display: flex; flex-direction: column; font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Oxygen, Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', Roboto, sans-serif; font-size: 14px; justify-content: center; letter-spacing: 0.25px; line-height: 20px; padding: 24px; text-decoration: none;&quot; href=&quot;https://foxsay.southfox.me/@SouthFox/115167732215186876&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg:svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;32&quot; viewBox=&quot;0 0 79 75&quot; height=&quot;32&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M63 45.3v-20c0-4.1-1-7.3-3.2-9.7-2.1-2.4-5-3.7-8.5-3.7-4.1 0-7.2 1.6-9.3 4.7l-2 3.3-2-3.3c-2-3.1-5.1-4.7-9.2-4.7-3.5 0-6.4 1.3-8.6 3.7-2.1 2.4-3.1 5.6-3.1 9.7v20h8V25.9c0-4.1 1.7-6.2 5.2-6.2 3.8 0 5.8 2.5 5.8 7.4V37.7H44V27.1c0-4.9 1.9-7.4 5.8-7.4 3.5 0 5.2 2.1 5.2 6.2V45.3h8ZM74.7 16.6c.6 6 .1 15.7.1 17.3 0 .5-.1 4.8-.1 5.3-.7 11.5-8 16-15.6 17.5-.1 0-.2 0-.3 0-4.9 1-10 1.2-14.9 1.4-1.2 0-2.4 0-3.6 0-4.8 0-9.7-.6-14.4-1.7-.1 0-.1 0-.1 0s-.1 0-.1 0 0 .1 0 .1 0 0 0 0c.1 1.6.4 3.1 1 4.5.6 1.7 2.9 5.7 11.4 5.7 5 0 9.9-.6 14.8-1.7 0 0 0 0 0 0 .1 0 .1 0 .1 0 0 .1 0 .1 0 .1.1 0 .1 0 .1.1v5.6s0 .1-.1.1c0 0 0 0 0 .1-1.6 1.1-3.7 1.7-5.6 2.3-.8.3-1.6.5-2.4.7-7.5 1.7-15.4 1.3-22.7-1.2-6.8-2.4-13.8-8.2-15.5-15.2-.9-3.8-1.6-7.6-1.9-11.5-.6-5.8-.6-11.7-.8-17.5C3.9 24.5 4 20 4.9 16 6.7 7.9 14.1 2.2 22.3 1c1.4-.2 4.1-1 16.5-1h.1C51.4 0 56.7.8 58.1 1c8.4 1.2 15.5 7.5 16.6 15.6Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;div style=&quot;color: #787588; margin-top: 16px;&quot;&gt;Post by SouthFox&lt;/div&gt; &lt;div style=&quot;font-weight: 500;&quot;&gt;View on Mastodon&lt;/div&gt; &lt;/a&gt; &lt;/blockquote&gt;&lt;script data-allowed-prefixes=&quot;https://foxsay.southfox.me/&quot; async=&quot;true&quot; src=&quot;https://foxsay.southfox.me/embed.js&quot;&gt;&lt;/script&gt;&lt;/div&gt;&lt;h3 id=&quot;外观&quot;&gt;外观&lt;/h3&gt;&lt;p&gt;在外观上我还是继续沿用了 &lt;a href=&quot;https://github.com/blackshow/hexo-theme-freemind.386&quot;&gt;Freemide.386&lt;/a&gt; 这个主题，不过因为从零开始写样式可以直接使用 css 里的 &lt;code&gt;media query&lt;/code&gt; 来
进行响应式布局而不必引用 bootstrap 的一大坨 css 和 js 了。&lt;/p&gt;&lt;p&gt;导航栏上我参考了另一个同样使用 Haunt 框架的博客 &lt;a href=&quot;https://bendersteed.gr/&quot;&gt;bendersteed.gr&lt;/a&gt; 来配置，这还真是令我吃惊没想到现在 css 已经可以
做到这种程度了吗？不过转念一想出现过的 &lt;a href=&quot;https://benjaminaster.com/css-minecraft/&quot;&gt;CSS Minecraft&lt;/a&gt; 这种项目就有点释然了，迟早有一天 css 能带上着色器或者光线追
踪啥的。&lt;/p&gt;&lt;h3 id=&quot;侧边栏&quot;&gt;侧边栏&lt;/h3&gt;&lt;p&gt;对于侧边栏我我现在没有想好要做什么，只是出于之前的主题有所以得做上去。可能真正有用的是标签和目录功能，
目录功能实现很简单：直接一个循环然后判断文章的 sxml 有没有带 &lt;code&gt;id&lt;/code&gt; 属性同时以 &lt;code&gt;h&lt;/code&gt; 开头的符号，是的
话就收集到一个列表里然后转换成 HTML的 &lt;code&gt;ul&lt;/code&gt; 列表放到侧边栏。&lt;/p&gt;&lt;h3 id=&quot;评论区&quot;&gt;评论区&lt;/h3&gt;&lt;p&gt;对于评论区现在只适配了之前提到的 &lt;a href=&quot;/2022/01/为博客支持评论系统/&quot;&gt;为博客支持评论系统&lt;/a&gt; &lt;code&gt;Giscus&lt;/code&gt; 的评论系统，而基于 &lt;a href=&quot;/2023/06/使用 Mastodon 作为博客的评论系统/&quot;&gt;使用 Mastodon 作为博客的评论系统&lt;/a&gt; 我还在犹豫
要不要集成，因为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;基于 js ，我还在考虑要不要引入 js ，可能引入也得以一个更 lisp 的手段例如 &lt;a href=&quot;https://lips.js.org/&quot;&gt;LIPS&lt;/a&gt; 或者 &lt;a href=&quot;https://spritely.institute/hoot/&quot;&gt;Hoot&lt;/a&gt; ？&lt;/li&gt;&lt;li&gt;麻烦，流程上还是得先去自己实例获取帖文的 url 才行，这样就需要额外编辑一次，在没想到更好的自动化方案之前还是有点不想集成了。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;org-mode&quot;&gt;org-mode&lt;/h3&gt;&lt;p&gt;其实只是把别人搞的用于解析 commonmark 的解析器 &lt;a href=&quot;https://github.com/OrangeShark/guile-commonmark&quot;&gt;GitHub - OrangeShark/guile-commonmark&lt;/a&gt; 给复制了一份然后
改了一下相应规则，感想是我确实对编译器相关不太感冒，看着相关代码然后不停尝试加点 org-mode 语法有点让脑子爆炸
了。不过就算是这样也只适配了 org-mode 的基本语法，标题、代码块、引用块啥的。支持 org-mode 全部语法可不敢想，
这可是让人堕入地狱的想法啊……&lt;/p&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://awesome.haunt.page/&quot;&gt;Awesome Haunt&lt;/a&gt; 同样使用 Haunt 框架的站点索引页&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/2025/04/emacs-lisp-elements/&quot;&gt;Emacs lisp 原本&lt;/a&gt; Emacs lisp 教程&lt;/li&gt;&lt;/ul&gt;</content></entry><entry><title>Steam Deck 可劲折腾</title><id>https://blog.southfox.me/2025/05/configure-steam-deck/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2025-05-26T11:40:00Z</updated><link href="https://blog.southfox.me/2025/05/configure-steam-deck/.html" rel="alternate" /><content type="html">&lt;blockquote&gt;&lt;p&gt;多年以后，面对着 steam deck，我都将想起起一七一八年在 linux 为了打游戏的折腾的那个下午，什么 prime-run 啊什么调 winecfg 啊……&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;谁能想象 Steam Deck 就这么成为了 &lt;code&gt;echo &amp;quot;$(( $(date +%Y) + 1 )) is the year for Linux gaming\!&amp;quot;&lt;/code&gt; 最有力的推手呢？&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;h3 id=&quot;折腾，开始！&quot;&gt;折腾，开始！&lt;/h3&gt;&lt;p&gt;Steam Deck 默认搭载了基于 Arch 的系统（BTW...） SteamOS ，除了一些刚出的热门「大作」和不愿兼容反作弊的游戏， Steam Deck 的运行效果已经很难让人相信是一台 Linux 游戏机了。&lt;/p&gt;&lt;p&gt;不过既然基于 Arch 那么就该让我鼓捣下了吧，没成想这成为了我这半年最大折腾的开始……&lt;/p&gt;&lt;h3 id=&quot;打折教父的魔法&quot;&gt;打折教父的魔法&lt;/h3&gt;&lt;p&gt;一开始我还时把 Steam Deck 当成一个普通的 Linux 设备把玩的，首先按下 Steam 键到电源设置进入桌面环境，熟悉的 KDE 桌面扑面而来，然后就是打开里面的终端然后开始安装 Emacs （不然呢？），
然后发现 Steam Deck 首先需要设置一个密码然后关闭只读模式（那时我对不可变系统没什么概念）执行一些换源操作 balabala ，大概差不多是这个样子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;passwd
sudo steamos-readonly disable
sudo pacman-key --init
sudo pacman-key --populate archlinux
sudo pacman-key --populate holo
sudo pacman -S emacs&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行完后就装上了熟悉的紫薯布丁，然后顺便想着配配代理吧然后装上 yay 开始鼓捣，最后发现菜单里更新通道可以选择稳定还是预览，作为一个滚动更新享受者我就换成了预览通道，安装更新，重启之后继续用着几天我就发现不对劲了：&lt;/p&gt;&lt;div&gt;&lt;blockquote style=&quot;background: #FCF8FF; border-radius: 8px; border: 1px solid #C9C4DA; margin: 0; max-width: 540px; min-width: 270px; overflow: hidden; padding: 0;&quot; data-embed-url=&quot;https://foxsay.southfox.me/@SouthFox/112997597522720272/embed&quot; class=&quot;mastodon-embed&quot;&gt; &lt;a target=&quot;_blank&quot; style=&quot;align-items: center; color: #1C1A25; display: flex; flex-direction: column; font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Oxygen, Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', Roboto, sans-serif; font-size: 14px; justify-content: center; letter-spacing: 0.25px; line-height: 20px; padding: 24px; text-decoration: none;&quot; href=&quot;https://foxsay.southfox.me/@SouthFox/112997597522720272&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg:svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;32&quot; viewBox=&quot;0 0 79 75&quot; height=&quot;32&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M63 45.3v-20c0-4.1-1-7.3-3.2-9.7-2.1-2.4-5-3.7-8.5-3.7-4.1 0-7.2 1.6-9.3 4.7l-2 3.3-2-3.3c-2-3.1-5.1-4.7-9.2-4.7-3.5 0-6.4 1.3-8.6 3.7-2.1 2.4-3.1 5.6-3.1 9.7v20h8V25.9c0-4.1 1.7-6.2 5.2-6.2 3.8 0 5.8 2.5 5.8 7.4V37.7H44V27.1c0-4.9 1.9-7.4 5.8-7.4 3.5 0 5.2 2.1 5.2 6.2V45.3h8ZM74.7 16.6c.6 6 .1 15.7.1 17.3 0 .5-.1 4.8-.1 5.3-.7 11.5-8 16-15.6 17.5-.1 0-.2 0-.3 0-4.9 1-10 1.2-14.9 1.4-1.2 0-2.4 0-3.6 0-4.8 0-9.7-.6-14.4-1.7-.1 0-.1 0-.1 0s-.1 0-.1 0 0 .1 0 .1 0 0 0 0c.1 1.6.4 3.1 1 4.5.6 1.7 2.9 5.7 11.4 5.7 5 0 9.9-.6 14.8-1.7 0 0 0 0 0 0 .1 0 .1 0 .1 0 0 .1 0 .1 0 .1.1 0 .1 0 .1.1v5.6s0 .1-.1.1c0 0 0 0 0 .1-1.6 1.1-3.7 1.7-5.6 2.3-.8.3-1.6.5-2.4.7-7.5 1.7-15.4 1.3-22.7-1.2-6.8-2.4-13.8-8.2-15.5-15.2-.9-3.8-1.6-7.6-1.9-11.5-.6-5.8-.6-11.7-.8-17.5C3.9 24.5 4 20 4.9 16 6.7 7.9 14.1 2.2 22.3 1c1.4-.2 4.1-1 16.5-1h.1C51.4 0 56.7.8 58.1 1c8.4 1.2 15.5 7.5 16.6 15.6Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;div style=&quot;color: #787588; margin-top: 16px;&quot;&gt;Post by SouthFox&lt;/div&gt; &lt;div style=&quot;font-weight: 500;&quot;&gt;View on Mastodon&lt;/div&gt; &lt;/a&gt; &lt;/blockquote&gt;&lt;script data-allowed-prefixes=&quot;https://foxsay.southfox.me/&quot; async=&quot;true&quot; src=&quot;https://foxsay.southfox.me/embed.js&quot;&gt;&lt;/script&gt;&lt;/div&gt;&lt;p&gt;没成想重启之后发现所有的东西都消失了，我的紫薯布丁还有 yay 的一众配置，最后东翻翻西翻翻才发现 Steam Deck 的升级策略类似现在某些安卓手机厂商的 AB 升级策略，系统分区会制作 AB 两份，升级时处在 A 状态时只升 B 完成升级后切换成 B ，好处就是可以优雅回滚，坏处就是占用双份空间还有……配置会被刷掉。感觉就像是灰姑娘里仙女教母施展的魔法，过了零点，所有东西都将回归原样。&lt;/p&gt;&lt;h3 id=&quot;感觉不太能开箱的箱子&quot;&gt;感觉不太能开箱的箱子&lt;/h3&gt;&lt;p&gt;这可就傻眼了，没办法只好去找找替代方案了：&lt;/p&gt;&lt;div&gt;&lt;blockquote style=&quot;background: #FCF8FF; border-radius: 8px; border: 1px solid #C9C4DA; margin: 0; max-width: 540px; min-width: 270px; overflow: hidden; padding: 0;&quot; data-embed-url=&quot;https://foxsay.southfox.me/@southfox/113061467070774840/embed&quot; class=&quot;mastodon-embed&quot;&gt; &lt;a target=&quot;_blank&quot; style=&quot;align-items: center; color: #1C1A25; display: flex; flex-direction: column; font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Oxygen, Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', Roboto, sans-serif; font-size: 14px; justify-content: center; letter-spacing: 0.25px; line-height: 20px; padding: 24px; text-decoration: none;&quot; href=&quot;https://foxsay.southfox.me/@southfox/113061467070774840&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg:svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;32&quot; viewBox=&quot;0 0 79 75&quot; height=&quot;32&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M63 45.3v-20c0-4.1-1-7.3-3.2-9.7-2.1-2.4-5-3.7-8.5-3.7-4.1 0-7.2 1.6-9.3 4.7l-2 3.3-2-3.3c-2-3.1-5.1-4.7-9.2-4.7-3.5 0-6.4 1.3-8.6 3.7-2.1 2.4-3.1 5.6-3.1 9.7v20h8V25.9c0-4.1 1.7-6.2 5.2-6.2 3.8 0 5.8 2.5 5.8 7.4V37.7H44V27.1c0-4.9 1.9-7.4 5.8-7.4 3.5 0 5.2 2.1 5.2 6.2V45.3h8ZM74.7 16.6c.6 6 .1 15.7.1 17.3 0 .5-.1 4.8-.1 5.3-.7 11.5-8 16-15.6 17.5-.1 0-.2 0-.3 0-4.9 1-10 1.2-14.9 1.4-1.2 0-2.4 0-3.6 0-4.8 0-9.7-.6-14.4-1.7-.1 0-.1 0-.1 0s-.1 0-.1 0 0 .1 0 .1 0 0 0 0c.1 1.6.4 3.1 1 4.5.6 1.7 2.9 5.7 11.4 5.7 5 0 9.9-.6 14.8-1.7 0 0 0 0 0 0 .1 0 .1 0 .1 0 0 .1 0 .1 0 .1.1 0 .1 0 .1.1v5.6s0 .1-.1.1c0 0 0 0 0 .1-1.6 1.1-3.7 1.7-5.6 2.3-.8.3-1.6.5-2.4.7-7.5 1.7-15.4 1.3-22.7-1.2-6.8-2.4-13.8-8.2-15.5-15.2-.9-3.8-1.6-7.6-1.9-11.5-.6-5.8-.6-11.7-.8-17.5C3.9 24.5 4 20 4.9 16 6.7 7.9 14.1 2.2 22.3 1c1.4-.2 4.1-1 16.5-1h.1C51.4 0 56.7.8 58.1 1c8.4 1.2 15.5 7.5 16.6 15.6Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;div style=&quot;color: #787588; margin-top: 16px;&quot;&gt;Post by SouthFox&lt;/div&gt; &lt;div style=&quot;font-weight: 500;&quot;&gt;View on Mastodon&lt;/div&gt; &lt;/a&gt; &lt;/blockquote&gt;&lt;script data-allowed-prefixes=&quot;https://foxsay.southfox.me/&quot; async=&quot;true&quot; src=&quot;https://foxsay.southfox.me/embed.js&quot;&gt;&lt;/script&gt;&lt;/div&gt;&lt;p&gt;然后发现新版本的 SteamOS 内置了 distrobox 这个程序可以用容器建立一个系统在里面执行一个程序，折腾来折腾去发现 distrobox 里带 systemd 的系统总有些问题，最后发现既然 distrobox 依托于 podman 为什么不直接在外面操作 podman 呢？&lt;/p&gt;&lt;div&gt;&lt;blockquote style=&quot;background: #FCF8FF; border-radius: 8px; border: 1px solid #C9C4DA; margin: 0; max-width: 540px; min-width: 270px; overflow: hidden; padding: 0;&quot; data-embed-url=&quot;https://foxsay.southfox.me/@SouthFox/113091661012546611/embed&quot; class=&quot;mastodon-embed&quot;&gt; &lt;a target=&quot;_blank&quot; style=&quot;align-items: center; color: #1C1A25; display: flex; flex-direction: column; font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Oxygen, Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', Roboto, sans-serif; font-size: 14px; justify-content: center; letter-spacing: 0.25px; line-height: 20px; padding: 24px; text-decoration: none;&quot; href=&quot;https://foxsay.southfox.me/@SouthFox/113091661012546611&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg:svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;32&quot; viewBox=&quot;0 0 79 75&quot; height=&quot;32&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M63 45.3v-20c0-4.1-1-7.3-3.2-9.7-2.1-2.4-5-3.7-8.5-3.7-4.1 0-7.2 1.6-9.3 4.7l-2 3.3-2-3.3c-2-3.1-5.1-4.7-9.2-4.7-3.5 0-6.4 1.3-8.6 3.7-2.1 2.4-3.1 5.6-3.1 9.7v20h8V25.9c0-4.1 1.7-6.2 5.2-6.2 3.8 0 5.8 2.5 5.8 7.4V37.7H44V27.1c0-4.9 1.9-7.4 5.8-7.4 3.5 0 5.2 2.1 5.2 6.2V45.3h8ZM74.7 16.6c.6 6 .1 15.7.1 17.3 0 .5-.1 4.8-.1 5.3-.7 11.5-8 16-15.6 17.5-.1 0-.2 0-.3 0-4.9 1-10 1.2-14.9 1.4-1.2 0-2.4 0-3.6 0-4.8 0-9.7-.6-14.4-1.7-.1 0-.1 0-.1 0s-.1 0-.1 0 0 .1 0 .1 0 0 0 0c.1 1.6.4 3.1 1 4.5.6 1.7 2.9 5.7 11.4 5.7 5 0 9.9-.6 14.8-1.7 0 0 0 0 0 0 .1 0 .1 0 .1 0 0 .1 0 .1 0 .1.1 0 .1 0 .1.1v5.6s0 .1-.1.1c0 0 0 0 0 .1-1.6 1.1-3.7 1.7-5.6 2.3-.8.3-1.6.5-2.4.7-7.5 1.7-15.4 1.3-22.7-1.2-6.8-2.4-13.8-8.2-15.5-15.2-.9-3.8-1.6-7.6-1.9-11.5-.6-5.8-.6-11.7-.8-17.5C3.9 24.5 4 20 4.9 16 6.7 7.9 14.1 2.2 22.3 1c1.4-.2 4.1-1 16.5-1h.1C51.4 0 56.7.8 58.1 1c8.4 1.2 15.5 7.5 16.6 15.6Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;div style=&quot;color: #787588; margin-top: 16px;&quot;&gt;Post by SouthFox&lt;/div&gt; &lt;div style=&quot;font-weight: 500;&quot;&gt;View on Mastodon&lt;/div&gt; &lt;/a&gt; &lt;/blockquote&gt;&lt;script data-allowed-prefixes=&quot;https://foxsay.southfox.me/&quot; async=&quot;true&quot; src=&quot;https://foxsay.southfox.me/embed.js&quot;&gt;&lt;/script&gt;&lt;/div&gt;&lt;p&gt;但最后发现 podman 也有些问题，首先就是 podman 即使设置为 &lt;code&gt;restart-policy=always&lt;/code&gt; 的 pod 在开机时也不会拉起，因为这是由一个 systemd service 执行的，而这个 service 也是 steamOS 的一部分，即使 enable 后在系统更新后也会回归原样（那个时候还不晓得 &lt;code&gt;/etc/systemd/system&lt;/code&gt; 的目录是不受升级策略影响的）……&lt;/p&gt;&lt;p&gt;折腾到最后发现其实也不需要 root 权限执行代理程序，因为 Steam Deck 在配置菜单里可以指定代理至少让 Steam 的流量全走指定的代理，同时还发现 &lt;code&gt;/home&lt;/code&gt; 目录不受更新影响，然后发现 podman 也带了一个快要被废弃的导出 systemd 配置生成功能，那就放到用户级别的 systemd service 文件到 &lt;code&gt;~/.config/systemd/user&lt;/code&gt; 里设成 enable 就能开机自动运行了，大概像这样：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;podman create --name proxy xxx:latest
podman generate systemd --restart-policy=always -t 1 proxy &amp;gt; ~/.config/systemd/proxy.service
systemctl --uesr daemon-reload
systemctl --user enable proxy.service&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就这样，一切都很美好。&lt;/p&gt;&lt;h3 id=&quot;地下室光头你害人不浅&quot;&gt;地下室光头你害人不浅&lt;/h3&gt;&lt;p&gt;但美好总不能长久，因为那段时间以撒的结合推出了联机更新，了解里面联机用的是 P2P 模式所以就动了用 Zerotier 组 VPN 来方便联机的念头，联机效果很不错但发现一个严重问题就是 Zerotier 需要 Root 权限……&lt;/p&gt;&lt;p&gt;虽然求快直接使用 pacman 安装的方式，但这总会消失（&lt;code&gt;/usr/bin&lt;/code&gt; 目录难逃更新毒手），所以一边玩着以撒一边寻找方案，最后在互联网搜索到一篇文章 &lt;a href=&quot;https://wimpysworld.com/posts/install-zerotier-on-steamdeck/&quot;&gt;Installing ZeroTier on Steam Deck&lt;/a&gt; 里面提到了 &lt;a href=&quot;https://github.com/ValShaped/rwfus&quot;&gt;rwfus&lt;/a&gt; 项目。里面有一些脚本可以保持一些应用逃出更新策略，但这个项目基本就是很多 bash 黑魔法同时项目主页提到了不能执行 &lt;code&gt;sudo pcaman -Syu&lt;/code&gt; 否则系统绝对会出问题，在 issues 里也看到了相应的案例，所以对直接用这个项目还是有点发怵。&lt;/p&gt;&lt;p&gt;但这些项目也同时推荐的 nix 这个选择，也看到了一些消息高版本 SteamOS 放行了 /nix 目录方便用 nix 安装，所以……&lt;/p&gt;&lt;div&gt;&lt;blockquote style=&quot;background: #FCF8FF; border-radius: 8px; border: 1px solid #C9C4DA; margin: 0; max-width: 540px; min-width: 270px; overflow: hidden; padding: 0;&quot; data-embed-url=&quot;https://foxsay.southfox.me/@SouthFox/113311627550276261/embed/embed&quot; class=&quot;mastodon-embed&quot;&gt; &lt;a target=&quot;_blank&quot; style=&quot;align-items: center; color: #1C1A25; display: flex; flex-direction: column; font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Oxygen, Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', Roboto, sans-serif; font-size: 14px; justify-content: center; letter-spacing: 0.25px; line-height: 20px; padding: 24px; text-decoration: none;&quot; href=&quot;https://foxsay.southfox.me/@SouthFox/113311627550276261/embed&quot;&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg:svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;32&quot; viewBox=&quot;0 0 79 75&quot; height=&quot;32&quot;&gt;&lt;path fill=&quot;currentColor&quot; d=&quot;M63 45.3v-20c0-4.1-1-7.3-3.2-9.7-2.1-2.4-5-3.7-8.5-3.7-4.1 0-7.2 1.6-9.3 4.7l-2 3.3-2-3.3c-2-3.1-5.1-4.7-9.2-4.7-3.5 0-6.4 1.3-8.6 3.7-2.1 2.4-3.1 5.6-3.1 9.7v20h8V25.9c0-4.1 1.7-6.2 5.2-6.2 3.8 0 5.8 2.5 5.8 7.4V37.7H44V27.1c0-4.9 1.9-7.4 5.8-7.4 3.5 0 5.2 2.1 5.2 6.2V45.3h8ZM74.7 16.6c.6 6 .1 15.7.1 17.3 0 .5-.1 4.8-.1 5.3-.7 11.5-8 16-15.6 17.5-.1 0-.2 0-.3 0-4.9 1-10 1.2-14.9 1.4-1.2 0-2.4 0-3.6 0-4.8 0-9.7-.6-14.4-1.7-.1 0-.1 0-.1 0s-.1 0-.1 0 0 .1 0 .1 0 0 0 0c.1 1.6.4 3.1 1 4.5.6 1.7 2.9 5.7 11.4 5.7 5 0 9.9-.6 14.8-1.7 0 0 0 0 0 0 .1 0 .1 0 .1 0 0 .1 0 .1 0 .1.1 0 .1 0 .1.1v5.6s0 .1-.1.1c0 0 0 0 0 .1-1.6 1.1-3.7 1.7-5.6 2.3-.8.3-1.6.5-2.4.7-7.5 1.7-15.4 1.3-22.7-1.2-6.8-2.4-13.8-8.2-15.5-15.2-.9-3.8-1.6-7.6-1.9-11.5-.6-5.8-.6-11.7-.8-17.5C3.9 24.5 4 20 4.9 16 6.7 7.9 14.1 2.2 22.3 1c1.4-.2 4.1-1 16.5-1h.1C51.4 0 56.7.8 58.1 1c8.4 1.2 15.5 7.5 16.6 15.6Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;div style=&quot;color: #787588; margin-top: 16px;&quot;&gt;Post by SouthFox&lt;/div&gt; &lt;div style=&quot;font-weight: 500;&quot;&gt;View on Mastodon&lt;/div&gt; &lt;/a&gt; &lt;/blockquote&gt;&lt;script data-allowed-prefixes=&quot;https://foxsay.southfox.me/&quot; async=&quot;true&quot; src=&quot;https://foxsay.southfox.me/embed.js&quot;&gt;&lt;/script&gt;&lt;/div&gt;&lt;h3 id=&quot;Nix，你是？不能忘记的人……&quot;&gt;Nix ，你是？不能忘记的人……&lt;/h3&gt;&lt;p&gt;所以最后就是鼓捣上了 Nix ，对 Nix 的印象还是来源查 Guix 资料顺带了解的，那时因为要用到 Guix 里的一些软件装上了 Guix 但只是浅尝辄止只当作简单包管理器来用。只晓得跟 Arch 一样教徒众多然后用一种「奇奇怪怪」语法写配置文件。&lt;/p&gt;&lt;p&gt;在安装 Nix 时就遇到了很多问题，不停通过官方脚本直接安装不停调参数安装最后发现直接用相应项目 &lt;a href=&quot;https://github.com/DeterminateSystems/nix-installer&quot;&gt;DeterminateSystems | nix-installer&lt;/a&gt; 来是最合适 Steam Deck，同时很多问题都是网络问题，在前面弄个代理就少了很多问题。&lt;/p&gt;&lt;p&gt;之后用 Nix home manager 加上当祈求者「求」着用 Nix 的好友帮忙下攒起了一份配置，但是 Nix home manager 只是针对用户级的配置，对于要用到 Root 权限的程序还是很困难，不过在 &lt;a href=&quot;https://github.com/numtide/system-manager&quot;&gt;system manager&lt;/a&gt; 这个项目的帮助下生成一些 service 文件到 &lt;code&gt;/etc/systemd/system&lt;/code&gt; 目录并调用 &lt;code&gt;/nix/store&lt;/code&gt; 下可执行文件的方式迂回实现了想要的功能。&lt;a href=&quot;https://git.southfox.me/southfox/.deck&quot;&gt;配置仓库地址&lt;/a&gt;&lt;/p&gt;&lt;p&gt;就这么用了几个月虽然甜蜜但还是有点摩擦：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;nix 对于[纯洁」的坚持像是到了洁癖的地步，因为换成了使用配置文件 cli 系的程序，不想用 sops 程序将加密后的配置放在仓库里。 nix 的配置是从 git 的 worktree 检出来的，没有 staged 的文件在后续是不能读到的。最后一种曲折的方式实现：在开始通过有值的配置文件替换准备好文件的模板，插值进去准备好后再 switch flake ，最后 git restore 恢复配置模板文件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;system manager 的逻辑是在生成 &lt;code&gt;/etc/.system-manager-static&lt;/code&gt; 文件夹然后再链接到 &lt;code&gt;/etc/systemd/system&lt;/code&gt; 等目录，而从两三个月前 &lt;code&gt;/etc/.system-manager-static&lt;/code&gt; 好像也被升级策略制裁了导致撑不过系统升级，最近这些个月我还要在系统升级后进入桌面环境调用终端在 system manager 手动部署一次，感觉还是用着 nix 跟没用一样。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;Guix，这会是最终的道路吗？&quot;&gt;Guix ，这会是最终的道路吗？&lt;/h3&gt;&lt;p&gt;在折腾 Nix 的同时 Guix 也没有放下，在慢慢用 Guix home 攒配置还有开发一些功能后，好感度慢慢加到终于触发了剧情，在这几天终于决定踢在 Steam Deck 踢掉 Nix 换成 Guix 。因为 Nix 设计上并不是一个完备的语言，连 system manager 这种扩展功能还要使用 Rust 来写，还有 Nix 对于纯洁的坚持对我也太难容忍了。&lt;/p&gt;&lt;p&gt;所以在参考了一篇讲述如何安装 Nix 的博文 &lt;a href=&quot;https://determinate.systems/posts/nix-on-the-steam-deck&quot;&gt;Nix on the Steam Deck&lt;/a&gt; 照虎画猫的形式弄了下，遵循相同的逻辑在 /home 目录建立目录存放文件然后在 guix-daemon 通过依赖关系 mount 到真实目录，脚本大致这样：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir /home/gnu/store -p
mkdir /home/var-guix

cat &amp;gt; /etc/systemd/system/guix-directory.service &amp;lt;&amp;lt;EOF
[Unit]
Description=Create a `/gnu` directory to be used for bind mounting
PropagatesStopTo=guix-daemon.service
PropagatesStopTo=gnu-store.mount
PropagatesStopTo=var-guix.mount
DefaultDependencies=no

[Service]
Type=oneshot
ExecStart=steamos-readonly disable
ExecStart=mkdir -vp /gnu
ExecStart=chmod -v 0755 /gnu
ExecStart=chown -v root /gnu
ExecStart=chgrp -v root /gnu
ExecStart=mkdir -vp /var/guix
ExecStart=chmod -v 0755 /var/guix
ExecStart=chown -v root /var/guix
ExecStart=chgrp -v root /var/guix
ExecStart=steamos-readonly enable
RemainAfterExit=true
EOF

cat &amp;gt; /etc/systemd/system/gnu.mount &amp;lt;&amp;lt;EOF
[Unit]
Description=Mount `/home/gnu` on `/gnu`
PropagatesStopTo=guix-daemon.service
PropagatesStopTo=guix-directory.service
After=guix-directory.service
Requires=guix-directory.service
ConditionPathIsDirectory=/gnu
DefaultDependencies=no
RequiredBy=guix-daemon.service

[Mount]
What=/home/gnu
Where=/gnu
Type=none
DirectoryMode=0755
Options=bind
EOF

cat &amp;gt; /etc/systemd/system/var-guix.mount &amp;lt;&amp;lt;EOF
[Unit]
Description=Mount `/home/var-guix` on `/var/guix`
PropagatesStopTo=guix-daemon.service
PropagatesStopTo=guix-directory.service
After=guix-directory.service
Requires=guix-directory.service
ConditionPathIsDirectory=/var/guix
DefaultDependencies=no
RequiredBy=guix-daemon.service

[Mount]
What=/home/var-guix
Where=/var/guix
Type=none
DirectoryMode=0755
Options=bind
EOF

cat &amp;gt; /etc/systemd/system/ensure-guix-symlinked.service &amp;lt;&amp;lt;EOF
[Unit]
Description=Ensure Guix related units which are symlinked resolve
After=gnu-store.mount
After=var-guix.mount
Requires=guix-directory.service
Requires=gnu-store.mount
Requires=var-guix.mount
DefaultDependencies=no

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/bin/systemctl daemon-reload

[Install]
WantedBy=sysinit.target
EOF

systemctl daemon-reload
systemctl enable --now ensure-guix-symlinked.service.service

wget 'https://git.savannah.gnu.org/gitweb/?p=guix.git;a=blob_plain;f=etc/guix-install.sh;hb=HEAD' -O guix-install.sh
# guix 安装时会在 /usr/local/bin/guix 创建 guix 软链接，虽然系统更新后
# /usr/local 下的目录会被重置掉，但现在暂时 disable readonly 来「欺骗」安装脚本
steamos-readonly disable
# 使用 GUIX_ALLOW_OVERWRITE 环境变量来强制向已存在的 /gnu 目录安装
GUIX_ALLOW_OVERWRITE=t bash guix-install.sh
steamos-readonly enable&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安期间因为不明原因导致安装脚本报错，这个时候重新安装得先 &lt;code&gt;systemctl stop gnu-store.mount&lt;/code&gt; 关掉 &lt;code&gt;/gnu/store&lt;/code&gt; 的只读挂载然后重新试一次。装完成后可以通过 &lt;code&gt;ls /gnu/store | wc -l&lt;/code&gt; 和 &lt;code&gt;ls /home/gnu/store | wc -l&lt;/code&gt; 对比两边的数据是同步且挂载是有效的。安装后最好通过 reboot 命令手动重启而不要通过 Steam Deck 的更新重启，因为通过 Steam Deck 的更新重启后我发现之前的对 &lt;code&gt;/etc/systemd/system&lt;/code&gt; 的修改全都消失了（这就是为什么会有上面这个脚本），看起来 Steam Deck 的更新流程有点奇怪的魔法，之后通过再试一次然后通过 reboot 的方式才看到修改的内容留着。&lt;/p&gt;&lt;p&gt;最后的问题就是在 &lt;code&gt;/usr/local/bin&lt;/code&gt; 路径会被清掉所以之后要用到 guix 程序时替换成绝对路径 &lt;code&gt;/var/guix/profiles/per-user/root/current-guix/bin/guix&lt;/code&gt; 或使用别名，另外在执行 &lt;code&gt;guix pull&lt;/code&gt; 完成后还发现了 &lt;code&gt;/var/guix/profiles/per-user/root/current-guix&lt;/code&gt; 并没有指向最新 profile 的问题（问题，问题还是问题！），出现这种情况得自己手动改动下。&lt;/p&gt;&lt;h3 id=&quot;最终话！（希望如此）&quot;&gt;最终话！（希望如此）&lt;/h3&gt;&lt;p&gt;在安装完 guix 后在通过 scheme 和一些 gexp 「术法」就能生成一个…… systemd service 文件（没办法， systemd 的淫威实在太大了）来调用 &lt;code&gt;/gnu/store&lt;/code&gt; 下的二进制文件就能做到跨更新保持一下自定义配置了，不过还是感叹 Steam Deck 以一种诡异的方式推了我一把来去学习相应知识，同时在半年前对「在 Steam Deck 使用 Guix 作为包管理器」搜遍互联网毫无头绪到现在暴力硬怼实现也是感概自己的进步。&lt;/p&gt;&lt;p&gt;在可劲折腾的最后却发现自己没什么动力打开游戏了，估计是这几天一直在玩「折腾 Steam Deck 配置」这么款游戏有点过载了吧。;-)&lt;/p&gt;</content></entry><entry><title>Emacs lisp 原本</title><id>https://blog.southfox.me/2025/04/emacs-lisp-elements/.html</id><author><name>Protesilaos Stavrou, SouthFox</name><email>master@southfox.me</email></author><updated>2025-04-15T23:55:00Z</updated><link href="https://blog.southfox.me/2025/04/emacs-lisp-elements/.html" rel="alternate" /><content type="html">&lt;blockquote&gt;&lt;p&gt;这篇文章是一篇翻译！&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这本书，由 Protesilaos Stavrou（也称 &amp;quot;Prot&amp;quot; ）撰写，提供了 Emacs Lisp 编程语言的概览。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;官方网站: &lt;a href=&quot;https://protesilaos.com/emacs/emacs-lisp-elements&quot;&gt;https://protesilaos.com/emacs/emacs-lisp-elements&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Git 仓库: &lt;a href=&quot;https://github.com/protesilaos/emacs-lisp-elements&quot;&gt;https://github.com/protesilaos/emacs-lisp-elements&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;h2 id=&quot;开始学习EmacsLisp&quot;&gt;开始学习 Emacs Lisp&lt;/h2&gt;&lt;p&gt;本书旨在为你提供 Emacs Lisp（也称 Elisp）的宏观认知。Elisp 是你用来扩展 Emacs 的编程语言。Emacs 是一个可编程的文本编辑器：它解释 Emacs Lisp 代码并做出反应。你确实可以使用 Emacs 而无需编写任何一行代码：它已经有非常多的功能了。不过你也可以通过随时运行一些 Elisp 代码来编程它，使其完全按照你想要的方式运行，这些代码可以是你自己编写的，也可以是从其他人那里获得的，例如以软件包的形式。&lt;/p&gt;&lt;p&gt;用编程定制自己的文本编辑器有用又有趣。比如，你可以将你一系列重复操作组合成一个命令，然后将该命令分配给一个按键绑定：按下该键——嘭！——即可一并执行所有中间步骤。这让你更有效率并将编辑器变成一个舒适的工作环境。&lt;/p&gt;&lt;p&gt;编写代码有趣之处在于你如何编写代码。你不用承担任何责任，不用！你为了编程而编程。这是一种开拓视野的娱乐活动。此外你还可以培养 Elisp 技能，如果你将来选择修改 Emacs 的某些行为，这些技能可能会有所帮助。&lt;/p&gt;&lt;p&gt;折腾 Emacs 是体验的一部分。它教会如何对你的编辑器工作方式直抒己见。关键要足够掌握 Elisp，这样你就能在玩乐上避免花费过多时间，或者因为一些琐事导致无法正常工作感到丧气。我本人是一个爱好钻研之人，没有计算机科学或相关背景：我通过折腾编辑器、反复试验的方式来学习 Emacs Lisp。我表面上的目标是改进我某些一遍又一遍重复的小操作：我寻求效率，却发现了一些更深刻的东西。学习扩展我的编辑器是一种充实的体验，也让我变得更有效率。我对 Emacs 按照我想要的方式运行感到满意。&lt;/p&gt;&lt;p&gt;本书中的每一章通常都简短扼要。有些对初学者更友好，而有些则更深入探讨了高级主题。章节之间有链接，就像参考手册该做一样。你可以通过来回跳转的方式寻找你需要的内容。&lt;/p&gt;&lt;p&gt;你在这里看到的文章是散文和代码的结合。后者可能是实际 Elisp 代码或是描绘基本范式的伪代码。我鼓励你在 Emacs 里或在 Emacs 随时可用的情况下阅读本书。这样，你可以摆弄我给你的函数，以进一步领会它们间的细微差别。&lt;/p&gt;&lt;p&gt;我使用的“宏观认知”途径包含了我在使用 Emacs Lisp 时经常遇到的概念。本书不能替代 Emacs Lisp 参考手册，也不应当将任何我关于 Elisp 的诠释作为权威。&lt;/p&gt;&lt;p&gt;祝你好运并玩得开心！&lt;/p&gt;&lt;h2 id=&quot;EmacsLisp求值&quot;&gt;Emacs Lisp 求值&lt;/h2&gt;&lt;p&gt;你在 Emacs 中做的每一件事都会调用某个函数，然后对 Emacs Lisp 代码进行求值，读取返回值并产生副作用 (&lt;a href=&quot;#副作用和返回值&quot;&gt;副作用和返回值&lt;/a&gt;)。&lt;/p&gt;&lt;p&gt;你在键盘上按下一个键一个字符就被写入当前缓冲区（buffer）。这是一个绑定到一个键上的函数，它实际上是一个 &lt;em&gt;交互式&lt;/em&gt; 函数，因为你是通过按键绑定而不是通过某个程序来调用它。交互式函数被称为“命令”（commands）。不过不要让交互式这个实现细节干扰你的注意力，要知道你在 Emacs 中每一个操作都涉及 Emacs Lisp 的求值。&lt;/p&gt;&lt;p&gt;另一种常见的交互形式是使用 M-x (&lt;code&gt;execute-extended-command&lt;/code&gt;) 键，默认运行命令 &lt;code&gt;execute-extended-command&lt;/code&gt; ：它会产生一个 minibuffer 输入栏，要求你按名称选择一个命令接收后并执行。&lt;/p&gt;&lt;p&gt;Emacs 可以在任何地方求值 Elisp 代码。如果你的缓冲区中有一些 Elisp 代码，你可以将光标（cursor）放在末尾的右括号，然后输入 C-x C-e (&lt;code&gt;eval-last-sexp&lt;/code&gt;)。同样你可以使用命令 &lt;code&gt;eval-buffer&lt;/code&gt; 和 &lt;code&gt;eval-region&lt;/code&gt; 分别对当前缓冲区或选中区域进行操作。&lt;/p&gt;&lt;p&gt;&lt;code&gt;eval-last-sexp&lt;/code&gt; 也适用于符号求值 (&lt;a href=&quot;#符号，匹配括号表达式和引用&quot;&gt;符号，匹配括号表达式和引用&lt;/a&gt;)。例如，如果你将光标放在变量 &lt;code&gt;buffer-file-name&lt;/code&gt; 的末尾并使用 C-x C-e (&lt;code&gt;eval-last-sexp&lt;/code&gt;)，你会获得该变量的值，这个值要么是 &lt;code&gt;nil&lt;/code&gt; 要么是你文件系统中正在编辑文件的路径。&lt;/p&gt;&lt;p&gt;有时上述方法不适用于你想做的事。假设你打算编写一个复制当前缓冲区文件路径的命令，那么你的代码需要检测变量 &lt;code&gt;buffer-file-name&lt;/code&gt; 的值 (&lt;a href=&quot;#作为数据结构的缓冲区&quot;&gt;作为数据结构的缓冲区&lt;/a&gt;)。但你肯定不想在文件中输入 &lt;code&gt;buffer-file-name&lt;/code&gt; ，然后使用前面提到的某个 Elisp 求值命令，最后再撤销你的编辑。这既笨拙又容易出错！在当前缓冲区中运行 Elisp 代码的最佳方式是键入 M-: (&lt;code&gt;eval-expression&lt;/code&gt;): 它会打开 minibuffer 并接收你写入的想要求值的代码。然后键入 RET 来开始求值。求值是在把最后的缓冲区当成当前缓冲区下运行的（即调用 &lt;code&gt;eval-expression&lt;/code&gt; 之前的缓冲区）。&lt;/p&gt;&lt;p&gt;这里有一些 Emacs Lisp 代码，你可以在 (i) 对应于文件的缓冲区 与 (ii) 与硬盘上任何文件都无关的缓冲区中尝试运行。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;;; 在打开了文件的缓冲区和没有打开文件的缓冲区
;; 求值`eval-expression' 。
(if buffer-file-name
    (message &amp;quot;此文件的路径是 `%s'&amp;quot; buffer-file-name)
  (message &amp;quot;抱歉伙计，这个缓冲区没有打开任何文件&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当你试验代码时，你可能也想测试它的行为表现。使用 &lt;code&gt;ielm&lt;/code&gt; 命令打开一个交互式 shell 。它让你进入一个提示符，你可以在其中键入任何 Elisp 代码并键入 RET 来求值它。返回值会输出到正下方。或者切换到 &lt;code&gt;*scratch*&lt;/code&gt; 缓冲区。如果它使用主模式 &lt;code&gt;lisp-interaction-mode&lt;/code&gt; （这是 &lt;code&gt;initial-major-mode&lt;/code&gt;  变量的默认值）那么你可以在该缓冲区中自由移动并在一些代码的末尾键入 C-j (&lt;code&gt;eval-print-last-sexp&lt;/code&gt;) 来求值它。这与 &lt;code&gt;eval-last-sexp&lt;/code&gt; 的工作方式几乎相同，但有了将返回值放在你刚刚求值表达式下方的效果。&lt;/p&gt;&lt;p&gt;除此之外，你还可以依靠 Emacs 的自文档特性来知晓当前状态。例如要了解变量 &lt;code&gt;major-mode&lt;/code&gt; 的缓冲区局部值（buffer-local value），你可以执行 C-h v (&lt;code&gt;describe-variable&lt;/code&gt;)，然后搜索该变量。帮助缓冲区将告诉你 &lt;code&gt;major-mode&lt;/code&gt; 的当前值。此帮助命令和许多其他命令，如 &lt;code&gt;describe-function&lt;/code&gt;, &lt;code&gt;describe-keymap&lt;/code&gt;, &lt;code&gt;describe-key&lt;/code&gt; 和 &lt;code&gt;describe-symbol&lt;/code&gt; 提供了 Emacs 对给定对象的洞察力。帮助缓冲区还会显示相关信息，例如给定函数的文件路径或变量是否为缓冲区的局部变量。&lt;/p&gt;&lt;p&gt;Emacs 是“自文档”的，因为它会报告身状态。你不需要显式更新帮助缓冲区。这在求值相关代码自动执行： Emacs 会向你展示你任何你在处理东西的最新值。&lt;/p&gt;&lt;h2 id=&quot;副作用和返回值&quot;&gt;副作用和返回值&lt;/h2&gt;&lt;p&gt;Emacs Lisp 有函数。它们接受输入并产生输出。在最纯粹形式中，函数是一个只有返回值的计算过程，它不会改变所处环境中的任何东西。一个函数的返回值可以用作另一个函数的输入，这实际上构成了一个计算链。因此你可以依赖一个函数的返回值来表达类似“如果这个成功，那么做另一件事，否则做其它的事甚至什么都不做”。&lt;/p&gt;&lt;p&gt;Elisp 是扩展和控制 Emacs 的语言。这意味着它会影响编辑器的状态。当你运行一个函数时，它可以产生永久性影响，例如在光标（cursor）处插入一些文本、删除一个缓冲区、创建一个新窗口等等等等。这些更改会影响到未来的函数调用。例如前一个函数删除了某个缓冲区，那么写入该缓冲区的下一个函数就无法工作了：缓冲区已经不见了！&lt;/p&gt;&lt;p&gt;当你编写 Elisp 时，你必须同时考虑返回值和副作用。如果你大意了，你会因为那些没有深思熟虑的环境变化得到意想不到的结果。但如果你仔细使用副作用，你就能够完全挖掘 Elisp 的潜力。例如想象你定义了一个函数，它有这样的逻辑：“创建一个缓冲区，转到那里，写入一些文本，将缓冲区保存到我偏好位置的文件中，最后回到我调用此函数之前的位置，同时让创建的缓冲区处于打开中。”所有的这一切都是有用的副作用。你的函数可能有一些有意义的返回值，你可以将其用作另一个函数的输入。例如你的函数可能会返回它生成的缓冲区对象让下一个函数可以在那里做些事情，比如在一个单独的窗框（frame)中显示该缓冲区然后调大文本。&lt;/p&gt;&lt;p&gt;这里的思想是操纵编辑器的状态让 Emacs 做你想作的事。有时这意味着你的代码有副作用，但有时副作用是没用的甚至不符合你的预期结果。随着你收获更多经验并扩充技能，你会不断精炼需要做什么的直觉 (&lt;a href=&quot;#符号，匹配括号表达式和引用&quot;&gt;符号，匹配括号表达式和引用&lt;/a&gt;)。不用担心，放松就好！&lt;/p&gt;&lt;h2 id=&quot;作为数据结构的缓冲区&quot;&gt;作为数据结构的缓冲区&lt;/h2&gt;&lt;p&gt;缓冲区以字符序列的形式把持数据。例如这里的数据就是你打开文件时看到的文本。每个字符都有一个数字用于表示位置。函数 &lt;code&gt;point&lt;/code&gt; 给出你所在游标（point）的位置，这通常对应于光标所在的位置 (&lt;a href=&quot;#EmacsLisp求值&quot;&gt;Emacs Lisp 求值&lt;/a&gt;)。在缓冲区的开头， &lt;code&gt;point&lt;/code&gt; 将返回 &lt;code&gt;1&lt;/code&gt; (&lt;a href=&quot;#副作用和返回值&quot;&gt;副作用与返回值&lt;/a&gt;)。有大量函数返回缓冲区位置，例如 &lt;code&gt;point-min&lt;/code&gt;, &lt;code&gt;point-max&lt;/code&gt;, &lt;code&gt;line-beginning-position&lt;/code&gt; 和 &lt;code&gt;re-search-forward&lt;/code&gt; 。其中一些会有副作用，比如 &lt;code&gt;re-search-forward&lt;/code&gt; 会将光标移动到给定匹配处。&lt;/p&gt;&lt;p&gt;当你在 Emacs Lisp 中编程时，你经常依赖缓冲区来做以下一些事：&lt;/p&gt;&lt;p&gt;将文件内容提取为字符串
: 将缓冲区视为一个大字符串。你可以使用函数 &lt;code&gt;buffer-string&lt;/code&gt; 获取全部内容作为一个可能极其巨大的字符串。你也可以使用 &lt;code&gt;buffer-substring&lt;/code&gt; 函数和对应的 &lt;code&gt;buffer-substring-no-properties&lt;/code&gt; 函数获取两个缓冲区位置之间的子字符串 (&lt;a href=&quot;#文本具有自身属性&quot;&gt;文本具有自身属性&lt;/a&gt;)。想象一下你将其作为更广泛操作的一部分来执行，该操作 (i) 打开文件，(ii) 转到特定位置，(iii) 复制找到的文本，(iv) 切换到另一个缓冲区，然后 (v) 将找到的内容写入这个新缓冲区。&lt;/p&gt;&lt;p&gt;展示某些操作的结果
: 你也许有一个显示即将来临的假期函数。你的代码在后台进行计算，并最终将一些文本写入缓冲区。最终产物被显示出来。这取决于你如何处理它，你可能需要求值函数 &lt;code&gt;get-buffer-create&lt;/code&gt; 或其更精确替代 &lt;code&gt;get-buffer&lt;/code&gt; 。如果你需要清除已存在缓冲区里的内容，你可能会使用 &lt;code&gt;with-current-buffer&lt;/code&gt; 宏临时切换到你指向的缓冲区然后调用函数 &lt;code&gt;erase-buffer&lt;/code&gt; 删除所有内容，要么使用 &lt;code&gt;delete-region&lt;/code&gt; 将删除范围框定在缓冲区两个位置之间。最后，函数 &lt;code&gt;display-buffer&lt;/code&gt; 或 &lt;code&gt;pop-to-buffer&lt;/code&gt; 会将缓冲区显示在 Emacs 窗口（window）中。&lt;/p&gt;&lt;p&gt;将变量与给定缓冲区关联
: 在 Emacs Lisp 中，变量可以采用为缓冲区局部值（buffer-local value），该值与其全局值不同。有些变量被声明为始终是缓冲区局部的，例如 &lt;code&gt;buffer-file-name~、~fill-column&lt;/code&gt; 和 &lt;code&gt;default-directory&lt;/code&gt; 。假设你在做返回指定目录中文件缓冲区列表的事。你会遍历 &lt;code&gt;buffer-list&lt;/code&gt; 函数的返回值，通过检测 &lt;code&gt;buffer-file-name&lt;/code&gt; 的特定值来相应过滤结果 (&lt;a href=&quot;#if,cond等基本控制流&quot;&gt;&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt; 等基本控制流&lt;/a&gt;)，这个特定变量始终可用。不过你可以使用 &lt;code&gt;setq-local&lt;/code&gt; 宏将值赋给当前缓冲区中的变量。&lt;/p&gt;&lt;p&gt;后一点也许是最开放的一点。缓冲区就像一组变量的集合，包括它们的内容、正在运行的主模式（major-mode)以及它们拥有的缓冲区局部值（buffer-local value）。在下面的代码块中，我使用 &lt;code&gt;seq-filter&lt;/code&gt; 函数遍历函数 &lt;code&gt;buffer-list&lt;/code&gt; 的返回值 (&lt;a href=&quot;#符号，匹配括号表达式和引用&quot;&gt;符号，匹配括号表达式和引用&lt;/a&gt;)。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(seq-filter
 (lambda (buffer)
   &amp;quot;返回缓冲区当其为可见的并且其主模式派生自 `text-mode' 。&amp;quot;
   (with-current-buffer buffer
     ;; 对于不打算让用户看到的缓冲区，
     ;; 惯例是它们的名称以一个空格开头
     ;; 我们现在不关心这些缓冲区。
     (and (not (string-prefix-p &amp;quot; &amp;quot; (buffer-name buffer)))
          (derived-mode-p 'text-mode))))
 (buffer-list))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这将返回一个缓冲区对象列表，这些对象通过了以下检测：(i) 对用户“可见” 且 (ii) 它们的主模式是 &lt;code&gt;text-mode&lt;/code&gt; 要么是从中派生的。上述代码也可以这样写 ([何时使用具名函数或 lambda 函数](#何时使用具名函数或 lambda 函数))：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-buffer-visble-and-text-p (buffer)
  &amp;quot;返回缓冲区当其为可见的并且其主模式派生自 `text-mode' 。&amp;quot;
  (with-current-buffer buffer
     ;; 对于不打算让用户看到的缓冲区，
     ;; 惯例为名称以一个空格开头
     ;; 我们现在不关心这些缓冲区。
    (and (not (string-prefix-p &amp;quot; &amp;quot; (buffer-name buffer)))
         (derived-mode-p 'text-mode))))

(seq-filter #'my-buffer-visble-and-text-p (buffer-list))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与缓冲区一样，Emacs 窗口（windows）和窗框（frame) 也有它们自己的参数。我不会讨论这些，因为它们的用途更为专门化，而且概念是相同的。只需知道它们是数据结构，你可以利用它们为你带来优势，例如遍历它们 (&lt;a href=&quot;#对列表中的元素进行映射&quot;&gt;对列表中的元素进行映射&lt;/a&gt;)。&lt;/p&gt;&lt;h2 id=&quot;文本具有自身属性&quot;&gt;文本具有自身属性&lt;/h2&gt;&lt;p&gt;如像数据结构一样工作的缓冲区 (&lt;a href=&quot;#作为数据结构的缓冲区&quot;&gt;作为数据结构的缓冲区&lt;/a&gt;)，任何文本也可能有与其关联的属性。这是你可以使用 Emacs Lisp 检阅的元数据。例如当你在某个编程缓冲区中看到语法高亮时，这就是文本属性的效果。某个函数负责“属性化”（propertise）或“字体化”（fontify）相关文本，并决定将一个称为 &amp;quot;face&amp;quot; 的对象应用于它。Face 是将排版属性和颜色属性捆绑在一起的造物，例如家族和字重、前景和背景的色调。要获取一个光标处（cursor)文本包含属性信息的帮助缓冲区，请键入 M-x (&lt;code&gt;execute-extended-command&lt;/code&gt;) 然后调用命令 &lt;code&gt;describe-char&lt;/code&gt; ，它会告诉你它看到的字符、它用什么字体渲染的、它的代码游标是什么，以及它的文本属性是什么。&lt;/p&gt;&lt;p&gt;假设你正在编写你自己的主模式。在实验的早期阶段，你想手动将文本属性添加到缓冲区中所有出现的短语 &lt;code&gt;I have properties&lt;/code&gt; 上，该缓冲区的主模式是 &lt;code&gt;fundamental-mode&lt;/code&gt; ，所以你可以这样做（&lt;a href=&quot;#上次搜索的匹配数据&quot;&gt;上次搜索的匹配数据&lt;/a&gt;）：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-add-properties ()
  &amp;quot;在当前缓冲区为 \&amp;quot;I have properties\&amp;quot; 文本添加属性。&amp;quot;
  (goto-char (point-min))
  (while (re-search-forward &amp;quot;I have properties&amp;quot; nil t)
    (add-text-properties (match-beginning 0) (match-end 0) '(face error))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实际实验一下这个。使用 C-x b (&lt;code&gt;switch-to-buffer&lt;/code&gt;)，输入一些与现在存在缓冲区不匹配的随机字符，然后按 RET 打开该新缓冲区。它运行 &lt;code&gt;fundamental-mode&lt;/code&gt; ，意味着没有“字体化”（propertise）发生，因此 &lt;code&gt;my-add-properties&lt;/code&gt; 会按预期工作。现在粘贴以下内容：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-fundamental&quot;&gt;This is some sample text. Will the phrase &amp;quot;I have properties&amp;quot; use the `bold' face?

What does it even mean for I have properties to be bold?&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;继续使用 M-: (&lt;code&gt;eval-expression&lt;/code&gt;) 并调用函数 &lt;code&gt;my-add-properties&lt;/code&gt; 。成功了吗？它应用的 face 叫做 &lt;code&gt;error&lt;/code&gt; 。忽略这个词的意思：我选择它是因为它的样式化方式通常有相当强烈和明显（尽管你当前的主题可能会有差异）。&lt;/p&gt;&lt;p&gt;有一些函数可以查找给定缓冲区位置的属性，还有一些函数可以向前和向后搜索给定的属性。具体的细节现在不重要。我只想让你记住，文本不仅仅是其组成的字符。要了解详情，可键入 M-x (&lt;code&gt;execute-extended-command&lt;/code&gt;) 来调用命令 &lt;code&gt;shortdoc&lt;/code&gt; 。它会要你选择一个文档组。选择 &lt;code&gt;text-properties&lt;/code&gt; 以了解更多信息。当然，对那里列出的所有内容都使用 &lt;code&gt;shortdoc&lt;/code&gt;  ，我一直都是这样做的。&lt;/p&gt;&lt;h2 id=&quot;符号，匹配括号表达式和引用&quot;&gt;符号，匹配括号表达式和引用&lt;/h2&gt;&lt;p&gt;对于不熟悉 Emacs Lisp 的人来说，这是一种括号非常多的语言！这是一个简单的函数定义：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-greet-person (name)
  &amp;quot;对给定的 name 说 hello&amp;quot;
  (message &amp;quot;Hello %s&amp;quot; name))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我刚刚定义了一个名为 &lt;code&gt;my-greet-person&lt;/code&gt; 的函数。它有一个参数列表，具体来说，是只包含一个参数的列表，参数名为 &lt;code&gt;name&lt;/code&gt; 。然后是可选的文档字符串，供用户理解代码和/或函数的意图。 &lt;code&gt;my-greet-person&lt;/code&gt; 接受 &lt;code&gt;name&lt;/code&gt; 并将其作为参数传递给 &lt;code&gt;message&lt;/code&gt; 函数，最终打印出问候语。 &lt;code&gt;message&lt;/code&gt; 函数将文本记录在 &lt;code&gt;*Messages*&lt;/code&gt; 缓冲区中，你可以使用 C-h e (&lt;code&gt;view-echo-area-messages&lt;/code&gt;) 直接访问该缓冲区。无论如何，下面是一个给定一个预期参数的 &lt;code&gt;my-greet-person&lt;/code&gt; 调用：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(my-greet-person &amp;quot;Protesilaos&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在用多个参数做同样的事情：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-greet-person-from-country (name country)
  &amp;quot;对给定住在 COUNTRY 的 NAME 说 hello&amp;quot;
  (message &amp;quot;Hello %s of %s&amp;quot; name country))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后这样子调用：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(my-greet-person-from-country &amp;quot;Protesilaos&amp;quot; &amp;quot;Cyprus&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即使对于最基本的任务，你也会用到很多括号。但不用害怕！这实际上让结构化理解你的代码变得更简单。如果现在感觉不是这样，那是因为你还不习惯。一旦你习惯了，可就回不去了。&lt;/p&gt;&lt;p&gt;任何 Lisp 方言 (Emacs Lisp 也是其中之一）的基本思想是：你有用来定义列表的括号；列表由元素组成；列表要么被求值产生某些计算结果，要么按原样返回以用于其他求值 (&lt;a href=&quot;#副作用和返回值&quot;&gt;副作用与返回值&lt;/a&gt;)：&lt;/p&gt;&lt;p&gt;列表作为函数调用
: 当求值一个列表时，第一个元素是函数名，其余元素是传递给该函数的参数。你已经在上面看到了这一点，我是如何用 &lt;code&gt;&amp;quot;Protesilaos&amp;quot;&lt;/code&gt; 作为参数调用 &lt;code&gt;my-greet-person&lt;/code&gt; 的。 &lt;code&gt;my-greet-person-from-country&lt;/code&gt; 也是同样的原理，参数是 &lt;code&gt;&amp;quot;Protesilaos&amp;quot;&lt;/code&gt; 和 &lt;code&gt;&amp;quot;Cyprus&amp;quot;&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;列表作为数据
: 当不求值一个列表时，它的所有元素在一开始都没有特殊含义。它们都作为一个列表原样返回，没有进一步的改变。当你不希望你的列表被求值时，你可以在它前面加上一个单引号字符。例如 &lt;code&gt;'(&amp;quot;Protesilaos&amp;quot; &amp;quot;Prot&amp;quot; &amp;quot;Cyprus&amp;quot;)&lt;/code&gt; 是一个包含三个元素的列表并且应该原样返回。&lt;/p&gt;&lt;p&gt;考虑你还没见过的下一种场景。你想从包含元素的列表中获取一些数据。在最基本的层面上，函数 &lt;code&gt;car&lt;/code&gt; 和 &lt;code&gt;cdr&lt;/code&gt; 分别返回第一个元素和包含所有剩余元素的列表：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(car '(&amp;quot;Protesilaos&amp;quot; &amp;quot;Prot&amp;quot; &amp;quot;Cyprus&amp;quot;))
;; =&amp;gt; &amp;quot;Protesilaos&amp;quot;

(cdr '(&amp;quot;Protesilaos&amp;quot; &amp;quot;Prot&amp;quot; &amp;quot;Cyprus&amp;quot;))
;; =&amp;gt; (&amp;quot;Prot&amp;quot; &amp;quot;Cyprus&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的单引号特别重要，因为它指示 Emacs 不要对列表求值。否则对这个列表求值会将第一个元素，即 &lt;code&gt;&amp;quot;Protesilaos&amp;quot;&lt;/code&gt; 视为函数名，并将列表其余部分视为该函数的参数。由于你并没有定义这样的函数，你会得到一个报错。&lt;/p&gt;&lt;p&gt;Emacs Lisp 中的某些数据类型是“自求值”的。这意味着如果你对它们求值，它们的返回值就是你看到的东西。例如，字符串 &lt;code&gt;&amp;quot;Protesilaos&amp;quot;&lt;/code&gt; 的返回值是 &lt;code&gt;&amp;quot;Protesilaos&amp;quot;&lt;/code&gt; 。这对于字符串、数字、关键字、符号以及特殊的 &lt;code&gt;nil&lt;/code&gt; 或 &lt;code&gt;t&lt;/code&gt; 都成立。下面是一个包含这些类型的列表，你可以通过调用函数 &lt;code&gt;list&lt;/code&gt; 来构建它：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(list &amp;quot;Protesilaos&amp;quot; 1 :hello 'my-greet-person-from-country nil t)
;; =&amp;gt; (&amp;quot;Protesilaos&amp;quot; 1 :hello 'my-greet-person-from-country nil t)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;list&lt;/code&gt; 函数对传递给它的参数进行求值，除非它们被引用（quote）。自求值是你得到没有明显变化的返回值的原因。注意 &lt;code&gt;my-greet-person-from-country&lt;/code&gt; 的引用方式与我们引用一个不希望求值的列表的方式相同。如果没有它， &lt;code&gt;my-greet-person-from-country&lt;/code&gt; 将被求值，除非它被定义为一个变量，否则将得到一个报错。&lt;/p&gt;&lt;p&gt;将单引号视为一个明确的指令：“不要对后续求值”。更具体说，它是一个指令，让通常会发生求值的情况下不进行求值 (&lt;a href=&quot;#列表里的部分求值&quot;&gt;列表里的部分求值&lt;/a&gt;)。换言之，你可不想在一个被引用的列表内部引用某些东西，因为那等同于对其引用两次：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;;; 这样做是正确的：
'(1 :hello my-greet-person-from-country)

;; 这样引用 `my-greet-person-from-country' 是错误的因为
;; 整个列表不会被求值，这里的错误在于你引用了已经引用的东西
;; 就像在做：
;; ''my-greet-person-from-country.
'(1 :hello 'my-greet-person-from-country)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在你可能想知道为什么我们引用了 &lt;code&gt;my-greet-person-from-country&lt;/code&gt; 但其他没有引用其他东西？原因是你在那里看到的其他所有东西实际上都是“自引用”的，即自求值的另一面。而 &lt;code&gt;my-greet-person-from-country&lt;/code&gt; 是一个符号。一个“符号”是一个自身之外某物的引用：它要么表示某个计算——一个函数——或为一个变量的值。如果你写一个符号而不引用它，你实际上是在告诉 Emacs “给我这个符号所代表的值”。就 &lt;code&gt;my-greet-person-from-country&lt;/code&gt; 而言，你尝试这样做会得到一个错误，因为这个符号不是一个变量，因此尝试从中获取值是无法生效的。&lt;/p&gt;&lt;p&gt;还请记住，Emacs Lisp 有一个“宏”的概念，它基本上是一个模板系统，用于编写扩展成其他实际代码然后才求值的代码。在一个宏内部，你控制了引用的如何完成，这意味着前面提到的规则可能不适用于宏的调用，即使它们仍然在宏的扩展形式内部使用 (&lt;a href=&quot;#宏或特殊形式里的求值&quot;&gt;宏或特殊形式里的求值&lt;/a&gt;)。&lt;/p&gt;&lt;p&gt;随着你接触更多的 Emacs Lisp 代码，你会遇到前面带有井号的引号，例如 &lt;code&gt;#'some-symbol&lt;/code&gt; 。这个 sharp quote ，正如它被称呼的那样，与常规引号相同，但增加了特指为函数的语义。程序员可以更好地表达给定表达式意图，字节编译器也能在内部执行必要的检查和优化。考虑这点，请阅读关于函数 &lt;code&gt;quote&lt;/code&gt; 和 &lt;code&gt;function&lt;/code&gt; 的内容，它们分别对应于常规引号和 sharp quote 。&lt;/p&gt;&lt;h2 id=&quot;列表里的部分求值&quot;&gt;列表里的部分求值&lt;/h2&gt;&lt;p&gt;你已经对 Emacs Lisp 代码的样子有了一些概念 (&lt;a href=&quot;#符号，匹配括号表达式和引用&quot;&gt;符号，匹配括号表达式和引用&lt;/a&gt;)。你有一个列表：它要么被求值；要么按照原样获取。还有另一种情况，即列表应该被部分求值，或者更具体地说，它应该被当作数据而不是函数调用，同时仍然需要求值某些元素。&lt;/p&gt;&lt;p&gt;在下面的代码块中，我定义了一个名为 &lt;code&gt;my-greeting-in-greek&lt;/code&gt; 的变量，这是一个希腊语中常用的短语，字面意思是“祝你健康”，发音为 &amp;quot;yah sou&amp;quot; 。为什么要用希腊语？好吧，你已经学习了生成 Lisp 这一切的 &lt;code&gt;lambda&lt;/code&gt; ，所以你不妨也了解其余的部分 ([何时使用具名函数或 lambda 函数](#何时使用具名函数或 lambda 函数))！&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defvar my-greeting-in-greek &amp;quot;Γεια σου&amp;quot;
  &amp;quot;希腊语中的祝某人健康。&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在我要用 &lt;code&gt;message&lt;/code&gt; 函数做些实验来更好理解求值是如何工作的。让我从引用列表然后按原样获取它的情况开始：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(message &amp;quot;%S&amp;quot; '(one two my-greeting-in-greek four))
;;=&amp;gt; &amp;quot;(one two my-greeting-in-greek four)&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你会注意到变量 &lt;code&gt;my-greeting-in-greek&lt;/code&gt; 没有被求值。我得到了符号即实际的 &lt;code&gt;my-greeting-in-greek&lt;/code&gt; 而不是它所代表的值。这是预期的结果，因为整个列表都被引用了，因此其中的所有内容都不会被求值。&lt;/p&gt;&lt;p&gt;现在检查下一个代码块，以理解我如何告诉 Emacs 我希望整个列表仍然被引用，但特别地让 &lt;code&gt;my-greeting-in-greek&lt;/code&gt; 被求值来替换它代表的值：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(message &amp;quot;%S&amp;quot; `(one two ,my-greeting-in-greek four))
;; =&amp;gt; &amp;quot;(one two \&amp;quot;Γεια σου\&amp;quot; four)&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请仔细注意这里的语法。我使用的是反引号或称反撇号，而不是单引号，在我们的例子中这也被称为准引号（quasi quote）。它的行为类似于单引号，但除了前面带有逗号的内容。逗号是一个“对后面的东西求值”的指令，并且只在准引号（quasi quote）的列表内部有效。后面跟着的“东西”要么是一个符号，要么是一个列表。列表当然也可以是一个函数调用。这里让我用 &lt;code&gt;concat&lt;/code&gt; 来问候某个人，同时将所有内容作为一个列表返回：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(message &amp;quot;%S&amp;quot; `(one two ,(concat my-greeting-in-greek &amp;quot; &amp;quot; &amp;quot;Πρωτεσίλαε&amp;quot;) four))
;; =&amp;gt; &amp;quot;(one two \&amp;quot;Γεια σου Πρωτεσίλαε\&amp;quot; four)&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;请记住如果你不引用这个列表就会得到一个错误，因为第一个元素 &lt;code&gt;one&lt;/code&gt; 会被视为一个函数的符号，该函数将用所有其他元素作为其参数来调用。很可能在你现在的 Emacs 会话中没有定义 &lt;code&gt;one&lt;/code&gt; 为函数，或者那些参数对它来说没有意义。另外， &lt;code&gt;two&lt;/code&gt; 和 &lt;code&gt;four&lt;/code&gt; 随后会视为变量，因为它们没有被引用，在这种情况下，那些变量也必须被定义，否则会导致更多错误产生。&lt;/p&gt;&lt;p&gt;除了逗号操作符，还有 &lt;code&gt;,@&lt;/code&gt; （这到底怎么发音？可能 &amp;quot;comma at&amp;quot; ？），这表示为 “拼接”（splicing）。这是用来说“返回值是一个列表但希望你移除它最外层的括号”的术语。实际上，原本会返回 &lt;code&gt;'(one two three)&lt;/code&gt; 的代码现在返回 &lt;code&gt;one two three&lt;/code&gt; 。这种差异在单独使用情况下可能没有多大意义，但一旦你将这些元素视为应独立求值的表达式，而不是仅仅作为被引用列表的元素时，它就有意义了。我不会在这里详细阐述一个例子，因为我认为最好在定义宏的背景下进行介绍 (&lt;a href=&quot;#宏或特殊形式里的求值&quot;&gt;宏或特殊形式里的求值&lt;/a&gt;)。&lt;/p&gt;&lt;p&gt;你很可能不需要用到部分求值的知识。它在宏中更常见但在任何地方都可以使用。不管怎样都要认识到它，因为在某些情况下你需要理解你所某些依赖的代码在做些什么。&lt;/p&gt;&lt;p&gt;最后，既然我向你介绍了一些希腊语单词，那我现在就把你当作我的朋友了。这里有一个我小时候的笑话。我试图向我的英语老师解释某个事情。由于我缺乏表达自己的词汇，我开始使用希腊语单词。我的老师有严格只用英语回应的规定，所以她说：&amp;quot;It is all Greek to me.&amp;quot;（对我来说都是希腊语「中文里类似表示为“对我来说都是天书”」）。我不知道她在说一个俗语，意思是“我不明白你在说什么”，我草率回答说:&amp;quot;Yes, Greek madame; me no speak England very best.&amp;quot;（是的，希腊语，夫人;我英语说得不是很好）。其实我当时已经算入门了，但我还是忍不住调侃一下。就像你应该记得享受折腾 Emacs 的时光一样。但好了！回到这本书。&lt;/p&gt;&lt;h2 id=&quot;宏或特殊形式里的求值&quot;&gt;宏或特殊形式里的求值&lt;/h2&gt;&lt;p&gt;在最基础的 Emacs Lisp 代码场景中，你有要么被求值要么不被求值的列表 (&lt;a href=&quot;#符号，匹配括号表达式和引用&quot;&gt;符号，匹配括号表达式和引用&lt;/a&gt;)。如果你玩得更高级一点，你有只被部分求值的列表 (&lt;a href=&quot;#列表里的部分求值&quot;&gt;列表里的部分求值&lt;/a&gt;)。但有时你看着一段代码，却无法理解为什么常规的引用和求值规则不适用。在看到实际例子之前，先检查一个典型的函数调用，它也涉及一个变量的求值：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(concat my-greeting-in-greek &amp;quot; &amp;quot; &amp;quot;Πρωτεσίλαε&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你在部分求值里遇到过这段代码。这里有一个对函数 &lt;code&gt;concat&lt;/code&gt; 的调用后面跟着三个参数。其中一个参数是一个变量即 &lt;code&gt;my-greeting-in-greek&lt;/code&gt; 。当这个列表被求值时 Emacs 实际首先对参数（包括 &lt;code&gt;my-greeting-in-greek&lt;/code&gt; ）进行求值来获取它们各自的值，然后才用这些值调用 &lt;code&gt;concat&lt;/code&gt; 。你可以将整个操作过程想象如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;这里是一个列表。&lt;/li&gt;&lt;li&gt;它没有被引用。&lt;/li&gt;&lt;li&gt;那你应该对它求值。&lt;/li&gt;&lt;li&gt;第一个元素是函数名。&lt;/li&gt;&lt;li&gt;剩余的元素是传递给该函数的参数。&lt;/li&gt;&lt;li&gt;检查参数是什么。&lt;/li&gt;&lt;li&gt;对每个参数求值获取其真实值。&lt;/li&gt;&lt;li&gt;字符串是自求值的，而 &lt;code&gt;my-greeting-in-greek&lt;/code&gt; 是一个变量。&lt;/li&gt;&lt;li&gt;你现在拥有了每个参数的值，包括符号 &lt;code&gt;my-greeting-in-greek&lt;/code&gt; 的值。&lt;/li&gt;&lt;li&gt;用你得到的所有值调用 &lt;code&gt;concat&lt;/code&gt; 。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;换句话说，下面两个产生相同的结果（假设 &lt;code&gt;my-greeting-in-greek&lt;/code&gt; 是常量）：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(concat my-greeting-in-greek &amp;quot; &amp;quot; &amp;quot;Πρωτεσίλαε&amp;quot;)

(concat &amp;quot;Γεια σου&amp;quot; &amp;quot; &amp;quot; &amp;quot;Πρωτεσίλαε&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是可预测的。它遵循单引号的基本逻辑：如果它被引用了，就不对它求值然后原样返回，否则就对它求值并返回值。但是你会发现很多情形下这种预期的模式似乎没有被遵循。考虑这个用 &lt;code&gt;setq&lt;/code&gt; 将符号绑定到给定值的常见场景：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(setq my-test-symbol &amp;quot;Protesilaos of Cyprus&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的表达式看起来像一个函数调用，这意味 (i) 列表没有被引用，(ii) 第一个元素是函数名，以及 (iii) 剩余元素是传递给该函数的参数。在某种程度上这是正确的，不过你可能会期望 &lt;code&gt;my-test-symbol&lt;/code&gt; 当成一个变量，它会被原地求值以返回其结果，而这个结果反过来将是传递给函数的实际参数。然而这并不是 &lt;code&gt;setq&lt;/code&gt; 的工作方式。原因是它是一个特殊情形而里面执行的是这个：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(set 'my-test-symbol &amp;quot;Protesilaos of Cyprus&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这里事情就符合预期。背后没有发生什么魔法。 &lt;code&gt;setq&lt;/code&gt; 是为了让用户不必每次都加上引用号。是的，这使得推论它变得有点困难，但你会习惯它，最终一切都会变得有意义。希望你会习惯这种特殊形式，就像你在 &lt;code&gt;setq&lt;/code&gt; 以及 &lt;code&gt;defun&lt;/code&gt; 等许多其他形式中发现的那样。这有一个你已经见过的函数：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-greet-person-from-country (name country)
  &amp;quot;对给定住在 COUNTRY 的 NAME 说 hello&amp;quot;
  (message &amp;quot;Hello %s of %s&amp;quot; name country))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果应用标准求值规则，那么参数列表应该被视作引用。否则你会觉得 &lt;code&gt;(name country)&lt;/code&gt; 将解释成一个函数调用，其中 &lt;code&gt;name&lt;/code&gt; 是函数符号， &lt;code&gt;country&lt;/code&gt; 是它的参数并且 &lt;code&gt;country&lt;/code&gt; 本身也应该是一个变量。但这并不是实际发生的情况，因为 &lt;code&gt;defun&lt;/code&gt; 会在内部将该参数列表视为已引用。&lt;/p&gt;&lt;p&gt;另一个常见的场景是使用 &lt;code&gt;let&lt;/code&gt; （&lt;a href=&quot;#if-let*控制流及其相关形式&quot;&gt;&lt;code&gt;if-let*&lt;/code&gt; 控制流及其相关形式&lt;/a&gt;） 。它的一般形式如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;;; 这是一段伪代码
(let LIST-OF-LISTS-AS-VARIABLE-BINDINGS
  BODY-OF-THE-FUNCTION)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;LIST-OF-LISTS-AS-VARIABLE-BINDINGS&lt;/code&gt; 是一个列表，其中每个元素都是 &lt;code&gt;(SYMBOL VALUE)&lt;/code&gt; 形式的列表。这里有一些实际代码：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(let ((name &amp;quot;Protesilaos&amp;quot;)
      (country &amp;quot;Cyprus&amp;quot;))
  (message &amp;quot;Hello %s of %s&amp;quot; name country))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;继续关于特殊形式主题，如果 &lt;code&gt;let&lt;/code&gt; 是一个典型函数调用，那么 &lt;code&gt;LIST-OF-LISTS-AS-VARIABLE-BINDINGS&lt;/code&gt; 就必须引用。否则它会被求值，在这种情况下，第一个元素将是函数名。这会返回一个错误，因为函数名将对应于另一个列表即 &lt;code&gt;(name &amp;quot;Protesilaos&amp;quot;)&lt;/code&gt; 而不是一个符号。不过使用 &lt;code&gt;let&lt;/code&gt; 时一切正常，因为它内部对其 &lt;code&gt;LIST-OF-LISTS-AS-VARIABLE-BINDINGS&lt;/code&gt; 进行了引用。&lt;/p&gt;&lt;p&gt;对于许多特殊形式和宏都有类似预期行为，比如流行的 &lt;code&gt;use-package&lt;/code&gt; （可用于在你的 Emacs 初始文件中配置相关包）。这些宏是如何工作取决于它们的设计，我不会在这里深入探讨技术细节，因为我希望这本书能够长期有用，侧重于理念而不是可能随时间变化的实现细节。&lt;/p&gt;&lt;p&gt;要了解给定的宏会实际扩展成什么，请将光标放在末尾的右括号并调用命令 &lt;code&gt;pp-macroexpand-last-sexp&lt;/code&gt; 。它将生成一个新的缓冲区，显示扩展后的 Emacs Lisp 代码。这才是宏实际替换后求值的内容。&lt;/p&gt;&lt;p&gt;理解这些基础后是时候来编写一个宏了。这就像一个模板，使你能够避免重复自己。在语法上宏很可能依赖于准引用（quasi quote） 、逗号操作符以及拼接机制的使用 (&lt;a href=&quot;#列表里的部分求值&quot;&gt;列表里的部分求值&lt;/a&gt;)。这里有一个简单的场景，我们希望在一个临时缓冲区中运行一些代码同时将 &lt;code&gt;default-directory&lt;/code&gt; 设成用户的家目录。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defmacro my-work-in-temp-buffer-from-home (&amp;amp;rest expressions)
  &amp;quot;在临时缓冲区将 `default-directory' 设为用户家目录并求值 EXPRESSIONS 。&amp;quot;
  `(let ((default-directory ,(expand-file-name &amp;quot;~/&amp;quot;)))
     (with-temp-buffer
       (message &amp;quot;Running all expression from the `%s' directory&amp;quot; default-directory)
       ,@expressions)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个定义里 &lt;code&gt;&amp;amp;rest&lt;/code&gt; 会让后面的参数成为一个列表。所以你可以向它传递任意数量的参数，所有参数都将被收集到一个名为 &lt;code&gt;EXPRESSIONS&lt;/code&gt; 的列表中。合理使用的部分求值确保了宏不会立即求值，而只在被调用时才求值。传递给它的参数将替换到你指定的位置。这是一个这个宏的调用：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(progn
  (message &amp;quot;Now we are doing something unrelated to the macro&amp;quot;)
  (my-work-in-temp-buffer-from-home
   (message &amp;quot;We do stuff inside the macro&amp;quot;)
   (+ 1 1)
   (list &amp;quot;Protesilaos&amp;quot; &amp;quot;Cyprus&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你将光标放在 &lt;code&gt;my-work-in-temp-buffer-from-home&lt;/code&gt; 的右括号处，你可以通过键入 M-x (&lt;code&gt;execute-extended-command&lt;/code&gt;) 然后调用命令 &lt;code&gt;pp-macroexpand-last-sexp&lt;/code&gt; 来确认它扩展成什么样子。这是我得到的结果：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(let ((default-directory &amp;quot;/home/prot/&amp;quot;))
  (with-temp-buffer
    (message &amp;quot;Running all expression from the `%s' directory&amp;quot; default-directory)
    (message &amp;quot;We do stuff inside the macro&amp;quot;)
    (+ 1 1)
    (list &amp;quot;Protesilaos&amp;quot; &amp;quot;Cyprus&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将其同上下文中的其余代码拼在一起我得到了这个：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(progn
  (message &amp;quot;Now we are doing something unrelated to the macro&amp;quot;)
  (let ((default-directory &amp;quot;/home/prot/&amp;quot;))
    (with-temp-buffer
      (message &amp;quot;Running all expression from the `%s' directory&amp;quot; default-directory)
      (message &amp;quot;We do stuff inside the macro&amp;quot;)
      (+ 1 1)
      (list &amp;quot;Protesilaos&amp;quot; &amp;quot;Cyprus&amp;quot;))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;记住这个例子，考虑将 Elisp 宏当成：“这个小东西帮助我更简洁表达这个更大的过程而实际运行的代码仍然是后者的代码。”&lt;/p&gt;&lt;p&gt;我上面写的宏其主体以准引用（quasi quote）开始，所以你无法体会到求值里的细微差别。让我向你展示另一种方法，我编写一个宏，让它可以定义几个几乎相同的交互式函数 ([让你的交互式函数也能从 Lisp 调用中运行](#让你的交互式函数从 Lisp 调用中运行))。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defmacro my-define-command (name &amp;amp;rest expressions)
  &amp;quot;定义命令跟对应 NAME 运行指定 EXPRESSIONS.&amp;quot;
  (declare (indent 1))
  (unless (symbolp name)
    (error &amp;quot;I want NAME to be a symbol&amp;quot;))
  (let ((modifined-name (format &amp;quot;modified-version-of-%s&amp;quot; name)))
    `(defun ,(intern modifined-name) ()
       (interactive)
       ,(message &amp;quot;The difference between `%s' and `%s'&amp;quot; modifined-name name)
       ,@expressions)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;my-define-command&lt;/code&gt; 大致可以分为两部分：(i) 立刻求值的部分和 (ii) 展开后进一步求值的部分。后一部分以 quasi quote 开始。当调用宏时这种区别很重要，因为前一部分会立即执行，所以如果我们遇到错误它将永远不会展开并运行 &lt;code&gt;EXPRESSIONS&lt;/code&gt; 。对下面的例子使用 &lt;code&gt;pp-macroexpand-last-sexp&lt;/code&gt; 来看看我的意思。为方便起见我在每种情形下面包含了宏展开结果。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(my-define-command first-demo
  (message &amp;quot;This is what my function does&amp;quot;)
  (+ 1 10)
  (message &amp;quot;And this&amp;quot;))
;; =&amp;gt;
;;
;; (defun modified-version-of-first-demo nil
;;   (interactive)
;;   &amp;quot;The difference between ‘modified-version-of-first-demo’ and ‘first-demo’&amp;quot;
;;   (message &amp;quot;This is what my function does&amp;quot;)
;;   (+ 1 10)
;;   (message &amp;quot;And this&amp;quot;))


(my-define-command second-demo
  (list &amp;quot;Protesilaos&amp;quot; &amp;quot;Cyprus&amp;quot;)
  (+ 1 1)
  (message &amp;quot;Arbitrary expressions here&amp;quot;))
;; =&amp;gt;
;;
;; (defun modified-version-of-second-demo nil
;;   (interactive)
;;   &amp;quot;The difference between ‘modified-version-of-second-demo’ and ‘second-demo’&amp;quot;
;;   (list &amp;quot;Protesilaos&amp;quot; &amp;quot;Cyprus&amp;quot;)
;;   (+ 1 1)
;;   (message &amp;quot;Arbitrary expressions here&amp;quot;))


(my-define-command &amp;quot;error scenario&amp;quot;
  (list &amp;quot;Will&amp;quot; &amp;quot;Not&amp;quot; &amp;quot;Reach&amp;quot; &amp;quot;This&amp;quot;)
  (/ 2 0))
;; =&amp;gt; ERROR...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你需要宏吗？并不总是需要，但有些情况下一个定义良好的宏会使你的代码更优雅。重要的是你对求值如何运作有一个概念，这样你就不会被所有那些括号搞晕。否则你可能会发生实际得到的结果与期望不符的事。&lt;/p&gt;&lt;h2 id=&quot;对列表中的元素进行映射&quot;&gt;对列表中的元素进行映射&lt;/h2&gt;&lt;p&gt;编程中一个常见状况是遍历一个列表里的元素并对每个元素执行一些计算。Emacs Lisp 有通用的 &lt;code&gt;while&lt;/code&gt; 循环，以及一系列专门用于遍历列表元素的函数，例如 &lt;code&gt;mapcar&lt;/code&gt;, &lt;code&gt;mapc&lt;/code&gt;, &lt;code&gt;dolist&lt;/code&gt;, &lt;code&gt;seq-filter&lt;/code&gt;, &lt;code&gt;seq-remove&lt;/code&gt; 等等等等。根据你在做的事情：遍历元素的目的是产生一些副作用和/或检测返回值 (&lt;a href=&quot;#副作用和返回值&quot;&gt;副作用与返回值&lt;/a&gt;)。我将向你展示一些例子，让你决定哪种工具最适合手头的任务。&lt;/p&gt;&lt;p&gt;从 &lt;code&gt;mapcar&lt;/code&gt; 开始，它将一个函数应用到列表中的每个元素。然后它获取每次迭代的返回值并将它们收集到一个新列表中然后作为 &lt;code&gt;mapcar&lt;/code&gt; 整体的返回值。在下面的代码块中我使用 &lt;code&gt;mapcar&lt;/code&gt; 遍历一个数字列表，将它们增加 &lt;code&gt;10&lt;/code&gt; 并返回一个包含增加后数字的新列表。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(mapcar
 (lambda (number)
   (+ 10 number))
 '(1 2 3 4 5))
;; =&amp;gt; (11 12 13 14 15)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上面的代码块中，我使用了一个 &lt;code&gt;lambda&lt;/code&gt; ，即匿名函数 ([何时使用具名函数或 lambda 函数](#何时使用具名函数或 lambda 函数))。下面是相同的代码不过使用具名函数：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-increment-by-ten (number)
  &amp;quot;Add 10 to NUMBER.&amp;quot;
  (+ 10 number))

(mapcar #'my-increment-by-ten '(1 2 3 4 5))
;; =&amp;gt; (11 12 13 14 15)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意这里我们引用了具名函数 (&lt;a href=&quot;#符号，匹配括号表达式和引用&quot;&gt;符号，匹配括号表达式和引用&lt;/a&gt;)。&lt;/p&gt;&lt;p&gt;&lt;code&gt;mapcar&lt;/code&gt; 将返回值收集到一个新列表中有时可能没什么用。假设你想对求值某个函数做到保存所有打开文件中未保存的缓冲区。在这种情况下你不在乎累积结果：你只想直接获得保存缓冲区的副作用。为此你可以使用 &lt;code&gt;mapc&lt;/code&gt; ，它总是返回它操作的列表：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(mapc
 (lambda (buffer)
   (when (and (buffer-file-name buffer)
              (buffer-modified-p buffer))
     (save-buffer)))
 (buffer-list))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;替代上述方法的是 &lt;code&gt;dolist&lt;/code&gt; ，它用于产生副作用但总返回 &lt;code&gt;nil&lt;/code&gt; ：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(dolist (buffer (buffer-list))
  (when (and (buffer-file-name buffer)
             (buffer-modified-p buffer))
    (save-buffer)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你会注意到 &lt;code&gt;dolist&lt;/code&gt; 是一个宏，所以它的某些部分与基本列表及求值规则表现不同 (&lt;a href=&quot;#宏或特殊形式里的求值&quot;&gt;宏或特殊形式里的求值&lt;/a&gt;)。这需要适应代码的编写方式。&lt;/p&gt;&lt;p&gt;什么时候使用 &lt;code&gt;dolist&lt;/code&gt; 而不是 &lt;code&gt;mapc&lt;/code&gt; 是风格问题。如果你使用具名函数在我看来 &lt;code&gt;mapc&lt;/code&gt; 更简洁。否则 &lt;code&gt;dolist&lt;/code&gt; 更容易阅读。这是我使用方式的一些伪代码：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;;; 我喜欢这个：
(mapc #'NAMED-FUNCTION LIST)

;; 我也喜欢用 `dolist' 替换 `mapc' 和里面的 `lambda' ：
(dolist (element LIST)
  (OPERATE-ON element))

;; 我不喜欢这个：
(mapc
 (lambda (element)
   (OPERATE-ON element))
 LIST)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然 &lt;code&gt;dolist&lt;/code&gt; 和 &lt;code&gt;mapc&lt;/code&gt; 是为了副作用，但你仍然可以在 &lt;code&gt;let&lt;/code&gt; 和相关形式帮助下来累积结果 (&lt;a href=&quot;#if-let*控制流及其相关形式&quot;&gt;&lt;code&gt;if-let*&lt;/code&gt; 控制流及其相关形式&lt;/a&gt;)。根据具体情况这种方法可能比依赖 &lt;code&gt;mapcar&lt;/code&gt; 更有意义。这是一个带注释的草稿：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;;; 以空列表 `found-strings' 开始。
(let ((found-strings nil))
  ;; 使用 `dolist' 检测列表里的每个元素 '(&amp;quot;Protesilaos&amp;quot; 1 2 3 &amp;quot;Cyprus&amp;quot;).
  (dolist (element '(&amp;quot;Protesilaos&amp;quot; 1 2 3 &amp;quot;Cyprus&amp;quot;))
    ;; 如果元素是字符串则 `push' 到 `found-strings' ，否则跳过它。
    (when (stringp element)
      (push element found-strings)))
  ;; 现在我们完成了 `dolist' ，返回 `found-strings' 最新值。
  found-strings)
;; =&amp;gt; (&amp;quot;Cyprus&amp;quot; &amp;quot;Protesilaos&amp;quot;)


;; 同上面一样但反转结果，这可能更符合直觉一点：
(let ((found-strings nil))
  (dolist (element '(&amp;quot;Protesilaos&amp;quot; 1 2 3 &amp;quot;Cyprus&amp;quot;))
    (when (stringp element)
      (push element found-strings)))
  (nreverse found-strings))
;; =&amp;gt; (&amp;quot;Protesilaos&amp;quot; &amp;quot;Cyprus&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了完整起见，前面的例子如果使用 &lt;code&gt;mapcar&lt;/code&gt; 则必须这样做：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(mapcar
 (lambda (element)
   (when (stringp element)
     element))
 '(&amp;quot;Protesilaos&amp;quot; 1 2 3 &amp;quot;Cyprus&amp;quot;))
;; =&amp;gt; (&amp;quot;Protesilaos&amp;quot; nil nil nil &amp;quot;Cyprus&amp;quot;)


(delq nil
      (mapcar
       (lambda (element)
         (when (stringp element)
           element))
       '(&amp;quot;Protesilaos&amp;quot; 1 2 3 &amp;quot;Cyprus&amp;quot;)))
;; =&amp;gt; (&amp;quot;Protesilaos&amp;quot; &amp;quot;Cyprus&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为 &lt;code&gt;mapcar&lt;/code&gt; 会开心地累积所有的返回值，它返回一个包含 &lt;code&gt;nil&lt;/code&gt; 的列表。如果你想要那样，你可能甚至不会费力在那里使用 &lt;code&gt;when&lt;/code&gt; 子句。 &lt;code&gt;delq&lt;/code&gt; 被应用于 &lt;code&gt;mapcar&lt;/code&gt; 的返回值用来删除所有 &lt;code&gt;nil&lt;/code&gt; 实例。现在将这个繁琐的流程与 &lt;code&gt;seq-filter&lt;/code&gt; 进行比较：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(seq-filter #'stringp '(&amp;quot;Protesilaos&amp;quot; 1 2 3 &amp;quot;Cyprus&amp;quot;))
;; =&amp;gt; (&amp;quot;Protesilaos&amp;quot; &amp;quot;Cyprus&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当你只需要检测元素是否满足谓词函数并返回该元素时， &lt;code&gt;seq-filter&lt;/code&gt; 是最佳工具。但你不能返回其他东西而 &lt;code&gt;mapcar&lt;/code&gt; 会毫无怨言地接受任何返回值，例如以下代码：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(delq nil
      (mapcar
       (lambda (element)
         (when (stringp element)
           ;; `mapcar' 会积累任意返回值，所以需要的话我们能改变
           ;; 每个元素的返回值
           (upcase element)))
       '(&amp;quot;Protesilaos&amp;quot; 1 2 3 &amp;quot;Cyprus&amp;quot;)))
;; =&amp;gt; (&amp;quot;PROTESILAOS&amp;quot; &amp;quot;CYPRUS&amp;quot;)

(seq-filter
 (lambda (element)
   (when (stringp element)
     ;; `seq-filter' 只返回那些具有非 nil 返回值的元素，
     ;; 但它返回的是元素本身，而不是在这里返回的值。
     ;; 换句话说，这个 `lambda' 做了没意义的事。
     (upcase element)))
 '(&amp;quot;Protesilaos&amp;quot; 1 2 3 &amp;quot;Cyprus&amp;quot;))
;; =&amp;gt; (&amp;quot;Protesilaos&amp;quot; &amp;quot;Cyprus&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你该怎么遍历列表元素取决于你想做什么。没有单个函数能为你做到所有事。理解里面细微差别，你就可以开始了。哦，还有，一定要看看内置的 &lt;code&gt;seq&lt;/code&gt; 库（使用 M-x (&lt;code&gt;execute-extended-command&lt;/code&gt;)，调用 &lt;code&gt;find-library&lt;/code&gt; ，然后搜索 &lt;code&gt;seq&lt;/code&gt; ）。然后看看 &lt;code&gt;seq.el&lt;/code&gt; 的源代码：它定义了许多函数，如 &lt;code&gt;seq-take~、~seq-find~、~seq-union&lt;/code&gt; 。另一种方法是调用命令 &lt;code&gt;shortdoc&lt;/code&gt; 并阅读文档组里 &lt;code&gt;list&lt;/code&gt; 以及 &lt;code&gt;sequence&lt;/code&gt; 里的内容。&lt;/p&gt;&lt;h2 id=&quot;上次搜索的匹配数据&quot;&gt;上次搜索的匹配数据&lt;/h2&gt;&lt;p&gt;当你使用 Emacs Lisp 时你会遇到“匹配数据”（match data）的概念以及相关的函数 &lt;code&gt;match-data~、~match-beginning~、~match-string&lt;/code&gt; 等等。这些指的是上次搜索的结果通常用来给 &lt;code&gt;re-search-forward~、~looking-at~、~string-match&lt;/code&gt; 及相关函数执行。每次你执行搜索时，匹配数据都会更新。请注意这是个常见的副作用 (&lt;a href=&quot;#副作用和返回值&quot;&gt;副作和返回值&lt;/a&gt;)。如果你忘记了它你的代码很可能做不对事。&lt;/p&gt;&lt;p&gt;在下面的代码块中我定义了一个函数，它在当前缓冲区中进行搜索并返回一个不带文本属性的匹配数据列表(&lt;a href=&quot;#文本具有自身属性&quot;&gt;文本具有自身属性&lt;/a&gt;)。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-get-match-data (regexp)
  &amp;quot;使用 REGEXP 搜索前（下）面的内容并返回匹配结果否则返回 nil 。&amp;quot;
  (when (re-search-forward regexp nil t)
    (list
     :beginning (match-beginning 0)
     :end (match-end 0)
     :string (match-string-no-properties 0))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你可以用一个字符串参数来调用它，该参数为一个 Emacs Lisp 正则表达式：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(my-get-match-data &amp;quot;Protesilaos.*Cyprus&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果正则表达式匹配，那么你会得到匹配数据。这是一些示例文本：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-fundamental&quot;&gt;Protesilaos lives in the mountains of Cyprus.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将光标放在该文本前面，并使用 M-: (&lt;code&gt;eval-expression&lt;/code&gt;) 来求值我上面带上的 regexp 的 &lt;code&gt;my-get-match-data&lt;/code&gt; 。你会如正预期得到一个返回值。&lt;/p&gt;&lt;p&gt;按照 &lt;code&gt;my-get-match-data&lt;/code&gt; 的编写，它做了两件事：(i) 它有将光标移动到找到的文本末尾的副作用，以及 (ii) 它返回一个包含我指定的匹配数据的列表。在许多情况下，你不希望有前面提到的副作用：光标应该停留在原来的位置。因此你可以将你的代码包装在 &lt;code&gt;save-excursion&lt;/code&gt; 中 (&lt;a href=&quot;#切换到另一个缓冲区、窗口或&quot; title=&quot;[运行一些代码或回退到其他代码](#运行一些代码或回退到其他代码&quot;&gt;切换到另一个缓冲区、窗口或 narrowed&lt;/a&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-get-match-data (regexp)
  &amp;quot;使用 REGEXP 搜索前（下）面的内容并返回匹配结果否则返回 nil 。&amp;quot;
  (save-excursion ; 我们使用 `save-excursion' 包装了这里的代码来抑制副作用
    (when (re-search-forward regexp nil t)
      (list
       :beginning (match-beginning 0)
       :end (match-end 0)
       :string (match-string-no-properties 0)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你对这个版本的 &lt;code&gt;my-get-match-data&lt;/code&gt; 求值然后重试我上面函数调用，你会注意到你是怎样得到预期的返回值而且没有移动光标（cursor）到匹配文本末尾的副作用。在实践中这是一个有用的工具，可以与 &lt;code&gt;save-match-data&lt;/code&gt; 结合使用。想象一下你想在你执行的另一次搜索内部进行一次前向搜索，例如检测上下文中是否存在某个正则表达式的匹配，但需要抑制对你操作的匹配数据的修改。因此：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-get-match-data-with-extra-check (regexp)
  &amp;quot;使用 REGEXP 向前（下）搜索且后面不能有空格匹配，返回匹配数据，否则返回 nil 。&amp;quot;
  (save-excursion
    (when (and (re-search-forward regexp nil t)
               (save-match-data (not (looking-at &amp;quot;[\s\t]+&amp;quot;))))
      ;; 返回第一次搜索的匹配数据,
      ;; 第二次搜索（用于检查空格或制表符）
      ;; 只是一个额外的检查，我们不想使用它的匹配数据，因此
      ;; 在它周围使用了 `save-match-data' 。
      (list
       :beginning (match-beginning 0)
       :end (match-end 0)
       :string (match-string-no-properties 0)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对函数 &lt;code&gt;my-get-match-data-with-extra-check&lt;/code&gt; 求值，然后用 M-: (&lt;code&gt;eval-expression&lt;/code&gt;) 调用它进行测试，它在下面的第二个例子中返回一个非 &lt;code&gt;nil&lt;/code&gt; 值，但在第一个例子中不返回。这是预期结果。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(my-get-match-data-with-extra-check &amp;quot;Protesilaos.*Cyprus&amp;quot;)
;; =&amp;gt; nil


;; Protesilaos, also known as &amp;quot;Prot&amp;quot;, lives in the mountains of Cyprus   .

(my-get-match-data-with-extra-check &amp;quot;Protesilaos.*Cyprus&amp;quot;)
;; =&amp;gt; (:beginning 41988 :end 42032 :string &amp;quot;Protesilaos lives in the mountains of Cyprus&amp;quot;)


;; Protesilaos lives in the mountains of Cyprus.&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;切换到另一个缓冲区、窗口或narrowed&quot;&gt;切换到另一个缓冲区、窗口或 narrowed&lt;/h2&gt;&lt;p&gt;当你以 Emacs Lisp 编程方式做事时，你会遇到需要离开当前位置的情况。你可能需要切换到另一个缓冲区、切换到给定缓冲区的窗口、甚至修改你正在编辑的缓冲区中可见内容。在任何时候这都涉及一个或多个副作用，这些副作用很可能应该在你的函数完成其工作时被撤销 (&lt;a href=&quot;#副作用和返回值&quot;&gt;副作用与返回值&lt;/a&gt;)。&lt;/p&gt;&lt;p&gt;可能最常见的情况是恢复 &lt;code&gt;point&lt;/code&gt; 。你有一些在缓冲区中向后或向前移动以执行匹配给定文本片段的的代码。但是之后你需要将光标留在它原来的位置否则用户会失去方向感。将你的代码包装在 &lt;code&gt;save-excursion&lt;/code&gt; 中，你就搞定了，正如我在别处展示的那样 (&lt;a href=&quot;#上次搜索的匹配数据&quot;&gt;上次搜索的匹配数据&lt;/a&gt;)：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(save-excursion ; 当事情做完后归还 `point'
  MOVE-AROUND-IN-THIS-BUFFER)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;save-window-excursion&lt;/code&gt; 的原理相同，它允许你选择另一个窗口（例如 &lt;code&gt;select-window&lt;/code&gt; ），在其缓冲区中移动，然后恢复窗口的原状：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(save-window-excursion
  (select-window SOME-WINDOW)
  MOVE-AROUND-IN-THIS-BUFFER)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;save-restriction&lt;/code&gt; 允许你恢复缓冲区的当前 narrow 状态。然后你可以选择 &lt;code&gt;widen&lt;/code&gt; 或 &lt;code&gt;narrow-to-region&lt;/code&gt; （还有像 &lt;code&gt;org-narrow-to-subtree&lt;/code&gt; 这样的相关命令），做你必须要做的事后然后将缓冲区恢复到开始状态。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;;; 这里我们假设我们开始于一个展开状态。
;; 然后我们收窄到当前的 Org 标题以获取下面所有内容作为一个巨大字符串。
;; 最后由于 `save-restriction' 的作用我们会再次展开。
(save-restriction
  (org-narrow-to-subtree)
  (buffer-string))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据具体情况你可能得需要组合使用上述方法。请注意 &lt;code&gt;save-restriction&lt;/code&gt; 的文档告诉你要将 &lt;code&gt;save-excursion&lt;/code&gt; 作为最外层的调用。除此之外，你还会发现一些情况需要不同的方法来执行对应条件下的行为 (&lt;a href=&quot;#运行一些代码或回退到其他代码&quot;&gt;运行一些代码或回退到其他代码&lt;/a&gt;)。&lt;/p&gt;&lt;h2 id=&quot;if,cond等基本控制流&quot;&gt;&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt; 等基本控制流&lt;/h2&gt;&lt;p&gt;你不需要任何条件逻辑来执行基本操作。例如如果你编写一个向下移动 15 行的命令，当它无法移动超过你指定的数量时，它自然会在缓冲区末尾停止。使用 &lt;code&gt;defun&lt;/code&gt; ，你编写一个交互式函数（即一个“命令”）来无条件用 &lt;code&gt;forward-line&lt;/code&gt; 向下移动 15 行（用负数调用它会反向移动）：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-15-lines-down ()
  &amp;quot;向下移动最多 15 行。&amp;quot;
  (interactive)
  (forward-line 15))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;my-15-lines-down&lt;/code&gt; 基本是最简洁的形式：它包装了一个基本函数并向其传递一个固定参数，在本例中是数字 &lt;code&gt;15&lt;/code&gt; 。使用 M-x (&lt;code&gt;execute-extended-command&lt;/code&gt;) 然后输入名字调用此命令。它有用！一旦你决定要在满足给定条件时才执行某些操作，事情就会变得更加复杂。这种不同分支之间的逻辑序列“控制流”是用 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt; 和 &lt;code&gt;cond&lt;/code&gt; 等等来表达的。根据具体情况， &lt;code&gt;and&lt;/code&gt; 以及 &lt;code&gt;or&lt;/code&gt; 可能也够用了。&lt;/p&gt;&lt;p&gt;让你的 &lt;code&gt;my-15-lines-down&lt;/code&gt; 变得更聪明一点怎么样？当它处于缓冲区的最末尾时，让它向上移动 15 行。为什么？因为这只是一个演示，所以为什么不呢？检测游标（point）是否在缓冲区末尾的谓词函数是 &lt;code&gt;eobp&lt;/code&gt; 。一个“谓词”是一个函数其条件满足时返回 true（技术上讲是非 &lt;code&gt;nil&lt;/code&gt; ），否则返回 &lt;code&gt;nil&lt;/code&gt; (&lt;a href=&quot;#副作用和返回值&quot;&gt;副作用与返回值&lt;/a&gt;)。至于这个奇怪的名字，Emacs Lisp 中惯例以 &lt;code&gt;p&lt;/code&gt; 后缀结束作为谓词函数名称：如果函数名由多个单词组成（通常用破折号分隔）则谓词函数命名为 &lt;code&gt;NAME-p&lt;/code&gt; ，例如 &lt;code&gt;string-match-p&lt;/code&gt; ；否则命名为 &lt;code&gt;NAMEp&lt;/code&gt; 例如 &lt;code&gt;stringp&lt;/code&gt; 。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-15-lines-down-or-up ()
  &amp;quot;向下移动最多 15 行或者掉头当`eobp' 为非 nil 。&amp;quot;
  (interactive)
  (if (eobp)
      (forward-line -15)
    (forward-line 15)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对这个函数求值，然后键入 M-x (&lt;code&gt;execute-extended-command&lt;/code&gt;) 并调用 &lt;code&gt;my-15-lines-down-or-up&lt;/code&gt; 来感受一下。下面是一个类似想法，如果 &lt;code&gt;eobp&lt;/code&gt; 返回非 &lt;code&gt;nil&lt;/code&gt; 它会抛出错误并退出正在做的事情：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-15-lines-down-or-error ()
  &amp;quot;当 `eobp' 返回非 nil 值时抛错，否则向下移动 15 行&amp;quot;
  (interactive)
  (if (eobp)
      (error &amp;quot;Already at the end; will not move further&amp;quot;)
    (forward-line 15)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Emacs Lisp 的一个怪癖（或许一直以来都被认为是一个特性）是它的缩进方式。只需标记你写好的代码并键入 TAB: Emacs 会负责按应有的方式对其进行缩进。在 &lt;code&gt;if&lt;/code&gt; 语句的情况下，&amp;quot;then&amp;quot; 部分比逻辑的 &amp;quot;else&amp;quot; 部分缩进得更深。这种缩进没有特殊含义：你可以把所有东西写在一行上，比如 &lt;code&gt;(if COND THIS ELSE)&lt;/code&gt; ，顺便说一下，这看起来像一个典型列表 (&lt;a href=&quot;#符号，匹配括号表达式和引用&quot;&gt;符号，匹配括号表达式和引用&lt;/a&gt;)。缩进的作用是帮助你意识到括号的不平衡。如果不同的表达式以看着奇怪的方式对齐，那么你很可能缺少一个括号或多了括号。通常，同一级别的表达式都会以相同的方式对齐。更深层次的表达式会有更多的缩进，依此类推。经验会让你能发现括号不匹配的错误。但即使你没有识别出来，你最终也会得到一个错误。放心吧！&lt;/p&gt;&lt;p&gt;&lt;code&gt;if&lt;/code&gt; 的写法就像一个接受两个或多个参数的函数。“更多”的部分都算作 &amp;quot;else&amp;quot; 逻辑的一部分。因此 &lt;code&gt;(if COND THIS)&lt;/code&gt; 没有 &amp;quot;else&amp;quot; 逻辑，而 &lt;code&gt;(if COND THIS ELSE1 ELSE2 ELSE3)&lt;/code&gt; 将按顺序运行 &lt;code&gt;ELSE1=、=ELSE2&lt;/code&gt; 和 &lt;code&gt;ELSE3&lt;/code&gt; 作为 &amp;quot;else&amp;quot; 分支的一部分。当加上到合适的缩进时，它看起来是这样的：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(if COND
    THIS
  ELSE1
  ELSE2
  ELSE3)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么如果 &lt;code&gt;THIS&lt;/code&gt; 部分需要大于一个函数调用呢？Elisp 有 &lt;code&gt;progn&lt;/code&gt; 形式，你可以用它来包装函数调用并将它们作为一个单一参数传递。把它们放在一起你的代码现在会像这样：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(if COND
    (progn
      THIS1
      THIS2
      THIS3)
  ELSE1
  ELSE2
  ELSE3)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你不需要 &amp;quot;else&amp;quot; 部分，使用 &lt;code&gt;when&lt;/code&gt; 来表达你的意思。在内部这是一个宏实际上代表 &lt;code&gt;(if COND (progn EXPRESSIONS))&lt;/code&gt; ，其中 &lt;code&gt;EXPRESSIONS&lt;/code&gt; 是一个或多个表达式。一个 &lt;code&gt;when&lt;/code&gt; 看起来像这样：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(when COND
  THIS1
  THIS2
  THIS3)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同样， &lt;code&gt;unless&lt;/code&gt; 的意味者 &lt;code&gt;(when (not COND) EXPRESSIONS)&lt;/code&gt; 。它也是一个宏扩展为一个 &lt;code&gt;if&lt;/code&gt; 语句：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(unless COND
  THIS1
  THIS2
  THIS3)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当你检测的条件有多个部分时，你可以使用 &lt;code&gt;and&lt;/code&gt; 以及 &lt;code&gt;or&lt;/code&gt; ：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(when (or THIS THAT)
  EXPRESSIONS)

(when (and THIS THAT)
  EXPRESSIONS)

(when (or (and THIS THAT) OTHER)
  EXPRESSIONS)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据具体情况，多个 &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt; 的组合看起来很别扭。你可以使用 &lt;code&gt;cond&lt;/code&gt; 将逻辑分解为不同的条件，这些条件从上到下依次检测。 &lt;code&gt;cond&lt;/code&gt; 的写法是一个列表的列表，这些列表不需要引用 (&lt;a href=&quot;#宏或特殊形式里的求值&quot;&gt;宏或特殊形式里的求值&lt;/a&gt;)。抽象地说，它看起来像这样：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(cond
 (CONDITION1
  CONSEQUENCES1)
 (CONDITION2
  CONSEQUENCES2)
 (CONDITION3
  CONSEQUENCES3)
 (t
  CONSEQUENCES-FALLBACK))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每个 CONSEQUENCES 都可以是任意数量的表达式，就像你上面看到的 &lt;code&gt;when&lt;/code&gt; 一样。这是一个展示 &lt;code&gt;cond&lt;/code&gt; 行为的玩具函数：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-toy-cond (argument)
  &amp;quot;根据 ARGUMENT 类型返回结果。&amp;quot;
  (cond
   ((and (stringp argument)
         (string-blank-p argument))
    (message &amp;quot;You just gave me a blank string; try harder!&amp;quot;))
   ((stringp argument)
    (message &amp;quot;I see you can do non-blanks string; I call that progress.&amp;quot;))
   ((null argument)
    (message &amp;quot;Yes, the nil is an empty list like (), but do not worry about it&amp;quot;))
   ((listp argument)
    (message &amp;quot;Oh, I see you are in the flow of using lists!&amp;quot;))
   ((symbolp argument)
    (message &amp;quot;What's up with the symbols, mate?&amp;quot;))
   ((natnump argument)
    (message &amp;quot;I fancy those natural numbers!&amp;quot;))
   ((numberp argument)
    (message &amp;quot;You might as well be a math prodigy!&amp;quot;))
   (t
    (message &amp;quot;I have no idea what type of thing your argument `%s' is&amp;quot; argument))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我希望你对其求值并传递不同的参数来测试它做了什么 (&lt;a href=&quot;#EmacsLisp求值&quot;&gt;Emacs Lisp 求值&lt;/a&gt;)。这里有两个例子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(my-toy-cond &amp;quot;&amp;quot;)
;; =&amp;gt; &amp;quot;You just gave me a blank string; try harder!&amp;quot;

(my-toy-cond '(1 2 3))
;; =&amp;gt; &amp;quot;Oh, I see you are in the flow of using lists!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上所有内容在 Emacs Lisp 中都很常见。另一个强大的宏是 &lt;code&gt;pcase&lt;/code&gt; ，由于其特殊性，我们将单独考虑它 ([&lt;code&gt;pcase&lt;/code&gt; 及其相关形式的模式匹配](#pcase 及其相关形式的模式匹配))。&lt;/p&gt;&lt;h2 id=&quot;if-let*控制流及其相关形式&quot;&gt;&lt;code&gt;if-let*&lt;/code&gt; 控制流及其相关形式&lt;/h2&gt;&lt;p&gt;&lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;let*&lt;/code&gt; 声明了仅在当前作用域内（即 &lt;code&gt;let&lt;/code&gt; 的 &lt;code&gt;BODY&lt;/code&gt; 部分）可使用的变量。比如：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(let BINDINGS
  BODY)

(let ((variable1 value1)
      (variable2 value2))
  BODY)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;BINDINGS&lt;/code&gt; 是一个列表的列表，不需要引用 (&lt;a href=&quot;#宏或特殊形式里的求值&quot;&gt;宏或特殊形式内部的求值&lt;/a&gt;)。而 &lt;code&gt;BODY&lt;/code&gt; 由一个或多个表达式组成，我在本书的其他地方也将其命名为 &lt;code&gt;EXPRESSIONS&lt;/code&gt; 。 &lt;code&gt;let&lt;/code&gt; 和 &lt;code&gt;let*&lt;/code&gt; （读作 &amp;quot;let star&amp;quot;）的区别在于，后者让较早的绑定可被用于较晚的绑定，就像这样：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;;; 这可以生效因为 `greeting' 可以使用 `name' 和 `country' ，
;; 多亏了 `let*' ：
(let* ((name &amp;quot;Protesilaos&amp;quot;)
       (country &amp;quot;Cyprus&amp;quot;)
       (greeting (format &amp;quot;Hello %s of %s&amp;quot; name country)))
  (DO-STUFF-WITH greeting))

;; 但这失败了……
(let ((name &amp;quot;Protesilaos&amp;quot;)
      (country &amp;quot;Cyprus&amp;quot;)
      (greeting (format &amp;quot;Hello %s of %s&amp;quot; name country)))
  (DO-STUFF-WITH greeting))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有时你想要做的是，当且仅当这些绑定都非 &lt;code&gt;nil&lt;/code&gt; 时才创建它们。如果它们的值是 &lt;code&gt;nil&lt;/code&gt; 那么它们对你来说是没用的，在这种情况下你会想做别的事 ([&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt; 等基本控制流](#if,cond 等基本控制流))。当你使用函数调用或某个其他变量的返回值创建绑定时值可能是 &lt;code&gt;nil&lt;/code&gt; 也可能不是。你总可以写这样的代码：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(let ((variable1 (SOME-FUNCTION SOME-ARGUMENT))
      (variable2 (OTHER-FUNCTION OTHER-ARGUMENT)))
  (if (and variable1 variable2) ; 简单检测两个变量是否非 nil
      THIS
    ELSE))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是你可以用 &lt;code&gt;if-let*&lt;/code&gt; 做同样的事情，其中 &lt;code&gt;THIS&lt;/code&gt; 部分仅在所有绑定都非 &lt;code&gt;nil&lt;/code&gt; 时运行：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(if-let* ((variable1 (SOME-FUNCTION SOME-ARGUMENT))
          (variable2 (OTHER-FUNCTION OTHER-ARGUMENT)))
    THIS
  ELSE)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 &lt;code&gt;ELSE&lt;/code&gt; 部分，绑定 &lt;code&gt;variable1&lt;/code&gt; 和 &lt;code&gt;variable2&lt;/code&gt; 不存在：它们只存在于代码 &lt;code&gt;THIS&lt;/code&gt; 部分。&lt;/p&gt;&lt;p&gt;&lt;code&gt;when-let*&lt;/code&gt; 与 &lt;code&gt;when&lt;/code&gt; 相同，意味着它没有 &amp;quot;else&amp;quot; 逻辑。如果它的某个绑定是 &lt;code&gt;nil&lt;/code&gt; ，那么整个 &lt;code&gt;when-let*&lt;/code&gt; 返回 &lt;code&gt;nil&lt;/code&gt; 。无需再赘述这一点。&lt;/p&gt;&lt;p&gt;随着你深入研究 Emacs Lisp 生态，你会遇到 &lt;code&gt;if-let*&lt;/code&gt; 用法，它 (i) 像 &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;let*&lt;/code&gt; 一样创建多个绑定，但 (ii) 也使用一个谓词函数来测试它们是否应该继续执行逻辑的 &lt;code&gt;THIS&lt;/code&gt; 部分。记住，如果 &lt;code&gt;if-let*&lt;/code&gt; 的某个绑定返回 &lt;code&gt;nil&lt;/code&gt; ，它会直接转到 &lt;code&gt;ELSE&lt;/code&gt; 。考虑这个例子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(if-let* ((variable1 (SOME-FUNCTION SOME-ARGUMENT))
          ;; 下划线 _ 表明：“不用绑定这个；
          ;; 我只关心返回值是否为非 nil ”。我们在这里检测
          ;; `variable1' 是否是字符串：如果是
          ;; 我们继续之后绑定，否则移动到代码
          ;; 的 ELSE 部分
          (_ (stringp variable1))
          (variable2 (OTHER-FUNCTION OTHER-ARGUMENT)))
    THIS
  ELSE)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;没有绝对胜出的方法，关键在于为手头的任务使用正确的工具。有时你希望创建绑定，即使它们的值是 &lt;code&gt;nil&lt;/code&gt; 。选择有意义的方式。&lt;/p&gt;&lt;h2 id=&quot;pcase及其相关形式的模式匹配&quot;&gt;&lt;code&gt;pcase&lt;/code&gt; 及其相关形式的模式匹配&lt;/h2&gt;&lt;p&gt;一旦你掌握了用 Emacs Lisp 表达想法的流程，你将能熟练使用 &lt;code&gt;if~、~cond&lt;/code&gt; 及类似形式 (&lt;a href=&quot;#if,cond等基本控制流&quot;&gt;&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt; 等基本控制流&lt;/a&gt;)。如果使用 &lt;code&gt;if-let*&lt;/code&gt; ，你甚至可能玩得更高级 (&lt;a href=&quot;#if-let*控制流及其相关形式&quot;&gt; &lt;code&gt;if-let*&lt;/code&gt; 及其相关形式控制流&lt;/a&gt;)。然而无论你怎么做，有些情况下更简洁的表达方式无疑更好。这就是 &lt;code&gt;pcase&lt;/code&gt; 发挥作用的地方。在其基本的表达中，它类似于 &lt;code&gt;cond&lt;/code&gt; ，因为它测试给定表达式的返回值与一系列条件的匹配情况。这里有一个例子，将变量 &lt;code&gt;major-mode&lt;/code&gt; 的缓冲区局部值（buffer-local value）与几个已知的符号进行相等比较：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(pcase major-mode
  ('org-mode (message &amp;quot;You are in Org&amp;quot;))
  ('emacs-lisp-mode (message &amp;quot;You are in Emacs Lisp&amp;quot;))
  (_ (message &amp;quot;You are somewhere else&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面与这个 &lt;code&gt;cond&lt;/code&gt; 的想法相同：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(cond
 ((eq major-mode 'org-mode)
  (message &amp;quot;You are in Org&amp;quot;))
 ((eq major-mode 'emacs-lisp-mode)
  (message &amp;quot;You are in Emacs Lisp&amp;quot;))
 (t
  (message &amp;quot;You are somewhere else&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一些程序员可能会争论说 &lt;code&gt;pcase&lt;/code&gt; 更优雅。我认为在这个具体例子中确实如此，但我想保持灵活和务实：我会使用对我正在编写的代码更有意义的任何方式。谈到优雅，我想告诉你几乎所有的条件逻辑都可以用一种意想不到的方法来完成。考虑一下我在本书中的例子是如何重复使用 &lt;code&gt;message&lt;/code&gt; 的，而实际上唯一改变的部分是传递给该函数的实际字符串/参数。这样做同样有效：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(message
 (pcase major-mode
   ('org-mode &amp;quot;You are in Org&amp;quot;)
   ('emacs-lisp-mode &amp;quot;You are in Emacs Lisp&amp;quot;)
   (_ &amp;quot;You are somewhere else&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于 &lt;code&gt;if~、~when&lt;/code&gt; 和其余的也是同样的概念。&lt;/p&gt;&lt;p&gt;回到 &lt;code&gt;pcase&lt;/code&gt; 有什么不同的主题。如果你阅读它的文档，你会意识到它有自己的迷你语言或称为“领域特定语言”（DSL）。这对于宏来说很常见 (&lt;a href=&quot;#宏或特殊形式里的求值&quot;&gt;宏或特殊形式里的求值&lt;/a&gt;)。它们定义了求值如何完成以及哪种表达式被特殊处理。那么让我送你这个玩具函数，它说明了现在讨论 DSL 的一些主要特性：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-toy-pcase (argument)
  &amp;quot;使用 `pcase' 根据 ARGUMENT 来返回合适结果。&amp;quot;
  (pcase argument
    (`(,one ,_ ,three)
     (message &amp;quot;List where first element is `%s', second is ignored, third is `%s'&amp;quot; one three))
    (`(,one . ,two)
     (message &amp;quot;Cons cell where first element is `%s' and second is `%s'&amp;quot; one two))
    ((pred stringp)
     (message &amp;quot;The argument is a string of some sort&amp;quot;))
    ('hello
     (message &amp;quot;The argument is equal to the symbol `hello'&amp;quot;))
    (_ (message &amp;quot;This is the fallback&amp;quot;))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对函数求值然后试一下 (&lt;a href=&quot;#EmacsLisp求值&quot;&gt;Emacs Lisp 求值&lt;/a&gt;)。下面是几个例子：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(my-toy-pcase '(&amp;quot;Protesilaos&amp;quot; &amp;quot;of&amp;quot; &amp;quot;Cyprus&amp;quot;))
;; =&amp;gt; &amp;quot;List where first element is ‘Protesilaos’, second is ignored, third is ‘Cyprus’&amp;quot;

(my-toy-pcase '(&amp;quot;Protesilaos&amp;quot; . &amp;quot;Cyprus&amp;quot;))
;; =&amp;gt; &amp;quot;Cons cell where first element is ‘Protesilaos’ and second is ‘Cyprus’&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中一些子句是 &lt;code&gt;cond&lt;/code&gt; 的不同表达方式，说不定更好，但在我看来并非绝对的赢家。令人印象深刻且真正带来范式转变的是“解构”（destructuring）的概念，即对表达式进行模式匹配，它有效地将列表或序对的元素通过 &lt;code&gt;let&lt;/code&gt; 绑定到它们对应的索引。用于这种解构的语法是晦涩难懂的，直到你将其与用于部分求值的准引用（quasi quote）和逗号联系起来 (&lt;a href=&quot;#列表里的部分求值&quot;&gt;列表里的部分求值&lt;/a&gt;)。考虑到这一点，将 &lt;code&gt;pcase-let&lt;/code&gt;, &lt;code&gt;pcase-let*&lt;/code&gt;, &lt;code&gt;pcase-lambda&lt;/code&gt; 和 &lt;code&gt;pcase-dolist&lt;/code&gt; 视为普通的 &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;let*&lt;/code&gt;, &lt;code&gt;lambda&lt;/code&gt; 和 &lt;code&gt;dolist&lt;/code&gt; 的增加了支持解构特性的变体。不过，它们并没有做 &lt;code&gt;pcase&lt;/code&gt; 的任何额外功能——只是在它们熟悉的行为之上增加了解构！这在你处理函数返回值为列表的时候特别有用。我不会详细阐述，因为这是一个高级用例。如果你已经到了那个水平你不需要我告诉你该写什么。对于像我一样其他人，通常处理更简单的代码， &lt;code&gt;pcase-let&lt;/code&gt; 足以说明这个原理：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-split-string-at-space (string)
  &amp;quot;以空格分割 STRING 并放在一个列表内然后返回。&amp;quot;
  (split-string string &amp;quot;\s&amp;quot;))

(pcase-let ((`(,one ,_ ,three) (my-split-string-at-space &amp;quot;Protesilaos of Cyprus&amp;quot;)))
  (message &amp;quot;This is like `let', but we got `%s' and `%s' via destructuring&amp;quot; one three))
;; =&amp;gt; &amp;quot;This is like ‘let’, but we got ‘Protesilaos’ and ‘Cyprus’ via destructuring&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你是否使用 &lt;code&gt;pcase&lt;/code&gt; 和解构一般取决于你。你不需要它们来编写高质量的代码。不过你可能会同意那些人的观点，认为它们更优雅。因此选择使用它们来使代码简洁而更富有表现力。&lt;/p&gt;&lt;h2 id=&quot;运行一些代码或回退到其他代码&quot;&gt;运行一些代码或回退到其他代码&lt;/h2&gt;&lt;p&gt;你典型代码会依赖 &lt;code&gt;if~、~cond&lt;/code&gt; 等控制流 (&lt;a href=&quot;#if,cond等基本控制流&quot;&gt;&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt; 等基本控制流&lt;/a&gt;)。根据你的具体需求或风格考虑，它甚至可能包括 &lt;code&gt;pcase&lt;/code&gt; (&lt;a href=&quot;#pcase及其相关形式的模式匹配&quot;&gt; &lt;code&gt;pcase&lt;/code&gt; 及其相关形式的模式匹配&lt;/a&gt;) 以及 &lt;code&gt;if-let*&lt;/code&gt; (&lt;a href=&quot;#if-let*控制流及其相关形式&quot;&gt; &lt;code&gt;if-let*&lt;/code&gt; 及其相关形式控制流&lt;/a&gt;)。然而有些情况下你必须在主要操作结束或退出后运行额外的代码。其思想是清理你创建的任何中间状态。逻辑是“用所有必要副作用做这件事，然后无论发生什么也要做那件事以便撤销副作用。” 这是 &amp;quot;unwinding&amp;quot; 的概念，通过 &lt;code&gt;unwind-protect&lt;/code&gt; 实现。&lt;/p&gt;&lt;p&gt;在下面的代码块中我定义了一个函数，它会产生一个 minibuffer 输入栏，要求你提供 &lt;code&gt;y&lt;/code&gt; 或 &lt;code&gt;n&lt;/code&gt; 的答案，这是 &amp;quot;yes&amp;quot; 或 &amp;quot;no&amp;quot; 的简写。它检测 &lt;code&gt;y-or-n-p&lt;/code&gt; 的返回值来决定需要做什么。当输入栏打开时，该函数会高亮显示当前缓冲区中正则表达式 &lt;code&gt;(defun&lt;/code&gt; 的所有匹配。在你完成 minibuffer 及其后续后，这些高亮都必须消失。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-prompt-with-temporary-highlight ()
  &amp;quot;询问确认和等待时高亮所有正则匹配。&amp;quot;
  (let ((regexp &amp;quot;(defun&amp;quot;))
    (unwind-protect
        (progn
          (highlight-regexp regexp)
          (if (y-or-n-p &amp;quot;Should we proceed or not? &amp;quot;)
              (message &amp;quot;You have decided to proceed&amp;quot;)
            (message &amp;quot;You prefer not to continue&amp;quot;)))
      (unhighlight-regexp regexp))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在你的 Emacs 中尝试上面的代码来感受一下。当“是或否”提示处于活动状态时，也执行 C-g (&lt;code&gt;keyboard-quit&lt;/code&gt;) 或 C-] (&lt;code&gt;abort-recursive-edit&lt;/code&gt;) 来确认就算在输入栏后续代码从未运行高亮也会被移除。你甚至可以修改函数以产生错误：它将创建一个 backtrace ，当你从 &lt;code&gt;*Backtrace*&lt;/code&gt; 窗口执行 q (&lt;code&gt;debugger-quit&lt;/code&gt;) 后，仍然会产生 unwinding 的效果。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-prompt-with-temporary-highlight-try-with-error ()
  &amp;quot;询问确认和等待时高亮所有正则匹配。&amp;quot;
  (let ((regexp &amp;quot;(defun&amp;quot;))
    (unwind-protect
        (progn
          (highlight-regexp regexp)
          (error &amp;quot;This error makes no sense here; close the backtrace to test the unwinding&amp;quot;)
          (if (y-or-n-p &amp;quot;Should we proceed or not? &amp;quot;)
              (message &amp;quot;You have decided to proceed&amp;quot;)
            (message &amp;quot;You prefer not to continue&amp;quot;)))
      (unhighlight-regexp regexp))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;退一步看，你会发现 &lt;code&gt;unwind-protect&lt;/code&gt; 是像 &lt;code&gt;save-excursion&lt;/code&gt; 和 &lt;code&gt;save-restriction&lt;/code&gt; (&lt;a href=&quot;#切换到另一个缓冲区、窗口或narrowed&quot;&gt;切换到另一个缓冲区、窗口或 narrowed&lt;/a&gt;) 这样专门形式的更为通用的形式，同时它支持着 &lt;code&gt;save-match-data&lt;/code&gt; (&lt;a href=&quot;#上次搜索的匹配数据&quot;&gt;上次搜索的匹配数据&lt;/a&gt;) 以及许多其他函数/宏，例如 &lt;code&gt;with-temp-buffer&lt;/code&gt; 和 &lt;code&gt;save-window-excursion~。~unwind-protect&lt;/code&gt; ，但不对对信号（例如来自 &lt;code&gt;error&lt;/code&gt; 函数的信号）做出特殊响应：它会允许错误发生，这意味着将显示回溯并且你的代码将在那里退出（但是 unwinding 仍然会起作用，正如我已之前解释过的，在你关闭 backtrace 后）。要让你的代码以更可控的方式处理信号，你必须依赖 &lt;code&gt;condition-case&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;使用 &lt;code&gt;condition-case&lt;/code&gt; 你可以完全控制代码的行为，包括它应该如何处理错误。换句话说，你的 Elisp 将表达这样的意思：“我想做这个，但如果我得到一个错误，我想做那个来代替。” 有许多信号需要考虑，所有这些都来自 &lt;code&gt;signal&lt;/code&gt; 函数。这些包括符号 &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;user-error&lt;/code&gt;, &lt;code&gt;args-out-of-range&lt;/code&gt;, &lt;code&gt;wrong-type-argument&lt;/code&gt;, &lt;code&gt;wrong-length-argument&lt;/code&gt; 和 &lt;code&gt;quit&lt;/code&gt; ，此外还有程序员任何可能认为必要的其他信号。在下面的代码块中，我向你展示 &lt;code&gt;condition-case&lt;/code&gt; 的样式。请记住有时由于底层的实现方式，你不会像通常那样进行引用 (&lt;a href=&quot;#宏或特殊形式里的求值&quot;&gt;宏或特殊形式里的求值&lt;/a&gt;)。我使用的例子与我用于 &lt;code&gt;unwind-protect&lt;/code&gt; 的例子相同。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-prompt-with-temporary-highlight-and-signal-checks ()
  &amp;quot;询问确认和等待时高亮所有正则匹配。&amp;quot;
  (let ((regexp &amp;quot;(defun&amp;quot;))
    (condition-case nil
        (progn
          (highlight-regexp regexp)
          (if (y-or-n-p &amp;quot;Should we proceed or not? &amp;quot;)
              (user-error &amp;quot;You have decided to proceed; but we need to return a `user-error'&amp;quot;)
            (error &amp;quot;You prefer not to continue; but we need to return an `error'&amp;quot;)))
      (:success
       (unhighlight-regexp regexp)
       (message &amp;quot;No errors, but still need to unwind what we did, plus whatever else we want here&amp;quot;))
      (quit
       (unhighlight-regexp regexp)
       (message &amp;quot;This is our response to the user aborting the prompt&amp;quot;))
      (user-error
       (unhighlight-regexp regexp)
       (message &amp;quot;This is our response to the `user-error' signal&amp;quot;))
      (error
       (unhighlight-regexp regexp)
       (message &amp;quot;This is our response to the `error' signal&amp;quot;)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的函数说明了前面提到的 unwinding 概念和处理信号的机制。 &lt;code&gt;condition-case&lt;/code&gt; 的抽象结构在我看来像是 &lt;code&gt;let~、~unwind-protect&lt;/code&gt; 和 &lt;code&gt;cond&lt;/code&gt; 的混合体。这些条件可能包括特殊的处理程序 &lt;code&gt;:success&lt;/code&gt; 正如我在那里展示的那样。当然我写的代码不会永远导致那个特定成功情况，但你可以修改提示符之后发生的事情，比如说调用 &lt;code&gt;message&lt;/code&gt; 而不是 &lt;code&gt;user-error&lt;/code&gt; 函数，这将被视为一个成功的结果。否则我认为我写的表达式准确地告诉你这个程序如何响应它接收到的信号。&lt;/p&gt;&lt;p&gt;我还没有涵盖的是 &lt;code&gt;condition-case&lt;/code&gt; 类似 &lt;code&gt;let&lt;/code&gt; 的方面，即它如何将错误数据绑定到此作用域里的变量。在我上面实现中，它是你看到的 &lt;code&gt;nil&lt;/code&gt; 意味着我选择不执行这样的绑定，因为我不需要它的数据。下面我决定使用它，仅仅为了演示。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-prompt-with-temporary-highlight-and-signal-checks-with-error-report ()
  &amp;quot;询问确认和等待时高亮所有正则匹配。&amp;quot;
  (let ((regexp &amp;quot;(defun&amp;quot;))
    (condition-case error-data-i-got
        (progn
          (highlight-regexp regexp)
          (if (y-or-n-p &amp;quot;Should we proceed or not? &amp;quot;)
              (user-error &amp;quot;You have decided to proceed; but we need to return a `user-error'&amp;quot;)
            (error &amp;quot;You prefer not to continue; but we need to return an `error'&amp;quot;)))
      (:success
       (unhighlight-regexp regexp)
       (message &amp;quot;No errors, but still need to unwind what we did, plus whatever else we want here&amp;quot;)
       (message &amp;quot;The error is `%s' and its data is `%S'&amp;quot; (car error-data-i-got) (cdr error-data-i-got)))
      (quit
       (unhighlight-regexp regexp)
       (message &amp;quot;This is our response to the user aborting the prompt&amp;quot;)
       (message &amp;quot;The error is `%s' and its data is `%S'&amp;quot; (car error-data-i-got) (cdr error-data-i-got)))
      (user-error
       (unhighlight-regexp regexp)
       (message &amp;quot;This is our response to the `user-error' signal&amp;quot;)
       (message &amp;quot;The error is `%s' and its data is `%S'&amp;quot; (car error-data-i-got) (cdr error-data-i-got)))
      (error
       (unhighlight-regexp regexp)
       (message &amp;quot;This is our response to the `error' signal&amp;quot;)
       (message &amp;quot;The error is `%s' and its data is `%S'&amp;quot; (car error-data-i-got) (cdr error-data-i-got))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有时 &lt;code&gt;unwind-protect&lt;/code&gt; 和 &lt;code&gt;condition-case&lt;/code&gt; 是适合这项工作的工具。我希望这些例子给了你宏观的认知，你现在已经准备好用 Emacs Lisp 来编写你自己的程序了。&lt;/p&gt;&lt;h2 id=&quot;何时使用具名函数或lambda函数&quot;&gt;何时使用具名函数或 lambda 函数&lt;/h2&gt;&lt;p&gt;&lt;code&gt;lambda&lt;/code&gt; 是一个匿名函数。它与 &lt;code&gt;defun&lt;/code&gt; 相对，后者定义一个拥有给定名称的函数。何时使用哪一个很大程度上是风格问题。不过在某些情况下某种方法更合适。经验法则是：如果你需要多次使用该函数，那么给它一个名字然后通过名字调用它。否则，你实际上每次都会重新定义它，这使得重写你的程序变得困难。相比之下，如果函数只是临时用用的，那么用 &lt;code&gt;lambda&lt;/code&gt; 就可以了。&lt;/p&gt;&lt;p&gt;在某些情形下，你会有一个内部使用 &lt;code&gt;lambda&lt;/code&gt; 的命名函数。先修改你会在本书中找到的一个例子 (&lt;a href=&quot;#对列表中的元素进行映射&quot;&gt;对列表中的元素进行映射&lt;/a&gt;)：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-increment-numbers-by-ten (numbers)
  &amp;quot;对 NUMBERS 中的每一个元素加 10 然后返回新的列表。&amp;quot;
  (mapcar
   (lambda (number)
     (+ 10 number))
   numbers))

(my-increment-numbers-by-ten '(1 2 3))
;; =&amp;gt; (11 12 13)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具名函数内部的 &lt;code&gt;lambda&lt;/code&gt; 也可以在 &lt;code&gt;let&lt;/code&gt; 的帮助下用于重复做某事。例如你可能有一个函数需要使用 &lt;code&gt;mapc&lt;/code&gt; 作为副作用来问候一个人员列表，并且你不想多次定义同一个函数：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-greet-teams (&amp;amp;rest teams)
  &amp;quot;对处在 TEAMS 的每一个人说 hello 然后返回一个包含所有团队成员的列表。
TEAMS 的每一个元素都是存着字符串的列表。&amp;quot;
  (let* ((greet-name (lambda (name)
                       (message &amp;quot;Hello %s&amp;quot; name)))
         (greet-team-and-names (lambda (team)
                                 (message &amp;quot;Greeting the team of `%s'...&amp;quot; team)
                                 (mapc greet-name team))))
    (mapcar greet-team-and-names teams)))

(my-greet-teams
 '(&amp;quot;Pelé&amp;quot; &amp;quot;Ronaldo&amp;quot;)
 '(&amp;quot;Maradona&amp;quot; &amp;quot;Messi&amp;quot;)
 '(&amp;quot;Beckenbauer&amp;quot; &amp;quot;Neuer&amp;quot;)
 '(&amp;quot;Platini&amp;quot; &amp;quot;Zidane&amp;quot;)
 '(&amp;quot;Baresi&amp;quot; &amp;quot;Maldini&amp;quot;)
 '(&amp;quot;Eusebio&amp;quot; &amp;quot;Cristiano Ronaldo&amp;quot;)
 '(&amp;quot;Xavi&amp;quot; &amp;quot;Iniesta&amp;quot;)
 '(&amp;quot;Charlton&amp;quot; &amp;quot;Shearer&amp;quot;)
 '(&amp;quot;Puskas&amp;quot; &amp;quot;Kubala&amp;quot;)
 '(&amp;quot;All of the Greece Euro 2004 squad ;)&amp;quot;))
;; =&amp;gt; ((&amp;quot;Pelé&amp;quot; &amp;quot;Ronaldo&amp;quot;) (&amp;quot;Maradona&amp;quot; &amp;quot;Messi&amp;quot;) ...)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;问候语在这种情况下是副作用并且可以在 &lt;code&gt;*Messages*&lt;/code&gt; 缓冲区中找到。你可以使用 C-h e (&lt;code&gt;view-echo-area-messages&lt;/code&gt;) 快速访问该缓冲区。 &lt;code&gt;my-greet-teams&lt;/code&gt; 具体在做什么并不重要。专注于一个命名函数及其内部匿名函数的组合。&lt;/p&gt;&lt;h2 id=&quot;让你的交互式函数从Lisp调用中运行&quot;&gt;让你的交互式函数从 Lisp 调用中运行&lt;/h2&gt;&lt;p&gt;当函数使用 &lt;code&gt;interactive&lt;/code&gt; 规范声明时，它就可以交互式使用。这会将它们变成“命令”然后可以通过名称调用，首先执行 M-x (&lt;code&gt;execute-extended-command&lt;/code&gt;) 然后找到该命令。它也可以分配给一个按键并直接通过按该键调用。在其最简单的形式中， &lt;code&gt;interactive&lt;/code&gt; 规范是一个未引用的列表，如 &lt;code&gt;(interactive)&lt;/code&gt; 。这里有一个简单的例子，它调用 &lt;code&gt;read-string&lt;/code&gt; 来产生一个 minibuffer 输入栏，该输入栏接受用户输入并将其作为字符串返回：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-greet-person ()
  (interactive)
  (message &amp;quot;Hello %s&amp;quot; (read-string &amp;quot;Whom to greet? &amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述实现问题在于它仅在交互式使用中有用。如果你想通过在程序中非交互式地发出这样的问候，你需要编写另一个函数，该函数做几乎相同的事情只是它接受一个 &lt;code&gt;NAME&lt;/code&gt; 参数。像这样：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-greet-person-with-name (name)
  &amp;quot;问候给定的 NAME 。&amp;quot;
  (message &amp;quot;Hello %s&amp;quot; name))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你不需要编写两个实际上做同样事情的独立函数。相反，你可以有一个带有参数的函数，它根据是交互式调用还是编程方式调用来决定如何获取传递给它的参数的值。考虑这种情况：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-greet-interactive-and-non-interactive (name)
  &amp;quot;问候给定的 NAME 。
如果交互式调用，生成一个输入框询问 NAME 。

如果通过 Lisp 调用， NAME 为一个字符串。&amp;quot;
  (interactive (list (read-string &amp;quot;Whom to greet? &amp;quot;)))
  (message &amp;quot;Hello %s&amp;quot; name))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我在上面写的文档准确地告诉你发生了什么。不过让我进一步解释 &lt;code&gt;interactive&lt;/code&gt; ：它接受一个参数，该参数是一个列表，对应于当前 &lt;code&gt;defun&lt;/code&gt; 的参数列表。在这种情况下， &lt;code&gt;defun&lt;/code&gt; 有一个包含单个元素 &lt;code&gt;NAME&lt;/code&gt; 的参数列表。因此， &lt;code&gt;interactive&lt;/code&gt; 也有一个包含一个元素的列表，其值对应于 &lt;code&gt;NAME&lt;/code&gt; 。如果参数不止一个，那么 &lt;code&gt;interactive&lt;/code&gt; 必须相应地编写：它的每个元素将对应于列表中相同索引的参数。&lt;/p&gt;&lt;p&gt;你传递给 &lt;code&gt;interactive&lt;/code&gt; 这个表达式列表本质上是将值绑定到参数的预备工作。当你交互式地调用上面的函数时，你实际上告诉 Emacs 在这种情况下 &lt;code&gt;NAME&lt;/code&gt; 是调用 &lt;code&gt;read-string&lt;/code&gt; 的返回值。对于更多参数原理也是相同，但我还是写下来以明确说明：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-emacs-lisp&quot;&gt;(defun my-greet-with-two-parameters (name country)
  &amp;quot;用来自 COUNTRY 的 NAME 问候某人。
当交互式调用时，产生一个 minibuffer 输入栏，询问 NAME
接着是另一个提示，询问 COUNTRY。

当是来自 Lisp 的调用时， NAME 和 COUNTRY 是字符串。&amp;quot;
  (interactive
   (list
    (read-string &amp;quot;Whom to greet? &amp;quot;)
    (read-string &amp;quot;Where from? &amp;quot;)))
  (message &amp;quot;Hello %s of %s&amp;quot; name country))

(my-greet-with-two-parameters &amp;quot;Protesilaos&amp;quot; &amp;quot;Cyprus&amp;quot;)
;; =&amp;gt; &amp;quot;Hello Protesilaos of Cyprus&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;仔细编写 &lt;code&gt;interactive&lt;/code&gt; 声明，你最终会得到一个既高效又灵活的丰富代码库。&lt;/p&gt;</content></entry><entry><title>2024 年终总结</title><id>https://blog.southfox.me/2025/02/2024-annual-review/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2025-02-16T22:03:00Z</updated><link href="https://blog.southfox.me/2025/02/2024-annual-review/.html" rel="alternate" /><content type="html">&lt;p&gt;什么，已经要 2025 年了？！&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;h2 id=&quot;感受&quot;&gt;感受&lt;/h2&gt;&lt;p&gt;如果要给今年选择一个关键词的话，那么我会选择「适应」，在一个环境安定了下来，然后就开始待住了。时间变得像是静止了一样，上下班然后周末躺躺，然后再上下班。这样没什么不好——如此平平淡淡几十年，直到大厦崩塌（大概率是因为持续的不健康生活作息导致生大病）。不过依我这种用了电脑一段时间就忍不住想重装一遍的性子，这种情况或许持续不了几年，但今年给我最大的感想就是我证明了我能自己一个人过活，哪怕之后到一个重装的新环境我也能适应住。&lt;/p&gt;&lt;p&gt;同时重装也不意味着从零开始，总会有一些「东西」会在重装之前做好备份送往下个环境，今年的「适应」的过程就是在准备者这些「东西」。&lt;/p&gt;&lt;h2 id=&quot;形而下&quot;&gt;形而下&lt;/h2&gt;&lt;p&gt;那么在此就把这些「东西」列举出来吧，年终总结有一份 fedi 版的还有一个针对阅读的，那么在此处我也想列举一下准备了那些「东西」。&lt;/p&gt;&lt;h3 id=&quot;SteamDeck&quot;&gt;Steam Deck&lt;/h3&gt;&lt;p&gt;今年前半年一直没有怎么玩游戏，因为带来的 switch 的手柄有点问题，肩键有点不灵敏了（任天堂的奇妙品控）。后半年就想找个设备玩一下游戏就产生了想买个 Steam Deck 的念头，刚好那段时间 fedi 上看到了转手的消息就这么巧合的入手了。&lt;/p&gt;&lt;p&gt;Steam Deck 的性能虽然不太行只能达到勉强运行近年 3A 低画质的水平，但对于我倾向的独立游戏类别反而刚刚好甚至有点牛刀了。虽然在入手后游戏时间依然只有每周五六个小时的程度，但是花在买游戏的钱反而比之前更多了一些，原因我想在于随时能打开就意味随时能看到商店页面，这可不妙。&lt;/p&gt;&lt;h3 id=&quot;LogitechK380蓝牙键盘&quot;&gt;Logitech K380 蓝牙键盘&lt;/h3&gt;&lt;p&gt;那时刚好入手了 Steam Deck 要去折腾背后搭载的 Steam OS （BTW, Steam OS based on Arch） 系统还有那时还在折腾安卓 Emacs ，所以就入手了这个小巧的蓝牙键盘，但后来这两者都通过了 SSH 在电脑上去折腾，所以……吃灰了。&lt;/p&gt;&lt;h3 id=&quot;绿联懒得翻看牌子的便宜无线鼠标&quot;&gt;绿联懒得翻看牌子的便宜无线鼠标&lt;/h3&gt;&lt;p&gt;同样是为了操作 Steam Deck 而入手的，好像是为了玩 MC ，但自从自己折腾除了一个控制器布局后就没怎么打开过了，所以……吃灰了。&lt;/p&gt;&lt;h3 id=&quot;华硕灵耀14笔电&quot;&gt;华硕灵耀14 笔电&lt;/h3&gt;&lt;p&gt;其实严格来说已经是 25 年了，不过是农历年前买的也算是 24 年吧。原因也是因为一直在用的小破 Surface 只有 4G 内存，不管再怎么优化减少占用也都难以应付当前的浏览器了，所以就产生了更新设备的念头，那么为什么选这款是那时的笔吧评测刚好出了它的评测所以就选了 &lt;a href=&quot;https://www.bilibili.com/video/BV1brcieyEos/&quot;&gt;性能续航两手抓，Ultra 9 285H，灵耀14 2025评测| 笔吧评测室 | Bilibili&lt;/a&gt; ，诶，可能我真就是一个这么随意的人吧。&lt;/p&gt;&lt;p&gt;入手之后感想就是 32G 内存是真有着明显提升：浏览器终于不怎么卡了，后台的 Emacs 从蜗居房住进了大豪斯能多舒展筋骨了。不过人啊终究是一种善于「适应」的动物，哪怕升职加薪、住进大豪斯，幸福曲线在升高一阵之后不出半年又会回到平常。不过我也在想我意识到这点能不能延长这个曲线呢？甚至提升前半段的曲线，这也是我今年在思考的「元认识」。&lt;/p&gt;&lt;h3 id=&quot;盖世小鸡超新星手柄&quot;&gt;盖世小鸡超新星手柄&lt;/h3&gt;&lt;p&gt;因为 Switch 稀烂的手柄所以在入手了这款，选择这款的理由就是支持 Switch 同时 ABXY 的键帽可更换能让我不用额外承受 XBOX 系列布局的认知负担，同时也能运用于 Steam Deck ，不过鉴于我不是一个手柄玩家（虽然现在玩游戏全用手柄），所以在这些控制器上也就没什么太多感想了，就凑合用吧。&lt;/p&gt;&lt;h3 id=&quot;TOM星空飞鸟23寸尤克里里&quot;&gt;TOM 星空飞鸟 23 寸尤克里里&lt;/h3&gt;&lt;p&gt;在年中下单然后在春节假期才收到的，当然也算是 24 年的啦，其实也是因为一直在听歌，所以也产生了参与进去的念头，为什么选尤克里里可能就像为什么不买个台式或游戏本而买 Steam Deck 一样吧，中意小巧点的。&lt;/p&gt;&lt;p&gt;目标是在 25 年能弹出个 D 大调卡农，练乐器总是枯燥的，但是在进步也是实打实能感受到的，在「好难，这人类怎么可能做到」的怀疑到一步步凹出来慢慢接近的时候就不得感觉人类大脑的神奇，对于学习能力是否意识才是一个附属品？&lt;/p&gt;&lt;h3 id=&quot;Guix&amp;amp;Nix&amp;amp;开发游戏&quot;&gt;Guix &amp;amp; Nix &amp;amp; 开发游戏&lt;/h3&gt;&lt;p&gt;软件总归要存在实体上的所以我也把他分为「形而下」的吧，其实在前半年因为参加了春季 Lisp game jam 用 &lt;a href=&quot;https://spritely.institute/hoot/&quot;&gt;Hoot&lt;/a&gt; 时就安上了 Guix ，但深入研究的契机也是 Steam Deck ，因为其设置成不可变系统要折腾其它应用就折腾 Nix ，而鼓捣了 Nix 后就对 Guix 产生了兴趣，所以就深入的折腾了下去。现在正在把常用软件的设置慢慢移到 Guix Home 里。&lt;/p&gt;&lt;p&gt;今年也参加了两场的 Lisp Game Jam ，参加了春秋两个活动参加了做了奇奇怪怪的两个原型游戏（&lt;a href=&quot;https://southfox.itch.io/parentheses-is-you&quot;&gt;Parenthesis is you by SouthFox for Spring Lisp Game Jam 2024 - itch.io&lt;/a&gt; , [&lt;a href=&quot;https://southfox.itch.io/little-fram&quot;&gt;little farm by SouthFox for Autumn Lisp Game Jam 2024 - itch.io&lt;/a&gt;]），也是因为玩多了游戏所以产生了想参与进去的念头。不过那怕是简单的网页也因为小破 Surface 的性能而有点折磨（但其实都是借口，为什么折磨还是因为骨子里仍是一个死线战士），今年更新了设备能解锁更多的可能希望能探索下不同的场景吧。&lt;/p&gt;&lt;h3 id=&quot;各种订阅&quot;&gt;各种订阅&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;多领国：后半年靠着它在学德语，虽然多领国只能作为语言学习的辅助手段要正经学习得搞「学术派」看书之类的，但是可能最大的优点就是给了一种在学了的错觉吧。&lt;/li&gt;&lt;li&gt;Imprint: 一个用各种小动画刷文章和知识的应用，对于「幸福科学」和「西哲入门」我就是从这里「刷」的，视觉化学习对我来说确实是有点用的，但可能真不值 100 刀吧，今年的续费我持保留意见，或许也是我每天的就刷一篇文章还是有点少了，至少要看回本吧。&lt;/li&gt;&lt;li&gt;curiosity stream: 纪录片界的奈飞，某次搞活动时开的会员，至少要看回本吧，今年的续费我持保留意见……&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;形而上&quot;&gt;形而上&lt;/h2&gt;&lt;h3 id=&quot;老庄&quot;&gt;老庄&lt;/h3&gt;&lt;p&gt;今年看了一些讲庄子的书，但只是一个浏览，没有什么深入。不过我也在思考我为什么没有像庄子那样对世界的那种「绝望」感呢？难道是我身上的「科学趣味」会对这个宇宙和自上而下的宇宙学感到激动而憧憬？&lt;/p&gt;&lt;h3 id=&quot;展望&quot;&gt;展望&lt;/h3&gt;&lt;p&gt;在对于「适应」这个过程感想就是想为「适应」这个过程而去「建造」（这可能是我 25 年的关键词），有点像是 Lisp 的 Eval 和 Apply 的互相影响抑或是埃舍尔的画作《画手》。「建造」好了去「适应」，而「适应」中又提出了新的「建造」需求。对于赛博上的「建造」我想多多钻研下 Guix 然后建设好自托管服务和 dotfiles 管理；而对于思想上，最大的不同就是思想允许空中楼阁的存在，住在空中楼阁也不影响打打地基，所以今年我想多扎实的学一些地基东西例如系统学习和应用 Lisp 还有……数学。&lt;/p&gt;&lt;p&gt;今年有些时间确实闲了点，很多天多都躺在床上什么也不想干，不过我也不想将其叫成懒散，毕竟对于自然界很多生命来说，吃饱喝足了很多时间就是干待着，不会考虑八小时以后的事，可能只有人才会觉其后的每个小时、每天、每月、每年都是关键吧。不过对于之前的行为例如做饭、烘焙或者新的兴趣多一点投入也是今年要考虑的事了，有一些东西搁置了半年但也不意味着是放弃，只是我的任务时间片轮转太久了点罢了。哈雷彗星每隔七十五年也才能看到一次也不妨叫其为彗星，人的坚持又怎么不能算是呢？&lt;/p&gt;</content></entry><entry><title>Emacs 使用再记（4）- EMACS EVERYWHERE!</title><id>https://blog.southfox.me/2024/12/emacs-everywhere/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2024-12-31T14:30:00Z</updated><link href="https://blog.southfox.me/2024/12/emacs-everywhere/.html" rel="alternate" /><content type="html">&lt;p&gt;离开 Emacs ，怎么可能？&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;p&gt;在移动端使用 emacs 是有能见到的好处的，例如随时随地开记一点笔记或者处理一些脚本，而且随着原生安卓移植版的推出，在安卓 emacs 里查看多媒体也成了可能的事……不过这里面需要折腾的量嘛……&lt;/p&gt;&lt;h2 id=&quot;Syncthing&quot;&gt;Syncthing&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;&lt;p&gt;在折腾了众多方案后，最终还是选择了 Syncthing 来作为同步方案，因为它是以文件的形式存在本地，同步只是修改，如果走一众网络协议在 org-roam 这种需要不断监听文件修改的应用场景会让延迟变得难以忍受。&lt;/p&gt;&lt;p&gt;Arch 系统的话简单使用 &lt;code&gt;sudo pacman -S syncthing&lt;/code&gt; 即可，如果是用 Debian 系的话，首先要换成官方源确保安装最新版本：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;curl -s https://syncthing.net/release-key.txt | sudo apt-key add -
echo &amp;quot;deb https://apt.syncthing.net/ syncthing release&amp;quot; | sudo tee /etc/apt/sources.list.d/syncthing.list
sudo apt update
sudo apt install syncthing&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装完成后使用&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo systemctl enable syncthing@$USER
sudo systemctl start syncthing@$USER&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令将软件设成开机启动。&lt;/p&gt;&lt;p&gt;安卓端 Syncthing 同步使用 Syncthing-fork ，因为里面由针对移动端的优化，如果使用 Syncthing 安卓端很容易收到系统的后台管理限制导致软件冻住然后半天无法进行同步，而 Syncthing-fork 有始终同步和间隔同步的设置能应付后台管理限制严格的系统。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://f-droid.org/packages/com.github.catfriend1.syncthingandroid/&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Catfriend1/syncthing-android-fdroid&quot;&gt;F-droid&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;概览&quot;&gt;概览&lt;/h3&gt;&lt;p&gt;Syncthing 会将联结起来的节点称为集群，然后通过「文件夹 ID」来标识集群内需要同步的内容，所以要保证集群内的共享「文件夹 ID」不能冲突，这点设计上就跟 Resilio Sync 这种面向公网的软件不太一样。&lt;/p&gt;&lt;h3 id=&quot;WEBUI配置&quot;&gt;WEBUI 配置&lt;/h3&gt;&lt;p&gt;启动后在本机前往 &lt;code&gt;http://127.0.0.1:8384&lt;/code&gt; 地址即可使用内置的 Web 界面进行配置，添加和配置共享文件夹都可以这么做，如果是在服务器上可以使用 SSH 端口转发将服务器的 127.0.0.1:8384 转发到本地进行操作。&lt;/p&gt;&lt;h3 id=&quot;命令行配置&quot;&gt;命令行配置&lt;/h3&gt;&lt;p&gt;以两台设备：设备A 设备B 为例子：&lt;/p&gt;&lt;p&gt;使用 &lt;code&gt;syncthing cli show system | grep .myID&lt;/code&gt; 命令即可显示本服务上的 ID 。然后使用 &lt;code&gt;syncthing cli config devices add --device-id $设备B ID&lt;/code&gt; 即可将相关设备添加到名单中。之后使用（假设需要共享的「文件夹 ID」为 org）：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;mkdir -p ~/Sync/org
syncthing cli config folders add --id org --label org --path ~/Sync/org&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即可添加一个共享文件夹，其中 id 在各个链接的设备是唯一标识的， label 为说明性内容可随便定义， path 为共享文件夹放置的路径（务必要指定否则默认指定成配置成 home 目录会造成不必要的麻烦）。&lt;/p&gt;&lt;p&gt;设定好后，可使用：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;syncthing cli config folders org devices add --device-id $添加设备ID&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令将设备添加到共享设备中，设备 B 做一次相同的操作但将设备 ID 换成对方就行了：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;syncthing cli config devices add --device-id $设备A ID
mkdir -p ~/Sync/org
syncthing cli config folders add --id org --label org --path ~/Sync/org
syncthing cli config folders org devices add --device-id $设备A ID&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;移动端Org-mode&quot;&gt;移动端 Org-mode&lt;/h2&gt;&lt;p&gt;Org-mode 很强大，但很多功能都得依托于 Emacs 环境，而且对于 GTD 功能上的提醒和展示功能，安卓 Emacs 也很难做到，索性 Org-mode 只是些纯文件，所以可以通过安卓上 Orgzly Revived 这个 App 来解析文件并调用安卓系统来补足这方面的不足（闹钟、通知提醒；桌面小组件展示待办）。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/orgzly-revived/orgzly-android-revived&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://f-droid.org/packages/com.orgzlyrevived/&quot;&gt;F-droid&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在设置了 Syncthing 同步后，移动端就有同步过后的 Org 文件了，然后可在「设置-&amp;gt;同步-&amp;gt;存储库-&amp;gt;右上角加号-&amp;gt;目录」添加一个本地目录（会解析目录下所有的 org 文件所以建议将相关 GTD 文件放到单独的目录里）。然后在「设置-&amp;gt;同步设置」将相关的自动同步开上，因为 Orgzly Revived 设计上也是将数据记录在自己应用的数据库里，不会立马回刷到文件中。&lt;/p&gt;&lt;h2 id=&quot;Emacs&quot;&gt;Emacs&lt;/h2&gt;&lt;p&gt;Emacs 原生安卓版项目主页在（建议读读主页的描述文件的 FAQ）：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://sourceforge.net/projects/android-ports-for-gnu-emacs/files/&quot;&gt;Android ports for GNU Emacs - Browse Files at SourceForge.net&lt;/a&gt;&lt;/p&gt;&lt;p&gt;上，里面包含了具有相同签名的 Termux 安装包（在项目主页 Termux 目录下），这样 Emacs 即可访问相同 ID Termux 里 pkg install 安装的应用，不过因为签名问题需要卸载掉原先的 Termux，所以之前有安装过 Termux 的话需要做好数据备份然后卸载装上项目里的 Termux 。&lt;/p&gt;&lt;p&gt;安装 emacs 好后就可启动了，当然再次之前需要给 emacs 赋予访问全部文件的权限，在较高版本安卓，文件权限可以分目录级粒度赋予，所以需要「全部文件访问权限」。如果能在系统的设置菜单找到相应配置就直接赋予 emacs, 如果不行，可以打开 emacs 后在主页菜单栏 Edit-&amp;gt;Execute Command 里（相当于 M-x ，是的，在安卓上还是得尽量依赖菜单栏）然后输入 &lt;code&gt;android-request-storage-access&lt;/code&gt; 申请获取「全部文件访问权限」。&lt;/p&gt;&lt;p&gt;然后接下来就是激动的配置时间了，可以在 termux 里安装一个 vim 然后编辑 &lt;code&gt;/data/data/org.gnu.emacs/files/.emacs.d/init.el&lt;/code&gt;（这何尝不是一种……）或者在 emacs 里直接打开编辑 &lt;code&gt;.emacs/.emacs.d/&lt;/code&gt; 里的文件。&lt;/p&gt;&lt;p&gt;我现在的配置文件如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-elisp&quot;&gt;;; BASIC SETUP:
;; package setup - bootstrap the package system
(require 'package)
(setq package-enable-at-startup nil)
(setq gnutls-algorithm-priority &amp;quot;NORMAL:-VERS-TLS1.3&amp;quot;)
(setq package-archives
        '((&amp;quot;GNU ELPA&amp;quot;     . &amp;quot;https://elpa.gnu.org/packages/&amp;quot;)
        (&amp;quot;MELPA Stable&amp;quot; . &amp;quot;https://stable.melpa.org/packages/&amp;quot;)
        (&amp;quot;MELPA&amp;quot;        . &amp;quot;https://melpa.org/packages/&amp;quot;))
        package-archive-priorities
        '((&amp;quot;MELPA&amp;quot;        . 15)
        (&amp;quot;MELPA Stable&amp;quot; . 10)
        (&amp;quot;GNU ELPA&amp;quot;     . 5)))

(package-initialize)
(setq use-package-always-ensure t)
(unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
(eval-when-compile
    (require 'use-package)
    (require 'org-capture))

;; custom
;; 防止主题信任等变量弄乱 init.el 文件
(setq custom-file (concat user-emacs-directory &amp;quot;custom.el&amp;quot;))
(when (file-exists-p custom-file)
    (load custom-file))

;; ORG
(use-package org
    :ensure t
    :init
    (setq org-src-fontify-natively t)
    :config
    (setq word-wrap-by-category t)
    (add-hook 'org-mode-hook 'visual-line-mode)
    (setq org-ellipsis &amp;quot;⇣&amp;quot;))

(use-package org-roam
    :ensure t
    :custom
    (org-roam-directory (file-truename &amp;quot;/storage/emulated/0/Sync/org/Note/org-roam&amp;quot;))
    :bind ((&amp;quot;C-c n r r&amp;quot; . org-roam-buffer-toggle)
            (&amp;quot;C-c n r f&amp;quot; . org-roam-node-find)
            (&amp;quot;C-c n r i&amp;quot; . org-roam-node-insert)
            (&amp;quot;C-c n r n&amp;quot; . org-roam-capture)
            ;; Dailies
            (&amp;quot;C-c n r d t&amp;quot; . org-roam-dailies-goto-today)
            (&amp;quot;C-c n r d T&amp;quot; . org-roam-dailies-capture-today)))

;; ui
(use-package vertico
    :ensure t
    :config
    (vertico-mode))

(use-package orderless
    :ensure t
    :init
    (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles partial-completion)))))

;; 使用工具栏来做一些特定操作
(defun android-toggle-keyboard ()
    (interactive)
    (if touch-screen-display-keyboard
        (progn
        (setq touch-screen-display-keyboard nil)
        (tool-bar-add-item
            &amp;quot;disconnect&amp;quot; 'android-toggle-keyboard
            'android-toggle-keyboard
            :help &amp;quot;Toggle keyboard&amp;quot;)
        (message &amp;quot;Disable virtual keyboard&amp;quot;))
    (setq touch-screen-display-keyboard t)
    (tool-bar-add-item
        &amp;quot;connect&amp;quot; 'android-toggle-keyboard
        'android-toggle-keyboard
        :help &amp;quot;Toggle keyboard&amp;quot;)
    (message &amp;quot;Enable virtual keyboard&amp;quot;)))

(defun android-tool-bar-configs ()
    (when (and (fboundp 'tool-bar-mode)
                (string-equal system-type &amp;quot;android&amp;quot;))
    (tool-bar-mode +1)
    (setq tool-bar-position 'bottom)
    (setq tool-bar-button-margin 27)
    (setq tool-bar-map '(keymap nil))
    (android-general-tool-bar 'tool-bar-add-item nil)))

(defun android-general-tool-bar (fun map)
    (mapc (lambda (args)
            (apply fun args))
            `((&amp;quot;left-arrow&amp;quot; tool-bar-item-left arrow-left ,map)
            (&amp;quot;right-arrow&amp;quot; tool-bar-item-tab arrow-right ,map)
            (&amp;quot;info&amp;quot; org-roam-dailies-capture-today org-roam-dailies-capture-today ,map)
            (&amp;quot;jump-to&amp;quot; org-roam-dailies-goto-today org-roam-dailies-goto-today ,map)
            (&amp;quot;up-arrow&amp;quot; delete-other-windows delete-other-windows ,map)

            (&amp;quot;connect&amp;quot; android-toggle-keyboard android-toggle-keyboard ,map)
    )))
(define-key key-translation-map (kbd &amp;quot;&amp;lt;XF86Back&amp;gt;&amp;quot;) (kbd &amp;quot;C-g&amp;quot;))
(define-key key-translation-map (kbd &amp;quot;&amp;lt;volume-up&amp;gt;&amp;quot;) (kbd &amp;quot;C-c&amp;quot;))
(define-key key-translation-map [tool-bar arrow-left] (kbd &amp;quot;M-x&amp;quot;))
(define-key key-translation-map [tool-bar arrow-right] (kbd &amp;quot;TAB&amp;quot;))

;; 在 org-capture 时动态改变工具栏的选项
(defvar capture-tool-bar-map
    (let ((map (make-sparse-keymap)))
    (tool-bar-local-item &amp;quot;checked&amp;quot; #'org-capture-finalize 'capture-finalize map)
    (tool-bar-local-item &amp;quot;close&amp;quot; #'org-capture-kill 'capture-kill map)
    map))
(defun set-capture-tool-bar ()
    (setq-local tool-bar-map capture-tool-bar-map))
(add-hook 'org-capture-mode-hook #'set-capture-tool-bar)

(android-tool-bar-configs)

;; 为安卓开启像素滚动
(setq touch-screen-enable-hscroll nil)
(setq touch-screen-precision-scroll t)

;; theme
(use-package ef-themes
    :ensure t)
(load-theme 'ef-winter)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;改得地方并不多，主要还是一些修改源添加一些常用包（vertico + orderlessv 真是谁用谁知道！）和用工具栏进行一些操作。说来也是感叹，在 PC 上大家都不怎么开的工具栏和菜单栏，在安卓这种很难接入键盘输入的场景下反而是重度依赖了起来。&lt;/p&gt;&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://gist.github.com/Jonny-exe/9bad76c3adc6e916434005755ea70389&quot;&gt;syncthing setup exclusively with CLI · GitHub&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://computingforgeeks.com/how-to-install-and-use-syncthing-on-ubuntu/&quot;&gt;Install and Use Syncthing on Ubuntu 22.04|20.04|18.04 | ComputingForGeeks&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://yuchen-lea.github.io/2024-02-04-android-emacs-with-doom-emacs/&quot;&gt;在 Android Emacs 中使用 doom-emacs | 跬步&lt;/a&gt; （是的，当然也可以在安卓上装 doom emacs 但不是很推荐，因为 doom emacs 大量使用调用子进程进行安装而安卓系统不是很支持这种「玩法」导致安装在网络流畅的情况下也可能耗时半小时之多，而且相关键位在没有键盘输入情况下也难以分配）&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://emacs-china.org/t/native-emacs-termux-emacs-emacs-everywhere/27135/23?u=southfox&quot;&gt;用安卓native emacs+termux emacs，抛砖引玉说一下我体验emacs everywhere的个人指南 - #23，来自 DR MING&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry><entry><title>2023 年终总结</title><id>https://blog.southfox.me/2023/12/2023年终总结/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2023-12-31T21:32:00Z</updated><link href="https://blog.southfox.me/2023/12/2023年终总结/.html" rel="alternate" /><content type="html">&lt;p&gt;什么，已经要 2024 年了？！&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;h2 id=&quot;幸运&quot;&gt;幸运&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;And even when I might fall down,&lt;/p&gt;&lt;p&gt;I know my luck come back around.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;今年如果如果要选出一个关键词的话，那么就是「幸运」吧，每次找工都是海投简历快要绝望的时候「刚好」被「捞」到了。首先是三月份的实习，距离家的位置还算不远。作为一家还算大型的企业做事十分垂直，做的事多都是一些填表单之事，基本上很容易被替代。也「幸好」我有 &lt;code&gt;Emacs&lt;/code&gt; ，在一大堆服务器上翻找工程文件里 blame 是谁提交的代码，在一大堆编译产物翻找定位时真得救了我的命。&lt;/p&gt;&lt;p&gt;这段时间就像是静止了一样：每天被闹钟逼迫着起床；然后走到附近的公交站（甚至因为这样和公交车司机混了个脸熟）；半小时后下公交，然后走向大厦；等电梯（有时人太多也会选走楼梯）；到工位打开电脑；工；下班后在等公交；座半小时公交； 车站下车然后回家。在一座小城找到一份对于当地人耳熟能详企业的工作，如果能一直这样下去也还算是不错吧。但因为 2023 年寒冬实在太冷，冷意已经让大多数企业都得凝住呼吸，生怕机体的热量散失。所以自然是没有什么位置留给新来者的，甚至同组的一位实习快一年的小哥都没有转正的机会，所以当时间一到，我就只好潇洒走人了。&lt;/p&gt;&lt;p&gt;然后七月到十月就待在家里，算是一个小小的 gap time 吧，可能这个情况会一直持续到明年，真是这样的话本篇博文可能就没有那么多内容，写到这里就应该写点什么明年展望就结笔了，但生活总是像个迷，并没有给我这种发展。&lt;/p&gt;&lt;p&gt;十一月还是打算「出洞」，打算呼吸点新鲜空气。但是就业市场寒冬更甚，简历比起三月份更加沉底（哪怕开启广域模式），而且临近年关，也没有什么公司打算在这时候招人，正当我已经打算放弃「回洞」时，没想到就正好 HIT 到一家了。一家「幸运」的在今年拉到投资逆流而上就正好在这时招兵买马的公司，刚好也觉得我「折腾」的一大堆东西也「不容易」所以就这么对上了。一切都是那么恰好，但就是工作地点离家超过两千公里，虽然地点当初是在招聘软件自己选的，真发生时却还是有点恍惚。就算临行前故作坚定但潜意识下估计也是一大堆思绪组成的乱麻吧，头次座飞机、一落地就要开始找中介寻找房子、在名宿和租房地点两头跑搬运整理东西、甚至为了一台炸了的服务器就这么修到凌晨三点，不敢相信报到当天我的黑眼圈该重到什么地步。不过如今我喝着热茶写出这些事也就代表一切都已落定。&lt;/p&gt;&lt;h2 id=&quot;坚定&quot;&gt;坚定&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;好像大自然只支持一种理解能力，养活了四足动物就养不活禽鸟，养活了会爬的东西就养不活会飞的东西&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;可能还有一件拖了很久的事「有幸」在三个月的 gap time  里想好了，那就是「坚定的自我认同」，虽然说之前的人生里一直知道这件事但是却一直没有调度它导致这个任务一直在挂起，不知道是真觉得还早还是因为一直被压抑了呢？&lt;/p&gt;&lt;p&gt;我作为在这跟熵的「无情之手」永恒对抗下的一个生命，从海底的那隆起的石塔中「逃脱」而出，花了几十亿年将自己的足迹散步到这个星球并永远地改变了这里且绝不停歇嗡嗡震动的玩意，到底意味着什么呢？或者「在十个当中只得一个」意味着什么呢？我想生命「幸好」不总是一样，允诺了在每次分裂复制时不同的空间，造就了生命的可塑性，或许就连作为其象征——链条底层结构都「改朝换代」了几次。&lt;/p&gt;&lt;h2 id=&quot;展望&quot;&gt;展望&lt;/h2&gt;&lt;p&gt;作为「幸运」的一年，在年末找到了一份「幸运」的工作，也有时间一直做了之前一直想做的事，比如烘焙之类的，也体会到了「面多加水， 水多加面」是一件多窘迫的事。明年也没有什么特别的展望了，毕竟今年的多数事已经开始将我水豚化了，一些事情看起来很大很可怕但最后压到头上可能只是一个「橘子」，完全没有必要去付出超出的担忧。希望我明年能像我以为的这么处事不惊下去吧，不论是工作上的事、自己一个人潇洒待着抑或是打算走进一段亲密关系、不论「幸运」还是「没那么幸运」。&lt;/p&gt;</content></entry><entry><title>如何杀死一个去中心化网络？</title><id>https://blog.southfox.me/2023/06/如何杀死一个去中心化网络？/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2023-06-24T14:03:00Z</updated><link href="https://blog.southfox.me/2023/06/如何杀死一个去中心化网络？/.html" rel="alternate" /><content type="html">&lt;p&gt;例如联邦宇宙（&lt;code&gt;Fediverse&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreiht6bsh4u5ncv3ezxbkvyinkbhqxh6sjxfnsz2vw6lifnsa3jzllq&quot; alt=&quot;头图&quot; /&gt;&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;blockquote&gt;&lt;p&gt;这篇文章是一篇翻译，原文为 &lt;a href=&quot;https://ploum.net/2023-06-23-how-to-kill-decentralised-networks.html&quot;&gt;How to Kill a Decentralised Network (such as the Fediverse)&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;现在是 2023 年。整个互联网都在科技巨头的帝国掌握下吗？不，因为有一些小村落还在反抗这种趋势，其中一些村落开始聚集，形成「联邦宇宙」。&lt;/p&gt;&lt;p&gt;随着 Twitter 和 Reddit 上的发生的争论，联邦宇宙开始获得名气和注意，一些人开始在日常生活中使用。帝国开始注意到了。&lt;/p&gt;&lt;h2 id=&quot;资本家反对竞争&quot;&gt;资本家反对竞争&lt;/h2&gt;&lt;p&gt;正如 Fecebook 著名投资人 Peter Thiel 所说：“竞争是对于失败者说的”。是的，对于那些总将「市场总是对的」挂在嘴边的人来说，身处市场中却并不想要市场，他们想要垄断。自成立以来， Facebook 一直非常小心地消灭竞争对手。最简单的办法就是收购每一个可能成为竞争对手的公司。例如 Instagram、WhatsApp 被收购只是因为产品吸引了用户的注意并有可能为 Fecebook 蒙上阴影。&lt;/p&gt;&lt;p&gt;但联邦宇宙是买不到的。联邦宇宙是一个不同服务器通过协议（ActivityPub） 进行连接的非正式组织（informal group）。这些服务器甚至运行着不同的软件（Mastodon 是最著名的一个，但你也可以运行 Pleroma、Pixelfed、Peertube、WriteFreely、Lemmy 等）。&lt;/p&gt;&lt;p&gt;你无法买下一个去中心化网络！&lt;/p&gt;&lt;p&gt;但还有另外一种办法：让它变得无关紧要。这正是谷歌对 XMPP 所做的事。&lt;/p&gt;&lt;h2 id=&quot;谷歌如何加入XMPP联盟&quot;&gt;谷歌如何加入 XMPP 联盟&lt;/h2&gt;&lt;p&gt;20 世纪末，即时通讯工具风头无限。第一个获得巨大成功的应用是 ICQ，随后是 MSN 。 MSN 就类似于今天的 Tiktok ：青少年可以在没有大人陪伴下在这个世界里度过数小时或数天的时间。&lt;/p&gt;&lt;p&gt;因为 MSN 是微软的一部分，谷歌希望与其竞争，并于 2005 年发布了 Google Talk，并将其界面整合在 Gmail 里。请记住在那时还没有智能手机或是小体积的网页应用。应用程序必须安装在计算机上，所以 Gmail 的网页交互是开创性的。MSN 甚至在某个时间是和操作系统捆绑在一起的，很难将其卸载。与内置在操作系统的预装应用相比，在 Gmail 用网页进行构建的聊天是一种更贴近用户的方式。&lt;/p&gt;&lt;p&gt;在谷歌和微软开始争夺霸权地位时，自由极客们开始尝试构建去中心化的即时通信。就像电子邮件一样，XMPP 是一种联邦协议：多个服务器之间可以通过协议互相通信，每个用户可以使用任意客户端与任意服务器上的任意用户进行通信。ActivityPub 和联邦宇宙也是这样运作的。&lt;/p&gt;&lt;p&gt;2006 年，Google Talk 开始实现 XMPP 兼容,谷歌正在认真考虑 XMPP 协议。2008 年，当我正在工作时，我的手机响了。在电话里，有人告诉我：“嗨，我是谷歌，我们想雇佣你。”我们打了几个电话，他们是通过 XMPP 的开发者列表找到了我，并表示正在寻找 XMPP 服务器管理员。&lt;/p&gt;&lt;p&gt;所以谷歌确实在加入联盟，这有多酷？这意味着每个 Gmail 用户都可以变成 XMPP 用户。这只会对 XMPP 有好处，是吗？我高兴坏了。&lt;/p&gt;&lt;h2 id=&quot;谷歌如何杀死XMPP&quot;&gt;谷歌如何杀死 XMPP&lt;/h2&gt;&lt;p&gt;当然现实没有那么美好。首先，尽管制定了 XMPP 标准，谷歌仍然在实行着自己没有任何人审查的封闭实现。事实证明，他们并不总是尊重他们正在制定的协议。他们并没有完全实现所有标准，这迫使 XMPP 的降低速度以便适应。好的功能没有在 XMPP 客户端中实现或使用，因为它们与 Google Talk 不兼容（头像功能都花了非常久时间才在 XMPP 里实装）。联邦还总会被破坏：有时是几小时或数天，谷歌服务器和常规 XMPP 服务器之间无法进行通信。XMPP 社区成为了谷歌服务器的监管员和除错员，发布违规和停机信息（我做了好几次这种事，可能这就是为什么有这份工作的原因吧）。&lt;/p&gt;&lt;p&gt;而且由于 Google Talk 用户远多于「真正的 XMPP」用户，因此「不关心 Google Talk 用户」的情况并不多。新人发现 XMPP 并不是 Google Talk 用户的经历让人非常沮丧，因为他们接触的大多数都是 Google Talk 用户。他们认为他们可以轻易的与 Google Talk 用户沟通，但这相当于他们在用 Google Talk 的基本版或是降级版本。典型的 XMPP 名单主要由 Google Talk 用户和一些极客组成。&lt;/p&gt;&lt;p&gt;在 2013 年，谷歌意识到大多数 XMPP 交互都是在 Google Talk 用户之间进行的。他们并不关心遵守没有百分之百掌握在他们手里的协议，所以他们中止了合作并宣布不进行结盟。并开始踏上一条即时通讯软件的漫长探索，从 Hangout 开始（随后是 Allo、Duo ，之后我就记不清了）。&lt;/p&gt;&lt;p&gt;正如预料一样，谷歌用户没有太多感受，事实上，他们什么也没意识到。最坏的情况是他们的一些联系人离线了，就这样。但对于 XMPP 联邦来说，相当于绝大多数用户凭空蒸发了一样。即使是最狂热的 XMPP 拥趸，也要创建一个谷歌帐号和朋友保持联系。请记住：对于他们来说，我们就是单纯离线了，这是我们的错。&lt;/p&gt;&lt;p&gt;虽然 XMPP 仍然是一个存在并且活跃的社区，但它未从这次打击中恢复过来。对谷歌投入了过高的期待导致了巨大的失望然后就这么被遗忘了。XMPP 变得小众，以至于群聊应用开始流行时（Slack、Discord），自由软件社区重新造了一个协议（Matrix）与之竞争，但群聊已经可以通过 XMPP 实现了。（免责声明：我没有研究过 Matrix 协议，所以我不知道在技术层面上与 XMPP 相比如何。我只确信它解决了类似的问题并与 XMPP 在相同的空间上竞争。）&lt;/p&gt;&lt;p&gt;（译按： Matrix 和 XMPP 对比在 Matrix 官网 FAQ 上就有回答（虽然被标注为过时了）：&lt;a href=&quot;https://matrix.org/docs/legacy/faq/&quot;&gt;What is the difference between Matrix and XMPP? - FAQ&lt;/a&gt;）&lt;/p&gt;&lt;p&gt;如果谷歌未加入 XMPP 或从未被视为其中的一部分，今天的 XMPP 会有所不同吗？没有人知道。但我相信它会成长的更慢，可能，更健康。它将比今天更大、更重要，它将成为默认的去中心化通讯平台。但有一点是肯定的：如果谷歌没有加入，XMPP 不会比现在更糟糕。&lt;/p&gt;&lt;h2 id=&quot;并不是首例：微软的心机&quot;&gt;并不是首例：微软的心机&lt;/h2&gt;&lt;p&gt;谷歌对 XMPP 做的事并不新鲜。事实上，在 1998 年，微软的工程师 Vinod Vallopllil 就明确写下了一篇「削弱 OSS （译按：开源软件）攻击」的文章，其中他建议「去商品化协议和应用程序……]通过拓展这些协议或是开发新协议，我们可以拒绝 OSS 项目进入市场。&lt;/p&gt;&lt;p&gt;随着 Windows 2000 的发布，微软将这理论付诸实践，Windows 2000 提供了对 Kerberos 安全协议的支持。但该协议得到了拓展。这些拓展规范可以免费下载，但必须要接受禁止实现这些拓展的许可证。一旦点击「确定」，你就无法使用 Kerberos 的任何开源版本。这么做的目标就是消灭任何与之竞争的网络项目例如 Samba 。&lt;/p&gt;&lt;p&gt;Glyn Moody 在他的著作《Rebel Code》中讲述了这一传闻，并表明扼杀开源和去中心化项目是确有预谋的目标。它从来不是随机发生的，也不是由什么坏运气导致的。&lt;/p&gt;&lt;p&gt;微软还采用了类似的策略，通过专有格式（文件格式可以被视为交换数据的协议）的 Microsoft Office 来确保在办公市场的主导地位。当替代方案（OpenOffice 然后是 LibreOffice）在处理  doc/xls/ppt 格式能力变得足够好时，微软发布了一种他们称之为「开放和标准化」的新格式。格式故意弄得非常复杂（20,000  页的规范！），而且最重要的是，它是错误的。是的，标准中引入了一些错误，这意味完整实现 OOXML 格式的软件的表现将与 Microsoft  Office 不同。&lt;/p&gt;&lt;p&gt;这些错误以及政治游说是促使慕尼黑市恢复 Linux 迁移的原因之一。所以是的，这个策略运作良好。因为如今 docx、xlsx 和 pptx 仍然是标准格式。来源：我就在那里，由慕尼黑市间接支付费用，使 LibreOffice OOXML 的渲染更接近 Microsoft  的渲染，而不是遵循规范。&lt;/p&gt;&lt;p&gt;后按：这种策略有一个维基百科词条：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Embrace,_extend,_and_extinguish&quot;&gt;Embrace, extend, and extinguish - wikipedia&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8B%A5%E6%8A%B1%E3%80%81%E6%89%A9%E5%B1%95%E5%86%8D%E6%B6%88%E7%81%AD&quot;&gt;拥抱、扩展再消灭 - 维基百科&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;Meta和联邦宇宙&quot;&gt;Meta 和联邦宇宙&lt;/h2&gt;&lt;p&gt;不了解历史的人终究会重蹈覆辙，这就是现在 Meta （译按：Facebook 的公司现在改名叫 Meta 了）和联邦宇宙发生的事。&lt;/p&gt;&lt;p&gt;有传言称 Meta 会实现「联邦宇宙兼容」，这意味着你可以通过 Mastodon 账户关注 Instagram 上的人。&lt;/p&gt;&lt;p&gt;我不知道这些传言是真是假，Meta 是否在考虑实现它。但我在 XMPP 和 OOXML 方面的经验告诉我一件事情，如果 Meta 加入联邦宇宙，Meta 将是唯一的胜者。事实上现在的反应已经让他们开始赢了：联邦宇宙在阻止 Meta 与不阻止 Meta 之间存在分歧。如果继续发生这种情况，这将意味着一个支离破碎令人沮丧的俩半式联邦，对新来者而言没有什么吸引力。&lt;/p&gt;&lt;p&gt;后按：这些传言得到了证实，一位来自 fosstodon.org 的 Mastodon 管理员 kev 已被邀请参加和 Meta 的非正式会议。他做出了最好的选择：他礼貌地拒绝掉了，最重要的是，公开了该电子邮件以对其用户保持透明。谢谢 kev ！&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://fosstodon.org/@kev/110592625692688836&quot;&gt;相关邮件截图和回复 - fosstodon.org&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我知道我们都梦想着让我们所有的朋友和家人进入到联邦宇宙上，这样我们就可以完全避免专有网络。但联邦宇宙并不寻求市场主导地位或是利润，联邦宇宙并不寻求增长。它提供了一个自由的场所。加入联邦宇宙的人都是那些寻求自由的人。如果人们还没有准备好或者并不追寻自由，那也没关系。他们有权留在专有平台上，我们不应该强迫他们进入联邦宇宙。我们不应该不惜一切代价试图容纳尽可能多的人。我们应该诚心诚意并确保人们加入联邦宇宙是因为他们想分享其背后的一些价值观。&lt;/p&gt;&lt;p&gt;在无脑增长、不惜一切代价的意识形态下与 Meta 竞争，我们肯定会失败。他们是这场比赛的大师，他们试图让每个人都进入他们的领域，让人们使用他们熟悉的武器与他们竞争。&lt;/p&gt;&lt;p&gt;联邦宇宙只能坚守阵地，通过谈论自由、道德、伦理和价值观来获胜。通过公开、非商业和非监听的方式讨论，承认目标不是去获胜。我们的目标是继续成为一个工具，一个致力于为互联网上的人类提供自由场所的工具。这是任何商业实体都不会提供的东西。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://framapiaf.org/@davidrevoy/110583258129951932&quot;&gt;头图 by David Revoy&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>GPG 浅尝辄止</title><id>https://blog.southfox.me/2023/06/GPG 浅尝辄止/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2023-06-23T22:27:00Z</updated><link href="https://blog.southfox.me/2023/06/GPG 浅尝辄止/.html" rel="alternate" /><content type="html">&lt;p&gt;成为 &lt;code&gt;Geek&lt;/code&gt; 众多步的其中一步，捣鼓 &lt;code&gt;GPG&lt;/code&gt; (&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;p&gt;密码学让人掉头发，但也很重要，因为它是「普通人」们在赛博空间的基石。任何对「赛博自由」有兴趣的人都应该看过 &lt;code&gt;GPG&lt;/code&gt; 之类的文章或书籍吧，相关的加密工具套件让蚂蚁也有了战胜大象的可能，所以 &lt;code&gt;Geek&lt;/code&gt; 们乐于折腾这相关方面的东西也不足为奇了。&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;话要从哪里说起呢？思来想去发现没什么想说的，毕竟对 &lt;code&gt;GPG&lt;/code&gt; 感兴趣的前置条件是对 「赛博自由」感兴趣，而「赛博自由」也是一个很难说清的东西，就像空气一样。空气当然是很重要的东西，但是去卖力「推销」空气只会让人兴趣乏乏。&lt;/p&gt;&lt;p&gt;所以我就单纯列列最影响我对「赛博自由」这一观点的来源了：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E7%8B%AC%E7%AB%8B%E5%AE%A3%E8%A8%80&quot;&gt;网络独立宣言 - 维基百科&lt;/a&gt;&lt;/p&gt;&lt;p&gt;《永久记录》 - 爱德华·斯诺登&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/philosophy/free-sw.zh-cn.html&quot;&gt;什么是自由软件？ - GNU&lt;/a&gt;&lt;/p&gt;&lt;p&gt;零零年左右的那些对互联网有着美好畅想的书籍 - 不管地摊书还是教材&lt;/p&gt;&lt;h2 id=&quot;公钥私钥&quot;&gt;公钥私钥&lt;/h2&gt;&lt;p&gt;&lt;code&gt;GPG&lt;/code&gt; 是一个加密套件，覆盖了多种加密算法和类型，但是大家一般折腾的都是「非对称加密」的公钥私钥，简单来说公钥相当于一个带锁箱子，私钥相当于对应锁的钥匙。&lt;/p&gt;&lt;p&gt;大家都会把公钥发布出来，然后需要进行加密沟通时就用公钥进行加密（相当于将信件转入箱子并锁上），这样只有持有私钥（相当于对应锁的钥匙）的人才能知道内容。&lt;/p&gt;&lt;p&gt;如果想来点小小的数学风暴可以看：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1Ts411H7u9/&quot;&gt;银行密码系统安全吗？质数（素数）到底有啥用？李永乐老师11分钟讲RSA加密算法（2018最新）&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;最小系统&quot;&gt;最小系统&lt;/h2&gt;&lt;p&gt;&lt;code&gt;GPG&lt;/code&gt; 作为密码学软件让人摸不着头脑，一大堆的相关流程让人生怵，不过从繁杂的电路中拆出一个「最小系统」还是可以的，最后系统没冒烟能用下去就没关系了……大概。&lt;/p&gt;&lt;p&gt;&lt;code&gt;GPG&lt;/code&gt; 在一众 &lt;code&gt;Linux&lt;/code&gt; 发行版中应该是预装的，所以调出个终端直接用就是了，总体来说使用 &lt;code&gt;gpg --full-gen-key&lt;/code&gt; 命令就能生成一个了:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;输入 &lt;code&gt;gpg --full-generate-key&lt;/code&gt; 开始生成密钥。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;密钥类型可以选择默认选项： 1 RSA and RSA.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;密钥长度可以使用 &lt;code&gt;4096&lt;/code&gt; 来得到强壮的密钥。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;选择失效日期，建议 &lt;code&gt;2y&lt;/code&gt; （两年）。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;按照提示继续设置个人信息，注意名称和邮件在公钥里是公开可见的，所以最好不要填入真名或是公开使用的邮箱。然后就输入一个密码，这个密码会在进行私钥操作的时候需要用到，所以尽量设计得复杂一点同时能记下来（写下来或是放到密码管理器里）。&lt;/p&gt;&lt;p&gt;生成完以后可以使用 &lt;code&gt;gpg --list-keys [生成密钥时填的邮箱地址]&lt;/code&gt; 来列出具体的信息（也可使用 &lt;code&gt;-k&lt;/code&gt; 来简写 &lt;code&gt;--list-keys&lt;/code&gt; 选项）：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# 例如 
gpg --list-keys test@outlook.com
# 可能输出以下结果
sec   rsa3072 2023-01-01 [SC]
      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
uid           [ultimate] test &amp;lt;test@test.com&amp;gt;
ssb   rsa3072 2023-1-01 [E]
ssb   rsa3072 2023-1-01 [S]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&lt;/code&gt; 的 40 位字符对应的是 &lt;code&gt;finperprint&lt;/code&gt; （密钥指纹），在认证其它人的公钥时会用到。&lt;/p&gt;&lt;h2 id=&quot;发布公钥&quot;&gt;发布公钥&lt;/h2&gt;&lt;p&gt;接下来就是将公钥发布出去了，具体来说用：&lt;/p&gt;&lt;p&gt;&lt;code&gt;gpg --export --armor [密钥指纹] &amp;gt; pub_key.gpg&lt;/code&gt;&lt;/p&gt;&lt;p&gt;就能将公钥导出为文件，其中 &lt;code&gt;--armor&lt;/code&gt; 选项是导出为人类可读形式，可用可不用。&lt;/p&gt;&lt;p&gt;得到这个公钥之后就是将它发布出去，例如将文件发在网盘上分享；或是将其内容发在共享文档上（需要使用 &lt;code&gt;--armor&lt;/code&gt; 选项）；或是发布在博客上。&lt;/p&gt;&lt;p&gt;或是使用 &lt;code&gt;gpg --send-key [密钥指纹]&lt;/code&gt; 命令将其发在公共 &lt;code&gt;keyserver&lt;/code&gt; 上，但是默认使用的公共 &lt;code&gt;keyserver&lt;/code&gt; 没有可删除性，就是说无法撤销，所以要保证生成公钥时没填入敏感信息。&lt;/p&gt;&lt;h3 id=&quot;WKD&quot;&gt;WKD&lt;/h3&gt;&lt;p&gt;当然也有一种方式是通过 &lt;code&gt;WKD (Web Key Directory)&lt;/code&gt;  方式公布自己的公钥，&lt;code&gt;WKD&lt;/code&gt; 的思想很简单，就是将邮件地址的哈希串放到规范的指定位置，在使用支持 &lt;code&gt;WKD&lt;/code&gt; 的客户端时就会默认从对应的地址导入公钥 （&lt;code&gt;GunPG 2.1.23&lt;/code&gt; 版后默认从 &lt;code&gt;WKD&lt;/code&gt; 地址导入）例如 &lt;code&gt;aheinecke@intevation.de&lt;/code&gt; 的邮箱地址就对应 &lt;code&gt;https://intevation.de/.well-known/openPGPkey/hu/g8td9rsyatrazsoiho37j9n3g5ypp34h&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;要获取 &lt;code&gt;WKD&lt;/code&gt; 哈希可以使用 &lt;code&gt;gpg -k --with-wkd-hash [生成密钥时填的邮箱地址]&lt;/code&gt; 命令：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;pub   rsa3072 2023-01-01 [SC]
      XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
uid           [ultimate] test &amp;lt;test@test.com&amp;gt;
              ****************@test.com
ssb   rsa3072 2023-1-01 [E]
ssb   rsa3072 2023-1-01 [S]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;****************&lt;/code&gt; 那串字符串对应的就是 &lt;code&gt;WKD&lt;/code&gt; 哈希。&lt;/p&gt;&lt;p&gt;之后可以使用 &lt;code&gt;gpg --export [生成密钥时填的邮箱地址] &amp;gt; [WKD 哈希]&lt;/code&gt; 导出为文件，然后放到对应的服务器上，如果使用 &lt;code&gt;Nginx&lt;/code&gt; 可以在邮箱对应的域名（如 &lt;code&gt;aheinecke@intevation.de&lt;/code&gt; 对应 &lt;code&gt;intevation.de&lt;/code&gt; 域名）配置文件下这样写：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-ng&quot;&gt;    location /.well-known/openpgpkey/hu {
        add_header Access-Control-Allow-Origin *;
        alias /var/www/html/.well-known/openpgpkey/hu;  #对应的具体路径
    }    
    location /.well-known/openpgpkey/policy { # 可能一些旧版实现会用到这个路径
        add_header Access-Control-Allow-Origin *;
        alias /var/www/html/.well-known/openpgpkey/hu;  #对应的具体路径
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后可以在其它账户或设备上使用 &lt;code&gt;gpg --locate-key [生成密钥时填的邮箱地址]&lt;/code&gt; 来测试能否导入公钥（需 &lt;code&gt;GunPG 2.1.23&lt;/code&gt; 及以后版本）。&lt;/p&gt;&lt;h2 id=&quot;验证公钥&quot;&gt;验证公钥&lt;/h2&gt;&lt;p&gt;非对称加密的一个致命处就是如何保证收到的公钥真的是所发布的人呢？所以需要进行确认，最理想的做法是将公钥拷到移动设备上然后肉身跟需要交流的人碰面然后互换公钥。当然赛博空间上很难做到这一点，所以需要设立多个源进行交叉验证，例如在网盘分享公钥出来然后在博客上公布出密钥指纹；将公钥通过邮件发送然后通过电话方式通知密钥指纹等，这样才能防止可能潜在的欺骗行为。&lt;/p&gt;&lt;p&gt;比如我通过 &lt;code&gt;WKD&lt;/code&gt; 方式发布了公钥，那么我要在博客的相关页面公布出指纹来方便他人确认。&lt;/p&gt;&lt;h2 id=&quot;以及……&quot;&gt;以及……&lt;/h2&gt;&lt;p&gt;选用一个支持这些操作的客户端，比如 &lt;code&gt;Thunderbird&lt;/code&gt; 进行加解密操作并不算太复杂，可参见自由软件基金会写的指南：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://emailselfdefense.fsf.org/zh-hans/&quot;&gt;电子邮件加密指南 - FSF&lt;/a&gt;&lt;/p&gt;&lt;p&gt;当然 &lt;code&gt;GPG&lt;/code&gt; 还有其它的用法比如签名或是文件加解密等，或是硬件设备之类的，但是这些就太掉入「兔子洞」了。&lt;/p&gt;&lt;p&gt;同时 &lt;code&gt;GPG&lt;/code&gt; 作为一个加密中的 「瑞士军刀」为了广泛用途也带来了很多其它问题，所以其实更适合作为一个「兜底方案」。平常应该使用专门针对使用场景的设计方案例如文件加密使用 &lt;a href=&quot;https://github.com/FiloSottile/age&quot;&gt;Age&lt;/a&gt; ，聊天使用 &lt;a href=&quot;https://matrix.org/&quot;&gt;Matrix&lt;/a&gt; 等。&lt;/p&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://ulyc.github.io/2021/01/13/2021%E5%B9%B4-%E7%94%A8%E6%9B%B4%E7%8E%B0%E4%BB%A3%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8PGP-%E4%B8%8A/&quot;&gt;2021年，用更现代的方法使用PGP（上）- Ulyc&lt;/a&gt;&lt;/li&gt;&lt;li&gt;[GPG 密钥轮换小记 - &lt;a href=&quot;https://idawnlight.com/&quot;&gt;余光的部落格&lt;/a&gt;](https://idawnlight.com/2022/gpg-key-rotation-notes/)&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://wiki.gnupg.org/WKD&quot;&gt;Web Key Directory (WKD) / Web Key Service (WKS) what is the difference? - gunpgp wiki&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.uriports.com/blog/setting-up-openpgp-web-key-directory/&quot;&gt;Setting up OpenPGP Web Key Directory (WKD) - uriports&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.ruanyifeng.com/blog/2013/07/gpg.html&quot;&gt;GPG入门教程 - 阮一峰的网络日志&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</content></entry><entry><title>使用 Mastodon 作为博客的评论系统</title><id>https://blog.southfox.me/2023/06/使用 Mastodon 作为博客的评论系统/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2023-06-16T11:20:00Z</updated><link href="https://blog.southfox.me/2023/06/使用 Mastodon 作为博客的评论系统/.html" rel="alternate" /><content type="html">&lt;p&gt;又在博客的评论系统上左右摇摆了，就算没有人来评论。&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;p&gt;之前写过一篇&lt;a href=&quot;https://blog.southfox.me/2022/01/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%94%AF%E6%8C%81%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/&quot;&gt;使用 Giscus 作为博客评论系统&lt;/a&gt;的文章，一年下来的使用体验感受良好，只需要经过一点点配置就能为博客嵌入一个支持 &lt;code&gt;Markdown&lt;/code&gt; 支持、代码高亮、表情回应、邮件通知、数据背靠 &lt;code&gt;GitHub&lt;/code&gt;的评论系统，性价比十分之高。但代价也是背靠 &lt;code&gt;GitHub&lt;/code&gt; ，作为一个大商业公司「发病」是一个不断扔骰子的过程，随着时间流逝，扔出个「大发病」的概率将会趋近于必然。可能是什么「大会员」或是「API 收大费」。为了避免最坏情况发生所以有必要准备一些备选方案。&lt;/p&gt;&lt;p&gt;比如 &lt;a href=&quot;https://cusdis.com/&quot;&gt;Cusdis&lt;/a&gt; 是我之前尝试过一阵的评论系统方案，虽然各方面都比较优秀，但是它上面的一些小小「毛刺」最终让我放弃继续使用（主要是一些样式问题），更大的原因也是我开始觉得为了一年不到十多条的评论是否有必要开一个数据库+评论系统。&lt;/p&gt;&lt;p&gt;所以最后是打算复用一些已经建立的应用作为博客的评论系统，例如 &lt;a href=&quot;https://cactus.chat/&quot;&gt;cactus&lt;/a&gt; 评论系统就可以使用 &lt;code&gt;Matrix&lt;/code&gt; 聊天协议作为博客的评论系统。不过我觉得着有点「重」了，而且 &lt;code&gt;Matrix&lt;/code&gt; 主流实现 &lt;code&gt;Synapse&lt;/code&gt; 对于房间、媒体管理这些支持并不算太好，要是被恶意刷请求之后很难清理干净。&lt;/p&gt;&lt;p&gt;所以最后将目光放向了 &lt;code&gt;Mastodon&lt;/code&gt; ，现在谷歌上搜索 &lt;code&gt;mastodon blog comment&lt;/code&gt;  就能搜索出很多方案，本次我也是参（tou）考（qie）整（feng）合（he）了其中两篇的解决方案：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://blog.thms.uk/2023/02/mastodon-comments&quot;&gt;Adding comments to your blog, powered by mastodon&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://danielpecos.com/2022/12/25/mastodon-as-comment-system-for-your-static-blog/&quot;&gt;Mastodon as comment system for your static blog&lt;/a&gt;&lt;/p&gt;&lt;p&gt;主要思想就是利用 &lt;code&gt;Mastodon&lt;/code&gt; 的帖子 &lt;code&gt;API&lt;/code&gt; 获取一条博文下的所有回复，然后处理后插入的指定位置，并不是太复杂。&lt;/p&gt;&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;&lt;p&gt;作为一个备选方案我并没有删掉之前基于 &lt;code&gt;Giscus&lt;/code&gt; 的评论方案，现在是处于共存状态。要启用基于 &lt;code&gt;Mastodon&lt;/code&gt; 的方案就在文章的元数据中指定 &lt;code&gt;fedi_url&lt;/code&gt; 这个变量：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-ejs&quot;&gt;&amp;lt;% if (item.no_comment){ %&amp;gt;
  &amp;lt;!-- no comment --&amp;gt;
&amp;lt;% } else { %&amp;gt;
  &amp;lt;% if (item.fedi_url){ %&amp;gt;
    &amp;lt;div id=&amp;quot;comments&amp;quot;&amp;gt;
      &amp;lt;p id=&amp;quot;mastodon-comments-list&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;
      &amp;lt;script src=&amp;quot;&amp;lt;%- url_for('./js/fedicomment.js') %&amp;gt;&amp;quot; post-url=&amp;quot;&amp;lt;%- item.fedi_url %&amp;gt;&amp;quot;&amp;gt; async&amp;lt;/script&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;noscript&amp;gt;Enable JavaScript to view the comments.&amp;lt;/a&amp;gt;&amp;lt;/noscript&amp;gt;
  &amp;lt;% } else { %&amp;gt;
    &amp;lt;script src=&amp;quot;https://giscus.app/client.js&amp;quot;
                data-*=&amp;quot;……&amp;quot;
            async&amp;gt;
    &amp;lt;/script&amp;gt;
  &amp;lt;% } %&amp;gt;
&amp;lt;% } %&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后引入 &lt;code&gt;fedicomment.js&lt;/code&gt; 这个文件，不直接通过模板直接写入主要还是因为自己自找没趣设置了 &lt;code&gt;CSP&lt;/code&gt; 禁止 &lt;code&gt;inline javascript&lt;/code&gt; 。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-ejs&quot;&gt;&amp;lt;script src=&amp;quot;&amp;lt;%- url_for('./js/fedicomment.js') %&amp;gt;&amp;quot; post-url=&amp;quot;&amp;lt;%- item.fedi_url %&amp;gt;&amp;quot;&amp;gt; async&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这一段指定了 &lt;code&gt;post-url&lt;/code&gt; 这个属性，作为一个变量传入脚本文件里，参见：&lt;a href=&quot;https://stackoverflow.com/questions/14904378/get-data-attribute-of-script-tag&quot;&gt;Get data attribute of script tag?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;之后在脚本文件里将作为全局变量调用：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var post_url = document.currentScript.getAttribute(&amp;quot;post-url&amp;quot;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实际的脚本文件课参见 &lt;code&gt;GitHub&lt;/code&gt; 上： &lt;a href=&quot;https://github.com/SouthFox-D/SouthFox-D.github.io/blob/hexo/themes/freemind/source/js/fedicomment.js&quot;&gt;fedicomment.js&lt;/a&gt; （毕竟要是直接复制过来也太凑字数了），不过实际也是整合了前面提到的两篇参考文章。&lt;/p&gt;&lt;h2 id=&quot;缺点&quot;&gt;缺点&lt;/h2&gt;&lt;p&gt;**麻烦：**使用这套方案的最大特点就是要多一步操作，因为 &lt;code&gt;Mastodon&lt;/code&gt; 的帖子 &lt;code&gt;id&lt;/code&gt; 是根据时间戳生成的，不能提前知晓。所以得在 Mastodon 发好文然后获取帖子链接才能插入到博文这里。或许通过配置自动构建的形式使用帐号的 &lt;code&gt;token&lt;/code&gt; 预先发好帖然后自动插回文件再提交是种解决办法，但是肯定少不了折腾。而且虽说是在博客上的评论系统但是不能在博客上直接评论。&lt;/p&gt;&lt;p&gt;**管理：**如果不是身为站点管理员的话，那么将无法管理帖文下恶意评论，只能在站点层面的封禁才能移除评论。而且即使身为管理，想要删除单条帖文还得先进行「检举」操作标记这条帖文，然后在管理后台才能删除单条帖文的操作。&lt;/p&gt;&lt;p&gt;**限制：**如果站点开启了「安全模式」的话，那么将无法直接调用帖文的 &lt;code&gt;API&lt;/code&gt; ，这样自然谈不上在博客中显示评论了。&lt;/p&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;&lt;p&gt;总体来说，对于想复用服务的人或是联邦爱好者来说可以一试，不过其实相比 &lt;code&gt;Mastodon&lt;/code&gt; ，直接在博客上用 &lt;code&gt;Serveless&lt;/code&gt; 函数平台服务兼容 &lt;code&gt;ActivityPub&lt;/code&gt; 协议似乎是个更好的选择？不过这就相当于从依赖 &lt;code&gt;GitHub&lt;/code&gt; 改为依赖其它平台了……&lt;/p&gt;</content></entry><entry><title>2022年终总结</title><id>https://blog.southfox.me/2023/02/2022年终总结/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2023-02-02T02:22:00Z</updated><link href="https://blog.southfox.me/2023/02/2022年终总结/.html" rel="alternate" /><content type="html">&lt;p&gt;都二月份了！&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;p&gt;今年的年终总结来得晚是因为去年末今年初得病外加农历新年无所事事浑浑噩噩打游戏，不过《开拓者：正义之怒》还是挺好玩的，一种单人跑团代餐。&lt;/p&gt;&lt;h2 id=&quot;自托管&quot;&gt;自托管&lt;/h2&gt;&lt;h3 id=&quot;回流&quot;&gt;回流&lt;/h3&gt;&lt;p&gt;&lt;code&gt;2022&lt;/code&gt; 年想必我的关键词是 &lt;code&gt;自托管&lt;/code&gt; 一词了，一些常用的服务自己搭起来，在上面也费了很多功夫（不过也有很多功夫也是处于一种折腾了最后没怎么用的状态）。虽然前几年自己也在上面折腾过一些东西，不过这次面向到整个互联网感觉还是很不一样的，让我体会到了零几年的教科书绘声绘色介绍互联网的感觉，整个人类的宝库……和远在天涯海角的人……联系……&lt;/p&gt;&lt;p&gt;小时候被妈妈带着的时候，通过企业很早就接触到了互联网，第一个打开的网站好像是什么小游戏网站吧，太小了！甚至连当初的情绪都不记得了，新奇？幸福？还是对滑鼠的小球更感兴趣？然后也因为实在没办法去照料，小学一年级就开始全宿制。这个年纪根本就没有全宿制的安排，都是宿管阿姨在照料。不过我似乎也挺乐在其中，可能我就是那样一种自己能陪自己玩的人吧。&lt;/p&gt;&lt;p&gt;就在这时侯除了玩沙坑也就只能读读书了，或许是这时的书深深影响了我吧，书中对互联网的畅想搭配上蜻蜓点水般的体验，造就了我对于互联网不切实际的幻想。可惜现在互联网成为了大家眼中时好时坏的工具，像是在一望无际的荒原中行走。&lt;/p&gt;&lt;p&gt;没想到二十年后早期互联网的感觉又冒出来了，也许就互联网也像时尚界一样，二十年来一次回流吧。&lt;/p&gt;&lt;h3 id=&quot;若水&quot;&gt;若水&lt;/h3&gt;&lt;p&gt;自托管的好处就是数据在自己手中了，当然实际情况还是要打个问号，甚至惊叹号的。因为自托管面临的问题实在太多了，其中一个方面只要碰上一次「大失败」就要黯灭。但是谁叫这种自在感就是令人舒畅呢？在避无可避的「大失败」来临前再作弄一阵子吧。&lt;/p&gt;&lt;h2 id=&quot;Emacs&quot;&gt;Emacs&lt;/h2&gt;&lt;p&gt;当然还有一件事就是找到了一个能折腾好久的「玩具」，&lt;code&gt;Emacs&lt;/code&gt;。对此也没有什么好说的，因为这一年的博客百分之八十都在谈它。当然很多时候是假喜欢，很多东西都没有深入了解过，但没关系，它就在那里，直到我再也忍受不了它的毛病为止，我应该还能在摆弄上几年吧。&lt;/p&gt;&lt;h2 id=&quot;面纱&quot;&gt;面纱&lt;/h2&gt;&lt;p&gt;严格来讲，去年定下的目标和展望都没有实现多少，关爱身体啦、认清「现实」啦、磨炼技术啦等等，不过其实回头来看，盯着石像上的面纱，还是舞动了几分的。世界依然朦胧，但我已在月色下盯着湖面发呆，即使挨不到清晨的到来，此刻还算不赖。但是随着世界终于回归正轨，今年还是要稍微「正常」一下，至少为一个目标所努力。&lt;/p&gt;&lt;p&gt;2022 年，对我来说是失去的一年，就像「失去的十年」一样（气候变化上的说法），大家在扯皮中丧失希望，嘟囔着十年什么事都没干成，世界末日已经来临。但回过头来看世界并没有被毁灭，在一地鸡毛里，一些希望正在发展。&lt;/p&gt;&lt;p&gt;没有毁灭，但是问题依然存在，但随着绝望的潮水退去，踩在「正常」的大地上……或许回想起几年后的场景，没来头闲逛时发现当时的痕迹我一拍脑门想到，「啊，当时的水位~竟然有这么高吗？」&lt;/p&gt;</content></entry><entry><title>Emacs 使用再记（3）</title><id>https://blog.southfox.me/2023/01/Emacs-使用再记（3）/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2023-01-15T15:22:00Z</updated><link href="https://blog.southfox.me/2023/01/Emacs-使用再记（3）/.html" rel="alternate" /><content type="html">&lt;p&gt;两种喜欢的事遇到一起，多是一件美事啊。&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;p&gt;折腾 &lt;code&gt;Emacs&lt;/code&gt; 最重要就是开心，而能开心的事莫过于想实现的功能已经提前有人去实现了，这时候只要愉快导包就好了。&lt;/p&gt;&lt;h2 id=&quot;Mastodon&quot;&gt;Mastodon&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://codeberg.org/martianh/mastodon.el&quot;&gt;Mastodon.el&lt;/a&gt; 是一个 &lt;code&gt;Emacs&lt;/code&gt; 平台的 &lt;code&gt;Mastodon&lt;/code&gt; 客户端，为什么啥事都要用 &lt;code&gt;Emacs&lt;/code&gt; 来实现呢？因为只要将文字送入 &lt;code&gt;Emacs&lt;/code&gt; 解析，那么就能够和其它包进行联动，这可是很诱人的事啊。&lt;/p&gt;&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Mastodon.el&lt;/code&gt; 也已经上传到了 &lt;code&gt;MELPA&lt;/code&gt; 上面，可以直接进行安装。使用时只要指定实例地址和用户名：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(setq mastodon-instance-url &amp;quot;https://social.instance.org&amp;quot;
      mastodon-active-user &amp;quot;example_user&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后直接 &lt;code&gt;M-x mastodon&lt;/code&gt; 运行指令，然后就会往剪贴板复制一串授权地址，粘贴到登陆的了实例浏览器进行打开，获取授权码再复制回 &lt;code&gt;Emacs&lt;/code&gt; 就能完全授权了。&lt;/p&gt;&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;&lt;p&gt;当然如果是使用 &lt;code&gt;Doom emacs&lt;/code&gt; 配置集的话，自带的 &lt;code&gt;vim&lt;/code&gt; 按键绑定会覆盖掉 &lt;code&gt;mastodon.el&lt;/code&gt; 的自带按键设定，所以还是得自己设置一下。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(map! :leader
      :prefix (&amp;quot;o&amp;quot;)
      :desc &amp;quot;Mastodon&amp;quot;          &amp;quot;M&amp;quot; #'mastodon)

(map! :after mastodon
      :map mastodon-mode-map
      :n &amp;quot;[ [&amp;quot; #'mastodon-tl--goto-prev-toot
      :n &amp;quot;] ]&amp;quot; #'mastodon-tl--goto-next-toot
      :n &amp;quot;g k&amp;quot; #'mastodon-tl--previous-tab-item
      :n &amp;quot;g j&amp;quot; #'mastodon-tl--next-tab-item

      :n &amp;quot;q&amp;quot; #'kill-current-buffer
      :n &amp;quot;Q&amp;quot; #'kill-buffer-and-window

      ;;; timelines
      :n &amp;quot;#&amp;quot; #'mastodon-tl--get-tag-timeline
      :n &amp;quot;A&amp;quot; #'mastodon-profile--get-toot-author
      :n &amp;quot;F&amp;quot; #'mastodon-tl--get-federated-timeline
      :n &amp;quot;H&amp;quot; #'mastodon-tl--get-home-timeline
      :n &amp;quot;L&amp;quot; #'mastodon-tl--get-local-timeline
      :n &amp;quot;N&amp;quot; #'mastodon-notifications-get
      :n &amp;quot;O&amp;quot; #'mastodon-profile--my-profile
      :n &amp;quot;P&amp;quot; #'mastodon-profile--show-user
      :n &amp;quot;T&amp;quot; #'mastodon-tl--thread

      ;;; toot actions
      :n &amp;quot;K&amp;quot; #'mastodon-toot--bookmark-toot-toggle
      :n &amp;quot;R&amp;quot; #'mastodon-toot--toggle-boost
      :n &amp;quot;c&amp;quot; #'mastodon-tl--toggle-spoiler-text-in-toot
      :n &amp;quot;C&amp;quot; #'mastodon-toot--copy-toot-url
      :n &amp;quot;o&amp;quot; #'mastodon-url-lookup
      :n &amp;quot;d&amp;quot; #'mastodon-toot--delete-toot
      :n &amp;quot;D&amp;quot; #'mastodon-toot--delete-draft-toot
      :n &amp;quot;f&amp;quot; #'mastodon-toot--toggle-favourite
      :n &amp;quot;r&amp;quot; #'mastodon-toot--reply
      :n &amp;quot;u&amp;quot; #'mastodon-tl--update
      :n &amp;quot;v&amp;quot; #'mastodon-tl--poll-vote

      ;;; toot!
      :n &amp;quot;t&amp;quot; #'mastodon-toot

      ;;; mastodon additions
      :n &amp;quot;S&amp;quot;    #'mastodon-search--search-query
      :n &amp;quot;V F&amp;quot;  #'mastodon-profile--view-favourites
      :n &amp;quot;V B&amp;quot;  #'mastodon-profile--view-bookmarks
      :n &amp;quot;V L&amp;quot; #'mastodon-tl--view-list-timeline
      )&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一处就是使用 &lt;code&gt;SPC o M&lt;/code&gt; 来打开 &lt;code&gt;mastodon.el&lt;/code&gt; 这个包，实现快速摸鱼，第二处设置则是照虎画猫其他人的&lt;a href=&quot;https://github.com/coutego/evil-collection/blob/master/modes/mastodon/evil-collection-mastodon.el&quot;&gt;配置&lt;/a&gt;来实现的，虽然没看文档（坏习惯），但是猜测 &lt;code&gt;:map mastodon-mode-map&lt;/code&gt; 是选择指定那个模式下的按键配置，&lt;code&gt;:n&lt;/code&gt; 是覆盖 &lt;code&gt;vim&lt;/code&gt; 那个模式下的按键绑定，&lt;code&gt;n&lt;/code&gt; 应该是普通模式。&lt;/p&gt;&lt;p&gt;按键绑定改来改去，要在不影响原本的 &lt;code&gt;hjkl&lt;/code&gt; 和 &lt;code&gt;wby&lt;/code&gt; 常用指令还要做到方便（自己）记忆还是有点难的，毕竟能兼容了原本按键绑定进行复制粘贴起也比较好操作。&lt;/p&gt;&lt;p&gt;总体来看还是倾向于一个补充，毕竟 &lt;code&gt;Emacs&lt;/code&gt; 网络相关的操作确实不太行，跟 &lt;code&gt;Web&lt;/code&gt;  端确实是不能比的，但是能够快速摸鱼外加和其它包联携的潜力（比如打开收藏夹进行进行分析；直接拷贝嘟文内容送入待办等），还要啥自行车呢。&lt;/p&gt;&lt;h2 id=&quot;Matrix&quot;&gt;Matrix&lt;/h2&gt;&lt;p&gt;接下来就是聊天了，其实作为和 &lt;code&gt;Emacs&lt;/code&gt; 同一个时代的产品，&lt;code&gt;IRC&lt;/code&gt; 自然是支持众多的，不过我已经选择另一款聊天协议了 &lt;a href=&quot;https://matrix.org/&quot;&gt;Matrix&lt;/a&gt; 。&lt;/p&gt;&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;&lt;p&gt;虽然也有一些包支持但是现在还在积极开发的也就 &lt;a href=&quot;https://github.com/alphapapa/ement.el&quot;&gt;ement.el&lt;/a&gt; 其作者 &lt;code&gt;alphapapa&lt;/code&gt; 也是有名的 &lt;code&gt;Emacs&lt;/code&gt; 使用者了，写了很多流行的包。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ement.el&lt;/code&gt; 现在也是上传到了 &lt;code&gt;GNU ELPA&lt;/code&gt; 可以直接进行安装，但是实现起来那叫一个坑多啊，虽然大部分都是自己的问题。&lt;/p&gt;&lt;p&gt;安装后首先要登陆，但发现一直登陆不上去，之后排查是自己的 &lt;a href=&quot;https://matrix-org.github.io/synapse/latest/delegate.html#well-known-delegation&quot;&gt;Delegation&lt;/a&gt; 功能没有加上 &lt;code&gt;https://&lt;/code&gt; 例如 &lt;code&gt;return 200 '{&amp;quot;m.homeserver&amp;quot;: {&amp;quot;base_url&amp;quot;: &amp;quot;synapse.matrix.org&amp;quot;}}';&lt;/code&gt;  ，应该是 &lt;code&gt;return 200 '{&amp;quot;m.homeserver&amp;quot;: {&amp;quot;base_url&amp;quot;: &amp;quot;https://synapse.matrix.org&amp;quot;}}';&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;没有做到这一点导致 &lt;code&gt;ement.el&lt;/code&gt; 发起的链接不成功，虽然很想指责一下是包的健壮性不足但姑且还是把责任揽到自己身上吧……&lt;/p&gt;&lt;p&gt;登陆之后发现解密不了加密消息，看说明才发现是 &lt;code&gt;ement.el&lt;/code&gt; 不原生支持加密功能，想想也对，想支持得用 &lt;code&gt;ELisp&lt;/code&gt; 去造轮子太麻烦了（当然我觉得主要原因是作者对于用 &lt;code&gt;Matrix&lt;/code&gt; 发送加密消息没什么兴趣）。&lt;/p&gt;&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;&lt;p&gt;不过还有曲线救国方案就是用 &lt;a href=&quot;https://github.com/matrix-org/pantalaimon&quot;&gt;pantalaimon&lt;/a&gt; ，一个代理程序，可以将加密消息解密提供给其它不支持加密的客户端使用。&lt;/p&gt;&lt;p&gt;安装上可以直接用 &lt;code&gt;pip&lt;/code&gt; 进行安装 &lt;code&gt;pip install pantalaimon&lt;/code&gt; 之后得编辑 &lt;code&gt;~/.config/pantalaimon/pantalaimon.conf&lt;/code&gt; 下的配置文件指定实例地址和相关配置。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[配置名称，随便填]
Homeserver = https://实例地址
ListenAddress = localhost
ListenPort = 8009
VerifySessions = False
UseKeyring = False
IgnoreVerification = True&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意如果启用了  &lt;a href=&quot;https://matrix-org.github.io/synapse/latest/delegate.html#well-known-delegation&quot;&gt;Delegation&lt;/a&gt; 功能的话实例地址得填真正使用的服务地址。后面三行是不断试错加进去的，因为这个程序真的是缺文档，所以也不清楚对实际运行有没有影响。&lt;/p&gt;&lt;p&gt;之后再启动程序 &lt;code&gt;pantalaimon --log-level debug&lt;/code&gt; ，但是现在还没有真正运行，首先在 &lt;code&gt;Emacs&lt;/code&gt; 里进行登陆并且指定使用的地址:&lt;/p&gt;&lt;p&gt;按下 &lt;code&gt;M-S ；&lt;/code&gt; 运行指定本地反代的地址的指令：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(ement-connect :uri-prefix &amp;quot;http://localhost:8009&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后输入帐号密码进行登陆，看日志应该能发现有所输出，等待到数据同步后 &lt;code&gt;Emacs&lt;/code&gt; 显示了房间列表后。切换到另一个已经登陆的客户端上应该能发现两个设备进行登陆，一个叫 &lt;code&gt;pantalaimon&lt;/code&gt; 另一个是随机字符串是 &lt;code&gt;ement.el&lt;/code&gt; 使用的。两个都显示未支持加密功能。这时先用 &lt;code&gt;Emacs&lt;/code&gt; 进入一个开启加密的房间然后用 &lt;code&gt;ement-room-send-message&lt;/code&gt; 指令发送一条消息，理所当然的不会成功，因为 &lt;code&gt;pantalaimon&lt;/code&gt; 还没通过验证，但现在应该会显示 &lt;code&gt;pantalaimon&lt;/code&gt; 设备变成支持加密的未知设备了。&lt;/p&gt;&lt;p&gt;这时在开启一个终端输入 &lt;code&gt;panctl&lt;/code&gt; 指令进入控制，参考&lt;a href=&quot;https://www.cogitri.dev/posts/10-pantalaimon-setup/&quot;&gt;这篇文章&lt;/a&gt;进行验证操作 ，具体来说就是用指令 &lt;code&gt;start-verification @自己帐号:自己实例 @自己帐号:自己实例 已经登陆的设备的设备号&lt;/code&gt; 发起验证，然后用那一个已经登陆的设备确实验证请求开启交叉验证……其中可能会卡住或许要多发起几次。&lt;/p&gt;&lt;p&gt;确实 &lt;code&gt;emoji&lt;/code&gt; 匹配后就使用 &lt;code&gt;confirm-verification @自己帐号:自己实例 @自己帐号:自己实例 已经登陆的设备的设备号&lt;/code&gt; 指令验证 &lt;code&gt;pantalaimon&lt;/code&gt; 设备。转过头去 &lt;code&gt;Emacs&lt;/code&gt; 里再尝试发起加密房间的消息查看是否成功。&lt;/p&gt;&lt;h3 id=&quot;再配置&quot;&gt;再配置&lt;/h3&gt;&lt;p&gt;之后如果希望将 &lt;code&gt;pantalaimon&lt;/code&gt; 作为系统服务开机自启的话就发现不行，会遇到相关总线问题，因为其中一些 &lt;code&gt;pyDbus&lt;/code&gt; 什么的调用导致无法挂在后台吧。&lt;/p&gt;&lt;p&gt;权宜之计是按照这个&lt;a href=&quot;https://github.com/matrix-org/pantalaimon/issues/144#issuecomment-1345473181&quot;&gt;说法&lt;/a&gt;手动编辑 &lt;code&gt;pantalaimon&lt;/code&gt; 包下的 &lt;code&gt;ui.py&lt;/code&gt; 文件关闭 &lt;code&gt;UI&lt;/code&gt; 功能：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-py&quot;&gt;UI_ENABLED = False&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后就能当作 &lt;code&gt;service&lt;/code&gt; 进行管理理，代价就是无法使用 &lt;code&gt;panctl&lt;/code&gt; 命令，不过只要没有再配置的需求还是能接受的，或是从一开始就使用 &lt;code&gt;Docker&lt;/code&gt; 然后按照这&lt;a href=&quot;https://github.com/matrix-org/pantalaimon/issues/144#issuecomment-1376163550&quot;&gt;说法&lt;/a&gt;进行配置。&lt;/p&gt;&lt;h3 id=&quot;再再配置&quot;&gt;再再配置&lt;/h3&gt;&lt;p&gt;然后记得配置&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(setq ement-save-sessions t)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将会话数据保留下来，要不然每次登陆都会新申请一个设备，每开一次 &lt;code&gt;Emacs&lt;/code&gt; 来这样一次那很快就要达到上百个设备了。&lt;/p&gt;&lt;p&gt;配置此选项后关闭 &lt;code&gt;Emacs&lt;/code&gt; 应该能注意到关闭 &lt;code&gt;Emacs&lt;/code&gt; 会将会话数据写入，没有的话还得重启 &lt;code&gt;Emacs&lt;/code&gt; 使用&lt;code&gt;(ement-connect :uri-prefix &amp;quot;http://localhost:8009&amp;quot;)&lt;/code&gt; 指令再登陆几次。检查 &lt;code&gt;ement-sessions-file&lt;/code&gt; 变量是否有被设置，默认是 &lt;code&gt;&amp;quot;~/.cache/ement.el&amp;quot;&lt;/code&gt; ，到该路径检查，有没有设置反代地址和保存了相关 &lt;code&gt;token&lt;/code&gt; ，有的话就万事大吉了，之后也可以直接用 &lt;code&gt;ement-connect&lt;/code&gt; 直接登陆，因为反代地址已经保存了所以也不用再去特意指定。&lt;/p&gt;&lt;h3 id=&quot;再再再配置&quot;&gt;再再再配置&lt;/h3&gt;&lt;p&gt;跟 &lt;code&gt;mastodon.el&lt;/code&gt; 问题一样，&lt;code&gt;Doom emacs&lt;/code&gt; 的按键绑定会覆盖掉相关绑定，不过我想将上面让人头大的解决掉按键绑定就不是什么难题了。&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;两款常用服务配置下来那就挺让人舒适的了，快速刷轴摸鱼，聊天也可以在 &lt;code&gt;Emacs&lt;/code&gt; 实现，主要优点是不走 &lt;code&gt;Web&lt;/code&gt; 端的话，资源是比较省的，不用再加载几兆几十兆的脚本外加浏览器吃掉的内存了，两种喜欢的事加起来，多是一件美事啊。&lt;/p&gt;</content></entry><entry><title>Arch 系统随便用暨 Emacs 使用再记（2）</title><id>https://blog.southfox.me/2022/12/Arch系统随便用暨Emacs使用再记（2）/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2022-12-03T20:00:00Z</updated><link href="https://blog.southfox.me/2022/12/Arch系统随便用暨Emacs使用再记（2）/.html" rel="alternate" /><content type="html">&lt;p&gt;我还挺喜欢用 &lt;code&gt;Manjaro&lt;/code&gt; 的，就喜欢这种低人一等的感觉。&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;p&gt;反正系统相关的我也不懂啦，用着玩的，不想对这些 &lt;code&gt;Linux&lt;/code&gt; 发行版使用什么个排序算法争出个最优。用 &lt;code&gt;Manjaro&lt;/code&gt; 单纯就是安装方便同时教程好找点……不过最近（二十天前），当我更新包时突然开始报错「&lt;code&gt;libssl3.0&lt;/code&gt; 未找到。」去网上搜发现五六天前 &lt;code&gt;Manjaro&lt;/code&gt; 论坛就有此问题，但也只是捕风捉影并没有实际解决方案。&lt;/p&gt;&lt;p&gt;之后电脑新开一些应用已经打不开了，在终端里也只会一直显示库错误，估计系统已经成为一个僵尸了，一旦重新启动估计就会立马爆炸吧（重新启动果然如此，连终端环境都进不了）。&lt;/p&gt;&lt;p&gt;没办法，重装吧！对于这种问题向来我都是重装解决一切问题的，心想这次还是不要用 &lt;code&gt;KDE&lt;/code&gt; 了，试试其它桌面环境吧，结果没想到 &lt;code&gt;Manjaro&lt;/code&gt; 系统安装程序会卡在最后一步安装系统引导上（现在想来应该是智熄操作没有选到 &lt;code&gt;UEFI&lt;/code&gt; 选项导致的）。&lt;/p&gt;&lt;h2 id=&quot;Arch随便用&quot;&gt;Arch 随便用&lt;/h2&gt;&lt;h3 id=&quot;懒不动&quot;&gt;懒不动&lt;/h3&gt;&lt;p&gt;那么既然已经装不下了那就换个口味吧，换成更上游的 &lt;code&gt;Arch&lt;/code&gt; 。之前一直没用 &lt;code&gt;Arch&lt;/code&gt; 的原因就是系统安装没有提供一个图形化界面，就觉得很麻烦，不过查 &lt;code&gt;wiki&lt;/code&gt; 时发现现在会附带一个 &lt;code&gt;archinstall&lt;/code&gt; 程序辅助安装，那么就尝试用用看吧，能这么惬意决定重装也是因为大部分数据都是放在另一快数据盘上，是和系统盘分开的。&lt;/p&gt;&lt;p&gt;第一时间就发现的是 &lt;code&gt;Arch&lt;/code&gt; 的镜像挺小的，1G 还不到，但之后就发现为什么是这样了。因为只包括了基本的组件，要成为一个能用系统的东西还得从网上下，在运行 &lt;code&gt;archinstall&lt;/code&gt; 还要需求联网还卡住了几分钟的我才顿悟到……&lt;/p&gt;&lt;p&gt;不过说是辅助安装但也只是一个选项菜单而已，方便选择磁盘之类的，不过总比没有好吧，选好系统环境、额外包、挂载目录进行安装……最后报错识别不了另一个盘的某个分区，又不是在安装的盘上为什么还要去管其它盘上的事啊，重试了几次后依然卡在这里，没办法，想懒懒不动了，只好自己手动装了。&lt;/p&gt;&lt;h3 id=&quot;随便装&quot;&gt;随便装&lt;/h3&gt;&lt;p&gt;手动装就一步一步自己慢慢盯着了，看着 &lt;code&gt;wiki&lt;/code&gt; 再顺便开几个教程帖，之后慢慢对着下来，无非就是选择分区然后挂载点之类的（我这种大懒狐一个 &lt;code&gt;/&lt;/code&gt;  就够了），然后选择速度快的镜像站把基础系统组件还有网络管理包之类的装上去就完事了。&lt;/p&gt;&lt;p&gt;之后 &lt;code&gt;unmount&lt;/code&gt;，重启，噔噔噔……新系统就来了，不过没有选择桌面环境所以显示的还是挺「刻板印象里的黑客风」黑黢黢命令窗口。桌面环境想了想还是选择 &lt;code&gt;GNOME&lt;/code&gt; 吧，没错，我就喜欢卡又多 &lt;code&gt;BUG&lt;/code&gt; 低人几等的感觉，只能说习惯的力量还是惊人的，本来其实还想体验 &lt;code&gt;i3&lt;/code&gt; 环境来着但是到现在一次都没打开过（&lt;/p&gt;&lt;p&gt;安装重新登陆后，一个毛坯房 &lt;code&gt;GNOME&lt;/code&gt; 环境就出来了，看看系统占用，发现真的挺轻量的，内存占用在 1.5G 左右，只有 &lt;code&gt;Manjaro&lt;/code&gt; 一半左右。感想就是 &lt;code&gt;Minecraft&lt;/code&gt; 热门整合包和自己配整合包吧，现在自用的这款系统还是有点缺东少西，比如最重要的代理和 &lt;code&gt;Emacs&lt;/code&gt; 了。&lt;/p&gt;&lt;h3 id=&quot;随便折腾&quot;&gt;随便折腾&lt;/h3&gt;&lt;p&gt;代理的事因为相关软件挂在 &lt;code&gt;yay&lt;/code&gt; 上，但是安装 &lt;code&gt;yay&lt;/code&gt; 要自己构建下一大堆 &lt;code&gt;GO&lt;/code&gt; 相关东西而又需要代理环境，经典先有鸡还是先有蛋了属于是，不过好在可以用其它设备开放的代理环境救救急，这时候才发现 &lt;code&gt;Manjaro&lt;/code&gt; 默认把 &lt;code&gt;yay&lt;/code&gt; 集成到了自己的源中是有理由的……&lt;/p&gt;&lt;p&gt;安装 &lt;code&gt;yay&lt;/code&gt; 后就能愉快的继续偷 &lt;code&gt;Arch&lt;/code&gt; 的……嘶，我现在就是 &lt;code&gt;Arch&lt;/code&gt; 系统了，所以是光明正大来用！&lt;/p&gt;&lt;h4 id=&quot;编辑器&quot;&gt;编辑器&lt;/h4&gt;&lt;p&gt;首先是使用 &lt;code&gt;neovim&lt;/code&gt; ，&lt;code&gt;Emacs&lt;/code&gt; 这位大爷还是等所有东西都搞定了在把祂请过来吧。&lt;/p&gt;&lt;h4 id=&quot;字体&quot;&gt;字体&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -S noto-fonts-cjk&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;庞大的汉字在计算机世界还是要折腾一番的，不下中文字体开个浏览器就全是口口口的豆腐框了，所以要 &lt;code&gt;noto(fu)&lt;/code&gt; 字体来拯救一下。&lt;/p&gt;&lt;h4 id=&quot;输入法&quot;&gt;输入法&lt;/h4&gt;&lt;p&gt;好在在之前系统自爆前把 &lt;code&gt;Rime&lt;/code&gt; 的配置文件抢救了下来，所以直接使用相应包：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -S fcitx5-im fcitx5-rime&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后编辑 &lt;code&gt;/etc/environment&lt;/code&gt; 文件，添加以下几行&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;GTK_IM_MODULE=fcitx
QT_IM_MODULE=fcitx
XMODIFIERS=@im=fcitx
SDL_IM_MODULE=fcitx
GLFW_IM_MODULE=ibus&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后重新登录就好了，反正 &lt;a href=&quot;https://wiki.archlinuxcn.org/wiki/Fcitx5&quot;&gt;ArchWiki&lt;/a&gt; 是这么说的，之后把之前备份的 &lt;code&gt;Rime&lt;/code&gt; 配置覆盖回 &lt;code&gt;~/.local/share/fcitx5/rime&lt;/code&gt; 里就好了，使用的方案是 &lt;a href=&quot;https://github.com/mutoe/rime&quot;&gt;双拼自然码方案&lt;/a&gt;和 &lt;a href=&quot;https://github.com/Bambooin/rimerc&quot;&gt;rimerc&lt;/a&gt; ，毕竟没有网络词和大公司的算法加持，想要加快输入速度只能从自己的手法上入手了。&lt;/p&gt;&lt;h4 id=&quot;按键绑定&quot;&gt;按键绑定&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -S gnome-tweak-tool&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;突然发现 &lt;code&gt;Gnome tweak&lt;/code&gt; 里面的 &lt;code&gt;Keyboard &amp;amp; Mouse&lt;/code&gt; 里有一个 &lt;code&gt;Emacs Input&lt;/code&gt; 选项，打开它后就能在操作系统里实现 &lt;code&gt;Emacs Keybinding&lt;/code&gt; 了，就 &lt;code&gt;C-a&lt;/code&gt; 将光标移动到行首这种的，真实 &lt;code&gt;Emacs EveryWhere&lt;/code&gt; 了。然后 &lt;code&gt;/usr/share/themes/Emacs/gtk-2.0-key/gtkrc&lt;/code&gt; 文件是具体的配置，可以让猫猫来看具体定义了哪些按键（我是指，&lt;code&gt;cat&lt;/code&gt; 命令……）&lt;/p&gt;&lt;h4 id=&quot;窗口切换&quot;&gt;窗口切换&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -S gnome-shell-extensions&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在 &lt;code&gt;gnome-extensions&lt;/code&gt; 开启 &lt;code&gt;Window List&lt;/code&gt; 选项，这样就能像 &lt;code&gt;Win&lt;/code&gt; 系统一样显示一个任务栏在窗口底部，如果这不是默认启用的我真想不到平常使用 &lt;code&gt;GNOME&lt;/code&gt; 是怎么切换窗口的？难道这是 &lt;code&gt;Win&lt;/code&gt; 系统带来的我永远摆脱不了的烙印？&lt;/p&gt;&lt;h4 id=&quot;钥匙环儿&quot;&gt;钥匙环儿&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -S gnome-keyring&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我一般使用 &lt;code&gt;Nextcloud&lt;/code&gt; 的桌面客户端来同步数据的，如果缺少这个就会无限首次重新需求登录，似乎 &lt;code&gt;Minecraft&lt;/code&gt; 启动器也会有这个问题，所以还是得装的。&lt;/p&gt;&lt;h4 id=&quot;其它&quot;&gt;其它&lt;/h4&gt;&lt;p&gt;其它的有了 &lt;code&gt;yay&lt;/code&gt; 也挺容易装了比如 &lt;code&gt;oh-my-zsh&lt;/code&gt;  之类的，看情况调个顺眼的用用,&lt;/p&gt;&lt;p&gt;其中 &lt;code&gt;keyd&lt;/code&gt; 这个应用可以改键，把 &lt;code&gt;Esc&lt;/code&gt; 和 &lt;code&gt;Caps&lt;/code&gt; 调换之类的，虽然 &lt;code&gt;GNOME&lt;/code&gt; 里有什么组件能改不过我也是路径依懒惯了……&lt;/p&gt;&lt;h2 id=&quot;Emacs&quot;&gt;Emacs&lt;/h2&gt;&lt;p&gt;终于最后就是把这位神请回来了，&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -S emacs-nativecomp ripgrep&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然完全搞不懂但是听说加了 &lt;code&gt;nativecomp&lt;/code&gt; 会让运行速度有改善的样子，之后克隆下来 &lt;code&gt;doomemacs&lt;/code&gt; 的配置仓库，将之前的备份过的配置文件放入 &lt;code&gt;~/.doom&lt;/code&gt; 里，然后开始安装，之后就只能等了，几百个包安装编译啥的估计要登上十多分钟。&lt;/p&gt;&lt;h3 id=&quot;邮件&quot;&gt;邮件&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;yay -S mu isync&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参照&lt;a href=&quot;https://blog.lazkani.io/posts/email-setup-with-isync-notmuch-afew-msmtp-and-emacs/&quot;&gt;这篇文章&lt;/a&gt;完成 &lt;code&gt;mbsync(isync)&lt;/code&gt; 设定，然后 &lt;code&gt;mbsync -a&lt;/code&gt; 拉取邮件，然后参照&lt;a href=&quot;https://liujiacai.net/blog/2021/03/05/emacs-love-mail-feed/&quot;&gt;这篇文章&lt;/a&gt;完成 &lt;code&gt;mu4e&lt;/code&gt; 配置（&lt;code&gt;mu4e&lt;/code&gt; 在 &lt;code&gt;doomemacs&lt;/code&gt; 也有相应配置可启用），然后：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;export XAPIAN_CJK_NGRAM=true
# 只需要执行一次 init，可以指定多个邮件地址
mu init --my-address your-mail@qq.com --my-address your-mail@gmail.com -m ~/.mail
# index 在每次收取邮件后都需要执行，mu4e 可以配置自动执行
mu index&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就能为邮件建立索引，之后在 &lt;code&gt;Emacs&lt;/code&gt; 里使用 &lt;code&gt;Spc o m&lt;/code&gt; 即可打开 &lt;code&gt;mu4e&lt;/code&gt; 界面进行使用了。&lt;/p&gt;&lt;h3 id=&quot;Latex&quot;&gt;Latex&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Emacs&lt;/code&gt; 里预览公式需要 &lt;code&gt;latex&lt;/code&gt;，使用&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -S texlive-langextra&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装 &lt;code&gt;texlive&lt;/code&gt; 发行版同时还要指定是 &lt;code&gt;extra&lt;/code&gt; 包才能应付公式预览。&lt;/p&gt;&lt;h3 id=&quot;Emacseverywhere&quot;&gt;Emacs everywhere&lt;/h3&gt;&lt;p&gt;类似于空间文里的随身空间，直接在任意能输入文字的地方启动一个 &lt;code&gt;Emacs&lt;/code&gt; 编辑器，这样就不用离开自己的安乐窝了。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;sudo pacman -S xclip xdotool xorg-xprop xorg-xwininfo&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在 &lt;code&gt;gnome&lt;/code&gt; 里指定一个快捷键绑定上 &lt;code&gt;emacsclient --eval &amp;quot;(emacs-everywhere)&amp;quot;&lt;/code&gt;  就能想用就用 &lt;code&gt;Emacs&lt;/code&gt; 这个随身编辑器了。&lt;/p&gt;</content></entry><entry><title>Emacs再记（1）：传教二度</title><id>https://blog.southfox.me/2022/08/Emacs再记（1）：传教二度/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2022-08-16T14:17:00Z</updated><link href="https://blog.southfox.me/2022/08/Emacs再记（1）：传教二度/.html" rel="alternate" /><content type="html">&lt;p&gt;论都 2022 年了为什么要用 Emacs 。&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;p&gt;&lt;code&gt;Emacs&lt;/code&gt; 最早可以追溯到 &lt;code&gt;1975&lt;/code&gt;年，经过多年发展诞生了许多分支，不过现在都是特指 &lt;code&gt;GNU Emacs&lt;/code&gt;，时间没有葬送这款软件，直至现在也有不少人在使用它。&lt;/p&gt;&lt;h2 id=&quot;Emacs之世界观&quot;&gt;Emacs 之世界观&lt;/h2&gt;&lt;p&gt;经过将近一年的使用，我对于 &lt;code&gt;Emacs&lt;/code&gt; 也有了更多的了解，索性再写一遍第（1）篇吧。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Emacs&lt;/code&gt; ，其&lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;官网&lt;/a&gt;对它的描述是：一个可拓展的、客制化的自由（免费）文本编辑器—and more。当然这么多天用下来，我发现其实 &lt;code&gt;Emacs&lt;/code&gt; 本质并不是一个文本编辑器，因为它有一片自己的世界……&lt;/p&gt;&lt;p&gt;举个不恰当的例子来说，其它文本编辑器里编辑文本像是挥舞武器，安装一个插件并运用其功能像是吟唱一个魔法，其底层实现方式大家都一样，之间的区别不是很大。&lt;/p&gt;&lt;p&gt;而 &lt;code&gt;Emacs&lt;/code&gt;，表面看是挥舞武器，但实际是因为心中有战斗的决心所以才能具现一把专属武器并战斗，表面上看是吟唱魔法，但实际上是因为其所在世界是一个失落的高科技世界，吟唱魔法其实是在和空中散落的纳米单元进行沟通然后由单元实现具体效果……虽然最后 &lt;code&gt;Emacs&lt;/code&gt; 和其他文本编辑器实现了同样效果，但是它们的「世界观」是有根本不同的。&lt;/p&gt;&lt;h2 id=&quot;自由&quot;&gt;自由&lt;/h2&gt;&lt;p&gt;查看 &lt;code&gt;Emacs&lt;/code&gt; 代码仓库就能发现，其构成代码有近六成是由一个叫作 &lt;code&gt;Emacs Lisp&lt;/code&gt; 的语言构成的，&lt;code&gt;Emacs&lt;/code&gt; 以其说是一款文本编辑器倒不如说是作为 &lt;code&gt;Emacs Lisp&lt;/code&gt; 的运行环境，打开软件那出现的窗口和菜单，是 &lt;code&gt;Emacs&lt;/code&gt; 自己不断修改自己的体现。&lt;/p&gt;&lt;p&gt;这样的实现方式，更是让 &lt;code&gt;Emacs&lt;/code&gt; 对于用户的态度和其他编辑器有很大不同，再举个不恰当的例子来说：&lt;/p&gt;&lt;p&gt;其它文本编辑器就像一个人类：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;想要其它功能的话请指定，比如沟通语言从英语切换成汉语……什么？想要克林贡语，不好意思，没有，请自行查询插件商店吧。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;商店里没有？请自己参照接口标准自行实现一个吧？什么，你还想要修改大脑的核心功能？不可能！太危险了！&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;真想要修改大脑核心功能的话，请自行修改「源代码」去。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Emacs&lt;/code&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;犹如一个不定形的阿米巴变形虫，时刻不停在蠕动、变形……&lt;/li&gt;&lt;li&gt;想要切换到特定功能？好啊好啊，请自行在「配置文件」里指定吧……&lt;/li&gt;&lt;li&gt;没有想要的功能？那请自行在「配置文件」里实现具体功能吧……等我重载之后就能看到新功能了……&lt;/li&gt;&lt;li&gt;想干预一个核心功能？随便……&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;所以对于 &lt;code&gt;Emacs&lt;/code&gt; 来说，它不像其他软件的 &lt;code&gt;.ini&lt;/code&gt;  &lt;code&gt;.env&lt;/code&gt; 一样，只能附加几个参数或者在 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 已有的功能切换，在 &lt;code&gt;Emacs&lt;/code&gt; 里，没有 &lt;code&gt;C&lt;/code&gt; 功能，你可以自行在「配置文件」里实现，因为「配置文件」即是「源代码」，因为 &lt;code&gt;Emacs&lt;/code&gt; 是在那旧时代下诞生的软件，它完全信任用户。&lt;/p&gt;&lt;h2 id=&quot;混乱&quot;&gt;混乱&lt;/h2&gt;&lt;p&gt;当然自由的代价就是导致了其黑魔法满天飞，大魔法师用着呼风唤雨，而学徒却看着一大堆选择摸不着头脑。&lt;/p&gt;&lt;p&gt;不过随着社区的聚集，现在也出现了 &lt;a href=&quot;https://www.spacemacs.org/&quot;&gt;Spacemacs&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/doomemacs/doomemacs&quot;&gt;Doom emacs&lt;/a&gt; 这样的整合网上优秀第三方包和配置的配置集，新手直接使用的话可以在一开始时就能体验到 &lt;code&gt;Emacs&lt;/code&gt; 生态里的大部分优秀功能。&lt;/p&gt;&lt;h2 id=&quot;低效&quot;&gt;低效&lt;/h2&gt;&lt;p&gt;建立在 &lt;code&gt;Emacs Lisp&lt;/code&gt; 上的 &lt;code&gt;Emacs&lt;/code&gt; 其一大特征就是……慢……当然大多数场景不会感受到，但是出现了这个情况就真的有点锻炼耐心了。而且 &lt;code&gt;Emacs&lt;/code&gt; 说好听点是历史悠久，难听点就是历史包袱过重了，一些上古代码散落在各处，非常高效地拖慢了 &lt;code&gt;Emacs&lt;/code&gt; 在一些场景的性能让其低效（感谢 &lt;code&gt;Emacs&lt;/code&gt; 让我在 2022 年体会到了多图杀猫的效果）。&lt;/p&gt;&lt;h2 id=&quot;甜美错觉&quot;&gt;甜美错觉&lt;/h2&gt;&lt;p&gt;如果在多了解一点的话，可能就会发现很多人都在吐槽 &lt;code&gt;Emacs&lt;/code&gt; 用着像是一款操作系统一样，收发电子邮件、记录笔记、安排待办、写代码、甚至进行聊天。因为 &lt;code&gt;Emacs&lt;/code&gt; 其「万物皆文本」的哲学，代码是文本，笔记和待办也是，甚至文件列表或是菜单栏也是（文本定义九宫格.jpg），也借助于 &lt;code&gt;Emacs Lisp&lt;/code&gt; 的灵活性，只要你能想到有关于文字的编辑功能，你就能够去实现。&lt;/p&gt;&lt;p&gt;而且这些功能都做为一个包被 &lt;code&gt;Emacs&lt;/code&gt; 载入，所以这些功能还能进行联动，比如将待办里的任务作为电子邮件发送，将文件夹内的全文搜索结果裁剪为笔记，在笔记中嵌入可以执行的代码……因为这就是 &lt;code&gt;Emacs&lt;/code&gt; ，虽然实现的过程中可能像是在布满乐高的地板上赤脚行走，让人痛苦不堪感到沮丧，或许在 &lt;code&gt;Emacs&lt;/code&gt; 里实现还不如直接用专用软件效果来得好，但是 &lt;code&gt;Emacs&lt;/code&gt; 它就是让人产生了这样的错觉：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;我们必须实现，我们必将实现。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://nyk.ma/posts/emacs-intro/&quot;&gt;Emacs 自力求生指南 ── 前言&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org&quot;&gt;一年成为Emacs高手 (像神一样使用编辑器)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://manateelazycat.github.io/emacs/2018/12/11/study-emacs.html&quot;&gt;怎么学习 Emacs ? 达到真正融汇贯通的境界?&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>如何改变自己</title><id>https://blog.southfox.me/2022/08/如何改变自己/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2022-08-01T22:25:00Z</updated><link href="https://blog.southfox.me/2022/08/如何改变自己/.html" rel="alternate" /><content type="html">&lt;p&gt;基本就是 Kurz 的视频的梳理：&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1334y1j7DD&quot;&gt;【Kurz】如何改变自己的人生？@青知字幕组-哔哩哔哩&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=75d_29QWELk&quot;&gt;Change Your Life – One Tiny Step at a Time - Youtube&lt;/a&gt;&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreigayiupw7d5gg5pterrb3o6j4p23lyzqdn63ud3fs5ggj3tujuiya?filename=image.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;当今互联网充斥着各种成功学金句、传说和鸡汤，要是你没做成什么事，那么一切都是你的错！&lt;/p&gt;&lt;p&gt;但事实是做出改变就是一件艰难的事。&lt;/p&gt;&lt;h1 id=&quot;丛林比喻&quot;&gt;丛林比喻&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreid4btr3e35nhnzkmvwn7g3dwqjozr3qgxi4iyxrhiucuefm4uv5oa?filename=image.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;外部环境就像是一片错综复杂犹如迷宫般的雨林，在里面生活可是件很累的事，还需耗费大量的精力。所以经过千万年的进化，人类的大脑开始学会走捷径。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreidth26bi54ritzgzi3srdszk73jmr66b4dqd3dg3sciqhtsgtsfli?filename=image.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;所做出的每一次相同的决定，就像是在雨林中的一个位置上走了一遍，当走的次数多了，大脑就开始重视起这条路径。这条路径就开始变成了一条舒适又高效的道路了，走起这条路来那真是不带任何犹豫的……&lt;/p&gt;&lt;p&gt;如果自己想要做的事仍是一片丛林，那么有什么事已经成为高速路了呢？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;看到手机就开始下意识的解锁&lt;/li&gt;&lt;li&gt;躺床上看手机看到深夜哪怕在后半夜叹道自己今天依旧在浪费时间&lt;/li&gt;&lt;li&gt;每次到吃饭的地方总会选择同一家餐馆然后点同样的菜&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;随着年龄的增长，所建造的高速路也不断增多，所以说年纪越大越不容易改变，因为又有谁能富有强大的拓荒精神抛下高效且安全的高速路，去面对未知且危险的丛林呢？&lt;/p&gt;&lt;h1 id=&quot;例行和习惯&quot;&gt;例行和习惯&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreicp5345w6vp443dm7lwzx6su7swv5llcnzhtbqit6mujqzgjtquqi?filename=image.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;例行（惯例）是指按照一定步骤去做的事物，例如按照菜谱煮菜、初学开车等，当为一件例行投入大量时间和精力重复多次后，那么……&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreicqlnedjdzsqlthhitfrnzidshbit4jvf2qpodn2zkkpgj2tscwo4?filename=image.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;这件例行就会成为一个习惯，习惯是自然发生的，做一件习惯的事不用说服自己，因为……它就是习惯。例如上十年经验的开车、解锁手机并打开某一个社交 APP 等。&lt;/p&gt;&lt;h2 id=&quot;幼儿和导师&quot;&gt;幼儿和导师&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreido3ak6xul5duhfc2nbo3pkwxpk2g4sod7fpe7a2rsqxz4qjtffii?filename=image.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;人们总会沉溺在自己的坏习惯中无法自拔，事后又后悔不已，那是因为习惯的背后是由一个「幼儿」所掌握，眼里只有现在马上就能得到的满足。&lt;/p&gt;&lt;p&gt;而很不幸现代社会能马上产生满足事物太多了，袋装薯片、榜上有名的 APP 。沉溺其中也不是件丢人的事，因为它们背后可是站着无数聪明才智之人，重要的是认识到通过自己的意志力战胜这些人是一件困难的事，要思考如何规避避免硬碰硬（例如寻找是否有其它可替代客户端，能否关闭推荐功能或是私人推送功能）。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreiaq253nj6nbgf6mlwdcrv2qp3oswgit62qhljxvpbd7itzrphlffa?filename=image.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;而惯例既是由一个「导师」所掌握的，需要消耗珍贵的意志力去计划并执行，意志力通常在一天内都是宝贵的不可再生资源且通常都不能提升上限（尤其对于有 ADHD 特质的人来说）。&lt;/p&gt;&lt;h2 id=&quot;我们联合！&quot;&gt;我们联合！&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreia4eg5li2opfoaacxkvi3c6yu3hxuuvbcx23e46lpomnph5nux5gq?filename=image.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;「幼儿」是亿万年生物进化路上一直伴随着我们的模块，它对于生物的生存至关重要。「导师」是人类千万年来为了适应社会活动进化出来的模块，它很高效且精妙，但也像游戏中的某些武器一样，开不了几下火就会过热。
如果需要改变自己，让「幼儿」和「导师」一起为你工作，那么「导师」该如何规划道路的路线，让「幼儿」如何能最小抵抗得为道路完成做努力……&lt;/p&gt;&lt;h3 id=&quot;专注于小目标&quot;&gt;专注于小目标&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreigz6njoj6ikeeulg63bidoty3fn4t6b4vbycjnhd3fonkmkcecroa?filename=image.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;不要让躺在待办里的事物是一件吓人的目标，应该是一件每天结束时都能感到有所进展的小目标。让「导师」制定的目标也能像「幼儿」所执行的习惯那样能感到满足感和低抵抗感。&lt;/p&gt;&lt;p&gt;比如「每天写下五张卡片笔记」或是「每天早上十个深蹲」等。&lt;/p&gt;&lt;h3 id=&quot;易于触发&quot;&gt;易于触发&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreibrke4la2t5qj7lzq6h4jk625zqnn2zzdhjwl4hze5mrngtyai34m?filename=image.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;这通常来说也是最核心的一步了，如何找到一个触发？习惯的执行需要一个触发，比如看到手机、走到一家餐馆等，而自我决定的触发通常是以闹钟为多数。&lt;/p&gt;&lt;p&gt;而对于有 ADHD 特质的人来说，能否准确地实施呢？克服 ADHD 特质最需要一个强有力的外在结构也是如此……&lt;/p&gt;&lt;p&gt;营造一个专用的环境和空间大概有助于此，比如划分出一个专门做这件事的空间，并好好整理一下周围的杂物（杂乱的事物将导致分心的几率大大增加），划分出专门娱乐和学习专用空间（即使缺乏空间也可以在虚拟意义上实现，比如安装两个浏览器，并尽量让自己在学习时只能用专用浏览器）。&lt;/p&gt;&lt;h3 id=&quot;每天重复&quot;&gt;每天重复&lt;/h3&gt;&lt;p&gt;最难的一步，要让例行转为习惯那需要 15~250 天的时间，很多时候坚持不下来就会让一切照旧……还要加上一些自暴自弃的情绪……&lt;/p&gt;&lt;h3 id=&quot;改进&quot;&gt;改进&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreigronwruqfwukkhsimsbnlfw6q2mxbeymrib6bsxilgtqyxst2pue?filename=image.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;在实行的过程也并不是苦修，得尽量让做事的自己少点抵抗，例如放点喜欢的音乐，在跑步时听自己最喜欢的博客等。&lt;/p&gt;&lt;h1 id=&quot;结语&quot;&gt;结语&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreiab7e4ivqewy2kfjvz3kofwh7pf3coax5z27tx6u2xvs7h2wwti4q?filename=image.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;&lt;p&gt;哪怕只是做出了微小的改变，也是往理想的自己靠近一步，改进没有终点，只有方向。&lt;/p&gt;</content></entry><entry><title>Gitea:一款自托管的 Git 服务</title><id>https://blog.southfox.me/2022/07/Gitea:一款自托管的-Git-服务/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2022-07-17T19:02:00Z</updated><link href="https://blog.southfox.me/2022/07/Gitea:一款自托管的-Git-服务/.html" rel="alternate" /><content type="html">&lt;p&gt;别忘了泡上一杯茶！&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;h2 id=&quot;绕不开的存在&quot;&gt;绕不开的存在&lt;/h2&gt;&lt;p&gt;当然，谈到 &lt;code&gt;Git&lt;/code&gt; 服务时，肯定绕不过 &lt;code&gt;GitHub&lt;/code&gt; 。为什么要大费周章自建呢？&lt;code&gt;GitHub&lt;/code&gt; 不好吗？&lt;/p&gt;&lt;p&gt;是很好，但是也没那么好，因为：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;GitHub&lt;/code&gt; 是一家商业公司，那么首先盈利肯定是首要目的，为了不倒闭，指不准未来哪天就变质了。&lt;/li&gt;&lt;li&gt;同上，如果还是个自由软件爱好者的话，想必 &lt;code&gt;GitHub&lt;/code&gt; 最近一些事件带来的臭味也不必我再提了……&lt;/li&gt;&lt;li&gt;&lt;code&gt;Git&lt;/code&gt; 是分布式的，那么选择同样也是……不知道现在还有多少人还傻傻认为 &lt;code&gt;Git&lt;/code&gt; 和 &lt;code&gt;GitHub&lt;/code&gt; 是一体的呢？&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也可参见 &lt;a href=&quot;https://sfconservancy.org/GiveUpGitHub/&quot;&gt;GiveUpGitHub&lt;/a&gt; 一文章。&lt;/p&gt;&lt;h2 id=&quot;Gitea&quot;&gt;Gitea&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Gitea&lt;/code&gt; 是一个用 &lt;code&gt;Go&lt;/code&gt; 编写、面向自建的、轻量级的 &lt;code&gt;Git&lt;/code&gt; 服务。其安装十分便捷，直接下载个可执行文件也可快速搭建起来，当然为了后续跟其它服务联动，还是用 &lt;code&gt;docker-compose&lt;/code&gt; 方便点。&lt;/p&gt;&lt;p&gt;话不多说，新建一个文件夹然后往里建 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件并写入以下配置：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;version: &amp;quot;3.7&amp;quot;

services:
  gitea:
    image: gitea/gitea:latest
    container_name: gitea
    restart: unless-stopped
    environment:
      - USER_UID=1000
      - USER_GID=1000
    volumes:
      - ./data/gitea:/data
      - /etc/timezone:/etc/timezone:ro
      - /etc/localtime:/etc/localtime:ro
    ports:
      - &amp;quot;127.0.0.1:3000:3000&amp;quot;
      - &amp;quot;2222:22&amp;quot;
    networks:
      - cicd_net

  drone:
    container_name: drone
    image: drone/drone:latest
    restart: unless-stopped
    depends_on:
      - gitea
    environment:
      # https://docs.drone.io/server/provider/gitea/
      - DRONE_DATABASE_DRIVER=sqlite3
      - DRONE_DATABASE_DATASOURCE=/data/database.sqlite
      - DRONE_GITEA_SERVER=https://my.git.server/
      - DRONE_GIT_ALWAYS_AUTH=false
      - DRONE_RPC_SECRET=changeme...
      - DRONE_SERVER_PROTO=https
      - DRONE_SERVER_HOST=https://cicd.git.server
      - DRONE_GITEA_CLIENT_ID=changeme...
      - DRONE_GITEA_CLIENT_SECRET=changeme...
    ports:
      - &amp;quot;127.0.0.1:3001:80&amp;quot;
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./data/drone:/data
    networks:
      - cicd_net

  drone-runner:
    container_name: drone-runner
    image: drone/drone-runner-docker:latest
    restart: unless-stopped
    depends_on:
      - drone
    environment:
      # https://docs.drone.io/runner/docker/installation/linux/
      # https://docs.drone.io/server/metrics/
      - DRONE_RPC_PROTO=http
      - DRONE_RPC_HOST=drone
      - DRONE_RPC_SECRET=changeme...
      - DRONE_RUNNER_NAME=&amp;quot;action-runner&amp;quot;
      - DRONE_RUNNER_CAPACITY=2
      - DRONE_RUNNER_NETWORKS=cicd_net
      - DRONE_DEBUG=false
      - DRONE_TRACE=false
    networks:
      - cicd_net
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock

networks:
  cicd_net:
    name: cicd_net&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为预想场景是私人自用，所以选择了 &lt;code&gt;SQlite3&lt;/code&gt; 数据库，觉得别扭可以自己改掉……&lt;/p&gt;&lt;p&gt;然后准备两个域名，这里用 &lt;code&gt;my.git.server&lt;/code&gt; 域名指定用来运行 &lt;code&gt;Gitea&lt;/code&gt; 服务的域名，一个 &lt;code&gt;cicd.git.server&lt;/code&gt; 域名用来指定运行后续的自动构建服务的域名（可选）。&lt;/p&gt;&lt;p&gt;首先为 &lt;code&gt;my.git.server&lt;/code&gt; 域名设定&lt;code&gt;DNS&lt;/code&gt; 后申请证书，&lt;code&gt;certbot certonly --nginx -d my.git.server&lt;/code&gt;&lt;/p&gt;&lt;p&gt;，申请后写入 &lt;code&gt;nginx&lt;/code&gt; 配置：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-nginx&quot;&gt;#不要忘了替换成自己的域名
server {
    listen 80;
    listen [::]:80;
    server_name my.git.server;

    location /.well-known/acme-challenge {}
    location / {
        return 301 https://$host$request_uri;
    }
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name my.git.server;

    access_log  /var/log/nginx/access.log;
    #root /home/plume/Plume/ ;

    ssl_certificate /etc/letsencrypt/live/my.git.server/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/my.git.server/privkey.pem;

    # for ssl conf: https://cipherli.st/
    ssl_protocols TLSv1.2 TLSv1.3;# Requires nginx &amp;gt;= 1.13.0 else use TLSv1.2
    ssl_prefer_server_ciphers on;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;# openssl dhparam -out /etc/letsencrypt/ssl-dhparam.pem 4096
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384;
    ssl_ecdh_curve secp384r1; # Requires nginx &amp;gt;= 1.1.0
    ssl_session_timeout  10m;
    ssl_session_cache shared:SSL:10m;
    ssl_session_tickets off; # Requires nginx &amp;gt;= 1.5.9
    ssl_stapling on; # Requires nginx &amp;gt;= 1.3.7
    ssl_stapling_verify on; # Requires nginx =&amp;gt; 1.3.7
    resolver 9.9.9.9 80.67.169.12 valid=300s;
    resolver_timeout 5s;
    add_header Strict-Transport-Security &amp;quot;max-age=63072000; includeSubDomains; preload&amp;quot;;
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection &amp;quot;1; mode=block&amp;quot;;
    #如果不想显示外链图片可把 img-src 一栏改掉
    add_header Content-Security-Policy &amp;quot;default-src 'self'; img-src *; frame-ancestors 'self'; frame-src https:&amp;quot;;

    location / {
        proxy_pass http://localhost:3000/;
        proxy_set_header Host $http_host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        client_max_body_size 50m;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后 &lt;code&gt;nginx -s reload&lt;/code&gt; 重载配置，然后 &lt;code&gt;docker-compose up -d gitea&lt;/code&gt; 把 &lt;code&gt;Gitea&lt;/code&gt; 服务启动，之后前往 &lt;code&gt;my.git.server&lt;/code&gt; 地址进行配置并新建一个管理员账户。&lt;/p&gt;&lt;h3 id=&quot;Drone&quot;&gt;Drone&lt;/h3&gt;&lt;p&gt;到此服务就基本可用了，但是我相信很多人割舍不下 &lt;code&gt;GitHub&lt;/code&gt; 的一个原因就是因为它的 &lt;code&gt;Actions&lt;/code&gt; 很香。不过可以选择 &lt;code&gt;Drone&lt;/code&gt; ，一个同样用 &lt;code&gt;GO&lt;/code&gt; 编写的、轻量级的自动构建服务，也可以让体验往 &lt;code&gt;GitHub Actions&lt;/code&gt; 靠拢。&lt;/p&gt;&lt;p&gt;首先为 &lt;code&gt;cicd.git.server&lt;/code&gt; 域名申请证书并写入 &lt;code&gt;nginx&lt;/code&gt; 配置文件，配置文件可复用上面的，只需要更改相关域名和 &lt;code&gt;nginx&lt;/code&gt; 配置文件里的 &lt;code&gt;location /&lt;/code&gt; 里的 &lt;code&gt;proxy_pass&lt;/code&gt; 端口号就行（本例子是 &lt;code&gt;3001&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;之后为 &lt;code&gt;Drone&lt;/code&gt; 和 &lt;code&gt;Gitea&lt;/code&gt; 联动做准备，登陆自己 &lt;code&gt;Gitea&lt;/code&gt; 实例的帐号→设置→应用→创建新的 OAuth2 应用程序，应用名称随意填（本例子填 drone），重定向 URI 填入 &lt;code&gt;https://cicd.git.server/login&lt;/code&gt; （替换成自己的域名）。&lt;/p&gt;&lt;p&gt;点击创建应用→会生成一个客户端 ID 和一个客户端密钥→替换到上述 &lt;code&gt;docker-compose.yml&lt;/code&gt; 里 &lt;code&gt;drone&lt;/code&gt; 一栏的 &lt;code&gt;DRONE_GITEA_CLIENT_ID&lt;/code&gt; 和 &lt;code&gt;DRONE_GITEA_CLIENT_SECRET&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;之后再使用 &lt;code&gt;openssl rand -hex 16&lt;/code&gt; 命令生成一串随机字符串给 &lt;code&gt;DRONE_RPC_SECRET&lt;/code&gt; 使用（有两个地方需要替换）。&lt;/p&gt;&lt;p&gt;确认无误后使用 &lt;code&gt;docker-compose up -d&lt;/code&gt; 启动全部服务，之后前往 &lt;code&gt;https://cicd.git.server&lt;/code&gt; 地址查看是否正常运行，是的话点击登陆，看是否能够和 &lt;code&gt;Gitea&lt;/code&gt; 进行联动，如果显示错误请检查是否与上述配置一致（例如我之前就遇到了无法验证的错误，排查后发现是某个路径多带了一个 &lt;code&gt;/&lt;/code&gt; 导致之后生成的验证路径出错，去掉 &lt;code&gt;/&lt;/code&gt; 之后就正常了）。&lt;/p&gt;&lt;h3 id=&quot;仓库操作&quot;&gt;仓库操作&lt;/h3&gt;&lt;p&gt;因为宿主机的 &lt;code&gt;22&lt;/code&gt; 端口已被占用，所以克隆或者 &lt;code&gt;PUSH&lt;/code&gt; 仓库使用的端口应该为 &lt;code&gt;2222&lt;/code&gt;，觉得别扭也有其他教程教如何与宿主机共用端口，我就不折腾了（反正 &lt;code&gt;Just work!&lt;/code&gt; ）。&lt;/p&gt;&lt;p&gt;还有如果为网站使用了 &lt;code&gt;Cloudflare&lt;/code&gt; 之类的 &lt;code&gt;CDN&lt;/code&gt; 服务的话，那么 &lt;code&gt;SSH&lt;/code&gt; 协议也是不能用的，得用网站域名下的真实 &lt;code&gt;IP&lt;/code&gt; 地址克隆或 &lt;code&gt;PUSH&lt;/code&gt; 仓库。&lt;/p&gt;&lt;p&gt;如果像我什么都没改的话，想要克隆仓库就会得到这么一个奇怪的地址：&lt;/p&gt;&lt;p&gt;&lt;code&gt;git clone ssh://git@机子真实IP:2222/用户名/仓库名.git&lt;/code&gt;&lt;/p&gt;&lt;p&gt;反正 &lt;code&gt;Just work&lt;/code&gt;  ！&lt;/p&gt;&lt;h3 id=&quot;一个案例&quot;&gt;一个案例&lt;/h3&gt;&lt;p&gt;那么接下来就讲讲我用这套服务的案例吧，自动生成文件并推送一个 &lt;code&gt;HUGO&lt;/code&gt; 博客。&lt;/p&gt;&lt;p&gt;首先为仓库根目录写下 &lt;code&gt;.drone.yml&lt;/code&gt; 文件：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;kind: pipeline
name: build

steps:
- name: build
  image: klakegg/hugo:alpine
  commands:
  - hugo

- name: deploy
  image: node
  environment:
    CLOUDFLARE_API_TOKEN:
      from_secret: api_token
    CLOUDFLARE_ACCOUNT_ID:
      from_secret: account_id
  commands:
  - npm install -g wrangler
  - npx wrangler pages publish public --project-name 项目名 --commit-dirty=true&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以见到和 &lt;code&gt;GitHub Actions&lt;/code&gt; 的配置还是挺像的，琢磨琢磨还是挺快上手的。&lt;/p&gt;&lt;p&gt;其中 &lt;code&gt;steps&lt;/code&gt; 指定了所需步骤，&lt;code&gt;image&lt;/code&gt; 指定了需要什么样的 &lt;code&gt;docker&lt;/code&gt; 镜像，第一栏拉取了 &lt;code&gt;klakegg/hugo&lt;/code&gt; 镜像并使用 &lt;code&gt;hugo&lt;/code&gt; 命令生成静态文件。&lt;/p&gt;&lt;p&gt;之后是 &lt;code&gt;deploy&lt;/code&gt; 一栏里的 &lt;code&gt;environment&lt;/code&gt; ，像 &lt;code&gt;GitHub&lt;/code&gt; 一样，密钥相关可以使用 &lt;code&gt;secret&lt;/code&gt; 功能导入到环境变量中，可在自己的 &lt;code&gt;cicd.git.server&lt;/code&gt; →相关仓库→ &lt;code&gt;Settings&lt;/code&gt; → &lt;code&gt;Secrets&lt;/code&gt; 里进行导入。&lt;/p&gt;&lt;p&gt;接下来使用 &lt;code&gt;node&lt;/code&gt; 镜像安装了个 &lt;code&gt;wrangler&lt;/code&gt; 包，这是 &lt;code&gt;Cloudflare Pages&lt;/code&gt; 部署要用的，如果也用 &lt;code&gt;Cloudflare Pages&lt;/code&gt; 部署的话可以参考:&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://developers.cloudflare.com/workers/wrangler/commands/#pages&quot;&gt;Wrangler pages commands&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://developers.cloudflare.com/workers/wrangler/ci-cd/&quot;&gt;Running Wrangler in CI/CD&lt;/a&gt;&lt;/p&gt;&lt;p&gt;PS：不得不吐槽相关操作首先必须要用 &lt;code&gt;project create&lt;/code&gt; 命令里的 &lt;code&gt;--production-branch&lt;/code&gt; 显式指定部署分支否则接下来的部署都会被识别为预览而不会真正部署到……被这个坑卡了好一会……&lt;/p&gt;&lt;p&gt;之后再进行相关操作后应该能看见自己 &lt;code&gt;Gitea&lt;/code&gt; 实例也有小绿勾了（小红叉也行，至少证实自动部署服务有在用了）！&lt;/p&gt;&lt;h3 id=&quot;加主题&quot;&gt;加主题&lt;/h3&gt;&lt;p&gt;默认主题还挺程序员风格的，既然都自建了，肯定要加点主题快乐一下了。&lt;/p&gt;&lt;p&gt;以&lt;a href=&quot;https://codeberg.org/Freeplay/Gitea-Modern/&quot;&gt;现代主题&lt;/a&gt;为例。&lt;/p&gt;&lt;p&gt;如果是以上面的配置文件搭建起来的话要在自己文件夹下找到 &lt;code&gt;./data/gitea/gitea&lt;/code&gt; 路径，并在里头新建 &lt;code&gt;public/css&lt;/code&gt; 下 &lt;code&gt;wget https://codeberg.org/Freeplay/Gitea-Modern/raw/branch/main/Gitea/theme-gitea-modern.css&lt;/code&gt;  获取主题文件。&lt;/p&gt;&lt;p&gt;之后再编辑 &lt;code&gt;./data/gitea/gitea/conf/app.ini&lt;/code&gt; 文件，在最后面加上：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-ini&quot;&gt;请自己想象下……
因为现在我服务器炸了……&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后再用 &lt;code&gt;docker-compose down&lt;/code&gt;  和 &lt;code&gt;docker-compose up -d&lt;/code&gt; 重启服务。&lt;/p&gt;&lt;h3 id=&quot;安全&quot;&gt;安全&lt;/h3&gt;&lt;p&gt;如果没有相关要求，请务必关闭实例的注册功能。&lt;/p&gt;&lt;p&gt;参见，&lt;a href=&quot;https://imlonghao.com/59.html&quot;&gt;记一次自建 Gitea + Drone 实例被挖矿的经历&lt;/a&gt;&lt;/p&gt;&lt;p&gt;也是修改 &lt;code&gt;./data/gitea/gitea/conf/app.ini&lt;/code&gt; 里的：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-ini&quot;&gt;请自己查阅……
因为我现在服务器炸了&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后再用 &lt;code&gt;docker-compose down&lt;/code&gt;  和 &lt;code&gt;docker-compose up -d&lt;/code&gt; 重启服务，然后再检查站点是否关闭了注册入口。&lt;/p&gt;&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://blog.ruanbekker.com/blog/2021/03/09/cicd-with-droneci-and-gitea-using-docker-compose/&quot;&gt;CICD With DroneCI and Gitea Using Docker Compose&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://docs.gitea.io/en-us/&quot;&gt;Gitea Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://docs.drone.io/&quot;&gt;Drone Docs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://tech.ray247k.com/blog/202106-drone-cicd-3-advanced-cron-job/&quot;&gt;透過 Drone 建立自動部署流程，部署排程設定與權限管理 - 薛丁格的工程師&lt;/a&gt;&lt;/p&gt;</content></entry><entry><title>二二年六月梦记</title><id>https://blog.southfox.me/2022/06/二二年六月梦记/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2022-06-14T18:09:00Z</updated><link href="https://blog.southfox.me/2022/06/二二年六月梦记/.html" rel="alternate" /><content type="html">&lt;p&gt;能做梦说明我是终于有睡饱了……&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;h2 id=&quot;6-14中&quot;&gt;6-14 中&lt;/h2&gt;&lt;h3 id=&quot;预兆&quot;&gt;预兆&lt;/h3&gt;&lt;p&gt;我在一个广场上，一些人就站在其中，广场中间有一个大号喷泉。
我跟着某个人去见……某个人……那个人一见我就立马用手搓着我的脸，我回应了几句，期间他嘴里漏出了几句中文。我问到，你懂中文？
他回应道：“我爷爷后半辈子在太原生活。”
然后他又仔细端详着我的脸，我说：“看相不应该是南方盛行的东西吗？”，他只打了个哈哈就应付过去了。看完相后，他拉着我走起了步伐，不像跳舞，像是……禹步？但是我还是有时像跳舞一样被他一手用手拉着。结束后，他大声疾呼：“大干旱，大旱灾之象啊！”，然后就跑开了。
我只觉得他的语言有点神经，八亿年之久的大干旱？比几百万年的卡尼期洪积事件还要离谱哩，望着广场喷涌的喷泉，我这样想到……&lt;/p&gt;&lt;h3 id=&quot;干旱来临&quot;&gt;干旱来临&lt;/h3&gt;&lt;p&gt;随后就是旱灾来临了，倒是都是躺下的人，可能还有几个还能哀嚎，其他人已经毫无动静了……广场中间的喷泉早已干涸，或许只有中间的泥土还保有几丝湿润。喷泉中躺倒着一人，我望向他，就似乎看到了当时的景象——别死在喷泉里！会污染的！会污染的！滚出去……
我只想找到那个预言家，他去哪儿了？&lt;/p&gt;&lt;h3 id=&quot;幕后&quot;&gt;幕后&lt;/h3&gt;&lt;p&gt;巨大的六角形机器浮在空中，然后一道细小的白光闪了出去，打向不远处的另一个六角形，但是一道强光爆发出来，把白光弹回了原六角形处……
一个类似控制式的地方……屏幕亮了起来。
“我们已知晓你所做的破坏活动！还接连破坏了七个地区……严惩……”
然后似乎被某人关掉了，那人连线上了另外一个人，另一个人似乎类似鳄鱼，但是脸确有像阶梯状，非常古怪。控制室内的人叫鳄鱼人把身份信息发过来好进行伪装，说是要这样才能糊弄过那些追查过来的人，看起来那鳄鱼人是什么纳税大户吗？&lt;/p&gt;</content></entry><entry><title>Magit使用随记暨Emacs随记（3）</title><id>https://blog.southfox.me/2022/06/magit使用随记暨Emacs随记（3）/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2022-06-08T14:38:00Z</updated><link href="https://blog.southfox.me/2022/06/magit使用随记暨Emacs随记（3）/.html" rel="alternate" /><content type="html">&lt;p&gt;&lt;code&gt;magit&lt;/code&gt; 是个好东西。&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;p&gt;&lt;code&gt;Magit&lt;/code&gt; 是一个 &lt;code&gt;Emacs&lt;/code&gt; 的包，将一大堆长又长的 &lt;code&gt;Git&lt;/code&gt; 指令封装成了按键操作，对于受够了了在终端下按够了 &lt;code&gt;TAB&lt;/code&gt; 键的人来说，是一种解放，无怪 &lt;code&gt;Magit&lt;/code&gt; 的评价在整个 &lt;code&gt;Emacs&lt;/code&gt; 生态里评价那么好了。&lt;/p&gt;&lt;h2 id=&quot;Git&quot;&gt;Git&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Magit&lt;/code&gt; 是建立在 &lt;code&gt;Git&lt;/code&gt; 上的，意味着要使用得先对 &lt;code&gt;Git&lt;/code&gt; 有一定了解，&lt;a href=&quot;https://book.douban.com/subject/27133267/&quot;&gt;Pro Git&lt;/a&gt; 是一本不错的入门书，而且做为一本「开源」书籍，也很容易在网上找到可在线浏览的方式。&lt;/p&gt;&lt;h3 id=&quot;奇怪比喻&quot;&gt;奇怪比喻&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Git&lt;/code&gt; 的精髓在于它的设计，工作区、暂存区以及版本库，用 &lt;code&gt;Git&lt;/code&gt; 进行工作一般如下所示（图出自 Pro Git）。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreidcpqxgpknpmc5nmtjqzulncjwfdauiorlt6lcggxfswjh36rjelq&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;&lt;p&gt;用小学生写作业做比喻的话，草稿纸即是工作区，做好相关计算后把结果誊抄到作业本上，作业本既是暂存区（&lt;code&gt;Index&lt;/code&gt;、&lt;code&gt;Stage&lt;/code&gt;），最后确认无误后即可把作业本放入书包，书包既是版本库了。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Git&lt;/code&gt; 的设计给了使用者操作上的灵活，却也让人感到冗长，设置别名可以缓解这种情况，不过还是没有优化到单键操作的 &lt;code&gt;Magit&lt;/code&gt; 偷懒偷得多。&lt;/p&gt;&lt;h2 id=&quot;Magit&quot;&gt;Magit&lt;/h2&gt;&lt;h3 id=&quot;一般流程&quot;&gt;一般流程&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;Doom Emacs&lt;/code&gt; 下，使用 &lt;code&gt;SPC g g&lt;/code&gt; 即可选择一个 &lt;code&gt;Git&lt;/code&gt; 仓库（如果已经打开了一个 &lt;code&gt;Git&lt;/code&gt; 仓库的的文件即可直接打开当前仓库下的 &lt;code&gt;Magit&lt;/code&gt; 界面）打开 &lt;code&gt;Magit&lt;/code&gt; 界面。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreiele2ihm55y4rbemvz4dojlnukapibj4zn5isssj2x5huqsq76qdq&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;&lt;p&gt;在 &lt;code&gt;Magit&lt;/code&gt; 界面下，可以很方便看到工作区发生变动的文件（Unstaged changes），以及已经加入到暂存区的文件（Staged changes）。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreicttv7rkuzq5ishn6x3lix4rwdtkka7dubm5rjh67teehgcbh7nzy&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;&lt;p&gt;光标在某个文件上时，按下 &lt;code&gt;TAB&lt;/code&gt; 即可展示文件的变动，按下回车即可直接跳转到文件进行编辑，按下 &lt;code&gt;s&lt;/code&gt; 即可将文件暂存，对处于暂存区文件按下 &lt;code&gt;u&lt;/code&gt; 即可取消暂存（&lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 则是应用于全体文件）。忘掉 &lt;code&gt;git add xxx&lt;/code&gt; 吧，谁会怀念它？&lt;/p&gt;&lt;p&gt;确认暂存区的改动后即可进行提交（commit）将其送入版本库了，对应的快捷键是 &lt;code&gt;c&lt;/code&gt;，对于很多复杂的 &lt;code&gt;Git&lt;/code&gt; 操作附带了很多选项来完成，&lt;code&gt;Magit&lt;/code&gt; 把能用的操作都罗列了出来，做到了看菜下饭。&lt;/p&gt;&lt;p&gt;对于提交（commit） 操作，其里面常用的有：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;- s&lt;/code&gt; 或 &lt;code&gt;- S&lt;/code&gt; 附上签名消息或使用 &lt;code&gt;GPG&lt;/code&gt; 进行签名认证。&lt;/li&gt;&lt;li&gt;&lt;code&gt;c&lt;/code&gt; 进行 &lt;code&gt;commit&lt;/code&gt; 操作，之后会打开一个新区域输入消息，输入完毕后用 &lt;code&gt;C-c C-c&lt;/code&gt; 进行确认（&lt;code&gt;C-c C-k&lt;/code&gt; 为取消提交）。&lt;/li&gt;&lt;li&gt;&lt;code&gt;a&lt;/code&gt; 进行 &lt;code&gt;--amend&lt;/code&gt; 操作，即为重新进行提交操作，适用于提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了的情况。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;实际用习惯了之后基本就是无脑操作了，比如使用 &lt;code&gt;p p&lt;/code&gt; 快捷键，即可直接推送到默认的分支上，如果要进行其他操作比如推送到其他分支上，那么按一下 &lt;code&gt;p&lt;/code&gt; 之后再看信息提示进行操作也不会太难。&lt;/p&gt;&lt;p&gt;对于更多操作，按下 &lt;code&gt;?&lt;/code&gt; 即可进入提示菜单，或是翻阅 &lt;code&gt;Magit&lt;/code&gt; 的&lt;a href=&quot;https://magit.vc/manual/magit.html&quot;&gt;手册&lt;/a&gt;了解更多操作。&lt;/p&gt;&lt;h3 id=&quot;从实战到跑路&quot;&gt;从实战到跑路&lt;/h3&gt;&lt;p&gt;现在来说说我拿 &lt;code&gt;Magit&lt;/code&gt; 实际干过的事吧，&lt;/p&gt;&lt;p&gt;首先是要心动，看上了其他分支的功能，打算抄抄作业，那么第一件事就是把对方仓库克隆下来。在 &lt;code&gt;Magit&lt;/code&gt; 界面按下 &lt;code&gt;M&lt;/code&gt; 即可进入 &lt;code&gt;Remote&lt;/code&gt; 界面，按下 &lt;code&gt;a&lt;/code&gt; 添加，输入名称以及仓库地址来添加一个 &lt;code&gt;Remote&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;接着开始检索对方仓库的提交，检出自己需要的提交，按下 &lt;code&gt;l&lt;/code&gt; 打开 &lt;code&gt;log&lt;/code&gt; 界面，按下 &lt;code&gt;- F&lt;/code&gt; 搜索提交消息，之后输入想检索的提交消息，例如 &lt;code&gt;exclusive list&lt;/code&gt;，再按下 &lt;code&gt;o&lt;/code&gt; ，选择搜索其他（other）分支的历史记录，选择之前添加的 &lt;code&gt;Remote&lt;/code&gt; 仓库的分支。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreiduuqcpezsvunsggij4gfahdn53kxiacwewsbmciglk62v44yoane&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;&lt;p&gt;可以看到搜索出了相关的三条结果，从最旧的开始合并，将光标移动到最旧的提交，按下 &lt;code&gt;A A&lt;/code&gt; 进行一次 &lt;code&gt;cherry-pick&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreifkslyzgyvcm5zkapevoxkrnkdubh7uwbwwjjpjrkmwur43k4ji7i&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;&lt;p&gt;啊啊啊……！一大堆冲突，毕竟这次的提交很老旧了，是三年前的提交，发生变化很正常……&lt;/p&gt;&lt;p&gt;感叹一句没有银弹，&lt;code&gt;Git&lt;/code&gt; 对于冲突也从不僭越，会去自作主张搞定。所以只能自己上了，对于这种老旧的提交，可以前去 &lt;code&gt;GitHub&lt;/code&gt; 的那次提交消息里查看改动了哪些文件，再前去最新版本文件下仔细比对最新的样子是什么。当然 &lt;code&gt;Magit&lt;/code&gt; 同时也提供了一个命令 &lt;code&gt;magit-log-buffer-file&lt;/code&gt;（&lt;code&gt;SPC g L&lt;/code&gt;）查看当前文件下有那些提交，&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreied5lnnuofc7isxw3ufrg6j7gbs4ptzs27pkuxq54tcicnltl3k5e&quot; alt=&quot;检出更改&quot; /&gt;&lt;/p&gt;&lt;p&gt;不过用这种方式查看双方提交记录的话，得先 &lt;code&gt;Stash&lt;/code&gt; 修改再切换到对方分支查看历史记录又切换回来，感觉挺麻烦……所以我就先用 &lt;code&gt;GitHub&lt;/code&gt; 查看历史了，或许有更快速方便的方法？&lt;/p&gt;&lt;p&gt;总之，确定该怎样合并后即可进入 &lt;code&gt;Unstaged changes&lt;/code&gt; 上的任一文件按下 &lt;code&gt;E&lt;/code&gt; 打开 &lt;code&gt;Ediff&lt;/code&gt; 选单，再按下 &lt;code&gt;m&lt;/code&gt; 解决冲突。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreie5it6wivelcnp63l34epa377lijrksptmodz7nwsb7325n4g4zsq&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;&lt;p&gt;进入冲突选单后，用 &lt;code&gt;n&lt;/code&gt; 键跳转到下一冲突处（&lt;code&gt;p&lt;/code&gt; 为上一个），接着按下 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 选择保留那一方的修改，这次的提交要结合两者，所以首先选择一方，然后用 &lt;code&gt;SPC w k&lt;/code&gt; 将焦点移动到上方文件编辑区进行编辑，编辑完后再用 &lt;code&gt;SPC w j&lt;/code&gt; 将焦点移回 &lt;code&gt;Ediff&lt;/code&gt; 区。处理完全部冲突后，按下 &lt;code&gt;q&lt;/code&gt; 退出，再处理其他文件的冲突。&lt;/p&gt;&lt;p&gt;处理完全部冲突后，按下 &lt;code&gt;c c&lt;/code&gt; 进行一次提交，之后按下 &lt;code&gt;p p&lt;/code&gt; 推送到 &lt;code&gt;GitHub&lt;/code&gt; 上，祈祷部署能够成功吧！&lt;/p&gt;&lt;p&gt;如果想要合并的提交不是那么久远的话，可以用 &lt;code&gt;Y&lt;/code&gt; 按键对应的 &lt;code&gt;Cherries&lt;/code&gt; 操作来检出自己想要的提交，虽然我没用过（&lt;/p&gt;</content></entry><entry><title>我拿Emacs做什么暨Emacs随记（2）</title><id>https://blog.southfox.me/2022/05/我拿Emacs做什么暨Emacs随记（2）/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2022-05-14T17:34:00Z</updated><link href="https://blog.southfox.me/2022/05/我拿Emacs做什么暨Emacs随记（2）/.html" rel="alternate" /><content type="html">&lt;p&gt;大概也算是卡片笔记法的介绍？&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;提醒&lt;/strong&gt;：本文作者用上下列的方法也不是很久，甚至这篇文章还能算做第一个正式产出，所以……请谨慎判断。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;卡片笔记&quot;&gt;卡片笔记&lt;/h2&gt;&lt;h3 id=&quot;卡片笔记法解决了什么？&quot;&gt;卡片笔记法解决了什么？&lt;/h3&gt;&lt;p&gt;在空白处写涂涂写写、划重点、摘抄、不断翻阅资料，但是最后感觉还是学废了，到头来还是什么也没学到，或者记了一大堆笔记但是却成了一个坟墓，每次到里面想要提取点东西简直痛不欲生……&lt;/p&gt;&lt;p&gt;因为不断的阅读书籍并没有对学习产生帮助，反而因为&lt;strong&gt;曝光效应&lt;/strong&gt;而更有害（曝光效应：当我们熟悉某事物的时候，我们还会对其越发喜欢，相信自己理解了，&lt;strong&gt;但是熟悉不等同于理解&lt;/strong&gt;）。&lt;/p&gt;&lt;p&gt;卡片笔记法就是针对这种情况而产生的。&lt;/p&gt;&lt;h3 id=&quot;卡片笔记法该怎么做？&quot;&gt;卡片笔记法该怎么做？&lt;/h3&gt;&lt;p&gt;我目前所使用的工作流是这样的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;阅读材料，写下关键词或者想法和页数。（闪念笔记）&lt;/li&gt;&lt;li&gt;结束阅读后，通过关键词重构当时的话语，并通过页数返回当时的段落，对照着材料&lt;strong&gt;转写&lt;/strong&gt;成自己的话语录入到笔记系统中。（文献笔记）&lt;/li&gt;&lt;li&gt;当天结束前，浏览自己的所写的文献笔记，思考它能和自己的课题、兴趣、兴趣有何关联。（永久笔记）&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;闪念笔记&quot;&gt;闪念笔记&lt;/h4&gt;&lt;p&gt;闪念笔记可以……在任何地方开记，餐巾纸、手机、记事本等，只是写下几个关键字而已，并标上页数，结束完阅读后，再通过关键词思索当时的想法，之后通过页数方便返回对照材料。&lt;/p&gt;&lt;p&gt;此举是为了增加想法的&lt;strong&gt;必要难度&lt;/strong&gt;，边阅读、边听课、边看视频边记笔记实在太简单，就像在沙地上浅浅地写字一样，太容易模糊了……而通过记下关键词和页数，再回忆起当时所想记的，这样（大概）就提升了想法的&lt;strong&gt;存储强度&lt;/strong&gt;。&lt;/p&gt;&lt;h4 id=&quot;文献笔记&quot;&gt;文献笔记&lt;/h4&gt;&lt;p&gt;文献笔记最重要的是用&lt;strong&gt;自己的话&lt;/strong&gt;简洁得写下阅读材料中的观点。&lt;/p&gt;&lt;p&gt;之所以强迫用自己的话转写，是因为只有这样做才能更好地理解材料里的观点，一味摘抄是不行的……&lt;/p&gt;&lt;h4 id=&quot;永久笔记&quot;&gt;永久笔记&lt;/h4&gt;&lt;p&gt;永久笔记是通过浏览前几步写下的笔记所产生的，卡片笔记盒的思想就是：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;一个想法或者笔记只有在它的上下文才有意义，而它的上下文不一定是它在文章中的出处。所以卡片笔记法是要让笔记与不同上下文聚集起来并起到相应的作用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;其中永久笔记应该是&lt;strong&gt;原子化&lt;/strong&gt;的，即应该在没有上下文的情况下也能解释的清楚，这样才能更好的和其他相同的笔记组合成「分子」、「复杂化合物」。&lt;/p&gt;&lt;p&gt;所以为了更好地产生想法，每天划出一部分时间是去回顾是必要的（当然我也老是忘掉）。&lt;/p&gt;&lt;h3 id=&quot;Carryon!&quot;&gt;Carry on!&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;简单，简单，简单啊！我说，最好你的事只两件或三件，不要一百件或一千件；不必计算一百万，半打不是够计算了吗，总之，账目可以记在大拇指甲上就好了。不必一天三餐，如果必要，一顿也够了；不要百道菜，五道够多了； -- 《瓦尔登湖》&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;卡片笔记法并不复杂，实践起来只要选用一个专门对此进行优化过的软件就好了，&lt;code&gt;Notion&lt;/code&gt;、&lt;code&gt;obsidian&lt;/code&gt;、&lt;code&gt;org-roam&lt;/code&gt; 等都可以，我选用的是基于 &lt;code&gt;Emacs&lt;/code&gt; 的 &lt;code&gt;org-roam&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;过于复杂的工作流会马上消磨掉自己的耐心，而做事从来不能凭着虚无缥缈的「专注力」去完成，同时卡片笔记法所产生的笔记也让我觉得能在实实在在的做了某事，这样在对抗「不确定性」这一大怪兽面前也能有底气几分。&lt;/p&gt;&lt;p&gt;卡片笔记法也不是什么银弹，不能指望换用软件就能产生很好的效果，比如说卡片笔记法里重要的一点既是用自己的话去转写阅读材料的话语，没了解这一点，换软件后还把软件当成原文摘抄、文章剪辑之地，那么无非是又造了个坟墓，只不过是卡片式的。&lt;/p&gt;&lt;h2 id=&quot;任务管理&quot;&gt;任务管理&lt;/h2&gt;&lt;p&gt;任务管理也是我拿 &lt;code&gt;Emacs&lt;/code&gt; 所做的事，并且他的表现也比较优秀，稍微设置一些模板就能表现的很好。&lt;/p&gt;&lt;h3 id=&quot;番茄工作法&quot;&gt;番茄工作法&lt;/h3&gt;&lt;p&gt;番茄工作法，即在做事时划分一段专门用来做&lt;strong&gt;一件事&lt;/strong&gt;的时间，期间不允许做其他事，以期达到更好的做事效果。&lt;/p&gt;&lt;h3 id=&quot;蔡格尼克效应&quot;&gt;蔡格尼克效应&lt;/h3&gt;&lt;p&gt;蔡格尼克走近一家餐馆，发现服务员游刃有余得在多个顾客间间穿梭并记下点单且上菜，吃罢饭后，蔡格尼特发现忘记取大衣并折返，还想顺道称赞一下服务员的能力，但她惊讶的发现服务员竟然表示完全不记得她来过了！服务员表示干这一行的都把注意力集中在点单上面了……&lt;/p&gt;&lt;p&gt;蔡格尼特对此事做了研究发现：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;相较于已经完成的工作，人们比较容易记得未完成的，或是被打断的工作。这就是为什么我们的注意力很容易被未完成任务的想法所干扰，而不管这些想法的重要性如何。得益于蔡格尼克的后续研究，我们还知道，其实我们并不一定要完成任务才能说服我们的大脑停止思考它们，我们所要做的就是把想法写下来，让大脑相信它会在之后被妥善处理。至于任务是真的被完成了，还是通过记下笔记而推迟了，大脑并不会区分。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;Justdoit!&quot;&gt;Just do it!&lt;/h3&gt;&lt;p&gt;而具体的工作流，就是我会专门在一天的开始的时候，通常是泡咖啡的时候打开电脑，开始把今天要干的麻烦事写下来（我同时也把 &lt;code&gt;Emacs&lt;/code&gt; 设置成开机启动了，打开电脑就是打开 &lt;code&gt;Emacs&lt;/code&gt;）。等到有晚上有时间了，我会把想做的事进行分解，以期降低自己的抵抗心理（例如&lt;code&gt;写一篇文章&lt;/code&gt;的任务看起来太困难了，但把它分解成&lt;code&gt;收集材料&lt;/code&gt;、&lt;code&gt;思考结构&lt;/code&gt;、&lt;code&gt;完成初稿&lt;/code&gt;等就容易一点了）。&lt;/p&gt;&lt;h2 id=&quot;Emacs&quot;&gt;Emacs&lt;/h2&gt;&lt;p&gt;啊，甜美的 &lt;code&gt;Emacs&lt;/code&gt; 。&lt;/p&gt;&lt;h3 id=&quot;org-roam&quot;&gt;org-roam&lt;/h3&gt;&lt;h4 id=&quot;安装&quot;&gt;安装&lt;/h4&gt;&lt;p&gt;安装很简单，在配置文件中 &lt;code&gt;~/.doom.d/init.el&lt;/code&gt; 中的 &lt;code&gt;org&lt;/code&gt; 模块里加上 &lt;code&gt;roam2&lt;/code&gt; 再 &lt;code&gt;sync&lt;/code&gt; 一下就好了。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;       (org
        +roam2)         ; organize your plain life in plain text&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;配置&quot;&gt;配置&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;;; org-roam
(setq org-roam-directory &amp;quot;~/Nextcloud/Note/org-roam&amp;quot;)
(setq org-roam-capture-templates
      '((&amp;quot;m&amp;quot; &amp;quot;main&amp;quot; plain
         &amp;quot;%?&amp;quot;
         :if-new (file+head &amp;quot;main/${slug}.org&amp;quot;
                            &amp;quot;#+title: ${title}\n&amp;quot;)
         :immediate-finish t
         :unnarrowed t)
        (&amp;quot;r&amp;quot; &amp;quot;reference&amp;quot; plain &amp;quot;%?&amp;quot;
         :if-new
         (file+head &amp;quot;reference/${title}.org&amp;quot; &amp;quot;#+title: ${title}\n&amp;quot;)
         :immediate-finish t
         :unnarrowed t)
        (&amp;quot;a&amp;quot; &amp;quot;article&amp;quot; plain &amp;quot;%?&amp;quot;
         :if-new
         (file+head &amp;quot;articles/${title}.org&amp;quot; &amp;quot;#+title: ${title}\n#+filetags: :article:\n&amp;quot;)
         :immediate-finish t
         :unnarrowed t)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;org-roam-directory&lt;/code&gt; 是放置笔记文件的路径，我把它设置到了 &lt;code&gt;Nextcloud&lt;/code&gt; 的同步目录下，这样换台电脑也能快速查看笔记。&lt;/p&gt;&lt;p&gt;而 &lt;code&gt;org-roam-capture-templates&lt;/code&gt; 是配置笔记的模板，&lt;code&gt;main&lt;/code&gt; 是对应的是 &lt;code&gt;永久笔记&lt;/code&gt;，&lt;code&gt;reference&lt;/code&gt; 对应的是 &lt;code&gt;文献笔记&lt;/code&gt;，&lt;code&gt;article&lt;/code&gt; 可以对应的产出文章，虽然我这篇是直接在博客文件夹下写的（&lt;/p&gt;&lt;h4 id=&quot;具体使用&quot;&gt;具体使用&lt;/h4&gt;&lt;p&gt;经过模板配置后，按下 &lt;code&gt;SPC n r f&lt;/code&gt; 输入一个不存在的标题就是新建一个笔记了，再按下提前配置好的键指定是哪类笔记。&lt;/p&gt;&lt;p&gt;按下 &lt;code&gt;SPC n r i&lt;/code&gt; 既是在正文中插入一条笔记链接，&lt;code&gt;SPC n r r&lt;/code&gt; 既是打开显示双向链接的菜单，能帮助我更好地查看笔记之间的联系。&lt;/p&gt;&lt;p&gt;而通过 &lt;code&gt;SPC n r a&lt;/code&gt; 即可随机跳转到一条笔记上，方便我回顾笔记（可惜我太菜了不知道怎么设置成过滤成只显示仅某一类笔记orz）。&lt;/p&gt;&lt;p&gt;同时 &lt;code&gt;org-roam&lt;/code&gt; 里还附带了一个日志功能，可以像 &lt;code&gt;Logseq&lt;/code&gt; 那样写日志，其前缀是 &lt;code&gt;SPC n r d&lt;/code&gt;，但由于太长我一般都是通过 &lt;code&gt;M-x&lt;/code&gt; 来进行选择对应功能的，现在我的一些想法和梦记都是录入到其中的。&lt;/p&gt;&lt;p&gt;而对于文献笔记，因为没琢磨透 &lt;code&gt;Emacs&lt;/code&gt; 相关文献管理包怎么用，那我就用自带的大纲模式进行折腾了，具体就是用各个标题层级对应书的不同目录，并在最后加上页码，这样也方便我进行回读。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreidapw5bcu6ix2nxxi7uhbaiwnc23nukqfyzububigmk4hfcancc3u&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;&lt;h4 id=&quot;连接&quot;&gt;连接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;org-roam&lt;/code&gt; 第 2 个大版本将里面的链接机制换成了基于 &lt;code&gt;org-mode&lt;/code&gt; 的 &lt;code&gt;link&lt;/code&gt;,所以让 &lt;code&gt;org-roam&lt;/code&gt; 有了跟其他基于文章的双链笔记不同的，有更加精细的操控能力了。&lt;/p&gt;&lt;p&gt;在某个标题使用 &lt;code&gt;org-id-get-creat&lt;/code&gt; 就可以把这个标题转换为一个新的卡片笔记了，既使它仍在一篇文章中，这样一篇挤满不同卡片的文件我可以叫他为 &lt;code&gt;卡片桌&lt;/code&gt;，可以方便的排列展示各个卡片笔记。&lt;/p&gt;&lt;p&gt;而把 &lt;code&gt;org-link-search-must-match-exact-headline&lt;/code&gt; 的值设置成 &lt;code&gt;nil&lt;/code&gt;,那么可以编辑链接，设成 &lt;code&gt;[[roam-id:xxx-xxx-xxx-xxx::关键字][描述文本]]&lt;/code&gt; 即自动跳转到所选笔记的第一个匹配关键词上，不得不感叹 &lt;code&gt;Emacs&lt;/code&gt; 对于文字处理的底蕴之深……&lt;/p&gt;&lt;h4 id=&quot;加密&quot;&gt;加密&lt;/h4&gt;&lt;p&gt;选择了同步意味数据会放到他人的服务器上，所以一些东西不加密实在不放心，所幸其自带了一个包 &lt;code&gt;epa&lt;/code&gt; 可以完成加密工作，或是在模板中设置成 &lt;code&gt;xxx.org.gpg&lt;/code&gt; 格式就会自动进行加密……当然因为加密设定必须要设置一个同步密钥，对于互相连接的卡片笔记非常不方便（一打开菜单输入四五次加密密码谁受得了啊），所幸其 &lt;code&gt;epa&lt;/code&gt; 包里有仅加密一片文本区域的命令 &lt;code&gt;epa-encrypt-region&lt;/code&gt;,事先选择好一片文本区域执行此命令，再指定密码即可执行加密了。&lt;/p&gt;&lt;h4 id=&quot;MORE!&quot;&gt;MORE!&lt;/h4&gt;&lt;p&gt;当然还有其他的扩展包可以用，比如 &lt;code&gt;org roam ui&lt;/code&gt;，这个包可以分析笔记文件形成一个网页，让 &lt;code&gt;Emacs&lt;/code&gt; 用户也能享受到其他双链笔记软件的那个「花里胡哨」的链接分析图。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreicodyiisf7hstovxpkw5excjlmdltlxgjjqbvsghrhmrfxc5hrytm&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;&lt;h3 id=&quot;任务管理&quot;&gt;任务管理&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Emacs&lt;/code&gt; 自带了个 &lt;code&gt;org-mode&lt;/code&gt;，是做任务管理的一把好手，当然要提前配置好任务模板。&lt;/p&gt;&lt;h4 id=&quot;任务模板&quot;&gt;任务模板&lt;/h4&gt;&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;;; org-capture
(setq org-agenda-files '(&amp;quot;~/Nextcloud/gtd/inbox.org&amp;quot;
                         &amp;quot;~/Nextcloud/gtd/gtd.org&amp;quot;
                         &amp;quot;~/Nextcloud/gtd/tickler.org&amp;quot;))

(after! org
  (setq org-capture-templates '((&amp;quot;t&amp;quot; &amp;quot;Todo [inbox]&amp;quot; entry
                               (file+weektree &amp;quot;~/Nextcloud/gtd/inbox.org&amp;quot;)
                               &amp;quot;* TODO %i%?&amp;quot;)
                              (&amp;quot;T&amp;quot; &amp;quot;Tickler&amp;quot; entry
                               (file+headline &amp;quot;~/Nextcloud/gtd/tickler.org&amp;quot; &amp;quot;Tickler&amp;quot;)
                               &amp;quot;* %i%? \n %U&amp;quot;))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;org-agenda-file&lt;/code&gt; 是设置将哪些文件拉入到日历视图的计算中，&lt;code&gt;org-agenda&lt;/code&gt; 视图可以很方便地查看任务分布情况，当然可设可不设。
&lt;code&gt;org-capture-templates&lt;/code&gt; 是设置任务模板，要用 &lt;code&gt;after!&lt;/code&gt; 关键字括起来用延后加载以免被默认配置覆盖掉，其中我将 &lt;code&gt;Todo&lt;/code&gt; 的格式设成了 &lt;code&gt;weektree&lt;/code&gt; 的格式，这会将任务归类成 &lt;code&gt;年-XX周-星期X&lt;/code&gt; 的格式，方便进行定位以及用 &lt;code&gt;org-archive-subtree&lt;/code&gt; 的命令将已完成的任务存档。
更多关于任务模板的相关介绍可看&lt;a href=&quot;https://www.zmonster.me/2018/02/28/org-mode-capture.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;&lt;h4 id=&quot;使用&quot;&gt;使用&lt;/h4&gt;&lt;p&gt;这样配置下来，使用 &lt;code&gt;SPC X&lt;/code&gt; 即可打开一个缓冲，按下 &lt;code&gt;t&lt;/code&gt; 即可选择预先配置的 &lt;code&gt;Todo&lt;/code&gt; 模板，接下来输入任务名称，按下 &lt;code&gt;C-c C-c&lt;/code&gt; 即可将缓冲中的内容送入文件，同时关闭缓存。这个过程不需要去打开其他文件，适合在一个工作流中突然想起某事而花最小的打断代价去写下代办事项。&lt;/p&gt;&lt;h4 id=&quot;移动端使用&quot;&gt;移动端使用&lt;/h4&gt;&lt;p&gt;目前我在安卓端上使用的是 &lt;code&gt;[Orgzly](https://f-droid.org/packages/com.orgzly/)&lt;/code&gt; 搭配 &lt;code&gt;Nextcloud&lt;/code&gt; 进行任务同步，利用小组件功能也能方便一览待办（就是小组件的刷新是个问题）。&lt;/p&gt;&lt;h3 id=&quot;番茄钟&quot;&gt;番茄钟&lt;/h3&gt;&lt;h4 id=&quot;安装&quot;&gt;安装&lt;/h4&gt;&lt;p&gt;在 &lt;code&gt;~/.doom.d/init.el&lt;/code&gt; 中加上 &lt;code&gt;pomodoro&lt;/code&gt; 即可。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;       (org
        +roam2
        +pomodoro)         ; organize your plain life in plain text&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;使用&quot;&gt;使用&lt;/h4&gt;&lt;p&gt;在一个待办标题上使用 &lt;code&gt;SPC t t&lt;/code&gt; 即可开启番茄计时，默认二十五分钟倒计时，还附带一个有点浮夸的敲钟音效（&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://media.southfox.me/attachment/bafkreieirqmdin4xhx57druv47vt64goyjbohwbumuahq5z5xg3y7bjxke&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://jethrokuan.github.io/org-roam-guide/&quot;&gt;How I Take Notes with Org-roam&lt;/a&gt;&lt;/li&gt;&lt;li&gt;卡片笔记写作法：如何实现从阅读到写作&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/jM6OoQLxKE4dT_ZWLibowA&quot;&gt;用“卡片笔记写作法”读《卡片笔记写作法》 译者现身说法并完整示范 | 学习骇客&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.zmonster.me/2018/02/28/org-mode-capture.html&quot;&gt;强大的 Org mode(4): 使用 capture 功能快速记录&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;</content></entry><entry><title>Emacs随记（1）</title><id>https://blog.southfox.me/2022/04/Emacs随记（1）/.html</id><author><name>SouthFox</name><email>master@southfox.me</email></author><updated>2022-04-19T13:09:00Z</updated><link href="https://blog.southfox.me/2022/04/Emacs随记（1）/.html" rel="alternate" /><content type="html">&lt;p&gt;小心，传教士来了.jpg&lt;/p&gt;&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;&lt;p&gt;&lt;code&gt;Emacs&lt;/code&gt;，一款诞生于 &lt;code&gt;1975&lt;/code&gt; 年的开源软件，时间并没有葬送这款软件，直至现在也依然也有不少“奇怪”的人在日常使用它。&lt;/p&gt;&lt;h2 id=&quot;Why?&quot;&gt;Why?&lt;/h2&gt;&lt;p&gt;讲为什么要使用 &lt;code&gt;Emacs&lt;/code&gt; 不如先讲讲为什么不用 &lt;code&gt;Emacs&lt;/code&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;它对 &lt;code&gt;Win&lt;/code&gt; 系统支持不是很友好&lt;/li&gt;&lt;li&gt;全按键操作很劝退从微机课学起电脑的“现代”信息原住民&lt;/li&gt;&lt;li&gt;如果说 &lt;code&gt;Vim&lt;/code&gt; 是小众编辑器，那么 &lt;code&gt;Emacs&lt;/code&gt; 更是小众中的小众，导致很多东西都要自己去翻找&lt;/li&gt;&lt;li&gt;经常出现一些让人恼火的小问题，结合上点更让人吐血&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;还不够劝退吗？那为什么我还要用 &lt;code&gt;Emacs&lt;/code&gt; 呢？&lt;/p&gt;&lt;ul&gt;&lt;li&gt;它的内存占用，4G 的电脑也带的动，我是受够了套壳框架带来的吃内存大户了……浏览器 + &lt;code&gt;VS Code&lt;/code&gt; 已经挤得我电脑动弹不得了。&lt;/li&gt;&lt;li&gt;它的哲学，如果说 &lt;code&gt;Linux&lt;/code&gt; 的哲学是一切皆文件，那么 &lt;code&gt;Emacs&lt;/code&gt; 的哲学就是对于文本的操控了，将电子邮件导入到待办事项，把即时通讯里的通天记录裁剪到收藏里，就连近些火热的双链也有人去实现……因为这些都是“文本”，所以他们就可以被 &lt;code&gt;Emacs&lt;/code&gt; 各个包处理。这些功能要让其他软件去实现，非得用上不同软件拼凑不可，同时他们之间的联系也很脆弱，全看软件开发者是否开放……&lt;/li&gt;&lt;li&gt;它的智慧，虽然我现在也是摸索着用了一段时间，到现在也才是打开次数跟 &lt;code&gt;VS Code&lt;/code&gt; 持平的状态，不过我也足以感受到其中的“智慧”了，它确实很适合培养所谓的“计算机素养”，哪怕用它的人中很多并不是程序员。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;WhyDoomEmacs？&quot;&gt;Why Doom Emacs？&lt;/h2&gt;&lt;p&gt;现在我在用的是 &lt;a href=&quot;https://github.com/hlissner/doom-emacs&quot;&gt;Doom Emacs&lt;/a&gt; ，他们之间的关系有点像是 &lt;code&gt;Minecraft&lt;/code&gt; 和 &lt;code&gt;整合包&lt;/code&gt; 之间的关系，原版生存固然足够好玩且富有深度了，但还是太朴素了，想弄点更大的乐子那自然是往里灌上一众 &lt;code&gt;MOD&lt;/code&gt; 了。而配好一整套相关 &lt;code&gt;MOD&lt;/code&gt; 的即是整合包了，&lt;code&gt;Doom Emacs&lt;/code&gt; 在各种配置整合包里算得上是高效和……轻量？（毕竟我也没用过其他的配置）&lt;/p&gt;&lt;p&gt;同时其中还附带了 &lt;code&gt;evil&lt;/code&gt; 这个包，可以让 &lt;code&gt;Emacs&lt;/code&gt; 用上 &lt;code&gt;Vim&lt;/code&gt; 的操作，想想这确实挺“邪恶”，&lt;code&gt;Emacs&lt;/code&gt; 和 &lt;code&gt;Vim&lt;/code&gt; 之间的“圣战”一直打得昏天暗地，谁知其中竟然分裂出一个教派结合了两方？也确实不愧于 &lt;code&gt;Doom&lt;/code&gt; 之名啊……&lt;/p&gt;&lt;p&gt;能蹭上 &lt;code&gt;Vim&lt;/code&gt; 的操作也是好事，因为 &lt;code&gt;Vim&lt;/code&gt; 的相关资料比 &lt;code&gt;Emacs&lt;/code&gt; 多上许多，比较好找到相关资料，也避免了 &lt;a href=&quot;https://zh.wikipedia.org/zh-hans/Emacs#Emacs%E5%B0%8F%E6%8B%87%E6%8C%87&quot;&gt;Emacs 小拇指&lt;/a&gt;症状。&lt;/p&gt;&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Emacs&lt;/code&gt; 在各种 &lt;code&gt;Linux&lt;/code&gt; 发行版自带的包管理应该能轻松找到（&lt;code&gt;Mac OS&lt;/code&gt; 应该也能简单安装到），安装后运行一次就会生成 &lt;code&gt;~/.emacs.d&lt;/code&gt; 路径下的文件夹。&lt;/p&gt;&lt;p&gt;确认文件夹存在后运行：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git clone --depth 1 https://github.com/hlissner/doom-emacs ~/.emacs.d

~/.emacs.d/bin/doom install&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中安装会到 &lt;code&gt;GitHub&lt;/code&gt; 下载一两百个包，所以提前配置好一个科学网络环境是必须的……&lt;/p&gt;&lt;p&gt;安装结束后，运行后并且……！&lt;/p&gt;&lt;h3 id=&quot;存活下来&quot;&gt;存活下来&lt;/h3&gt;&lt;h4 id=&quot;按键缩写&quot;&gt;按键缩写&lt;/h4&gt;&lt;p&gt;大部分资料都遵循以下缩写——&lt;/p&gt;&lt;p&gt;| Emacs 功能键 | 缩写 | 对应键盘按键(PC/Mac) |
| ------------ | ---- | -------------------- |
| Space        | Spc  | Space(空格)          |
| Control      | C    | Ctrl / Control       |
| Meta         | M    | Alt / Option         |
| Shift        | S    | Shift / Shift        |&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;p&gt;&lt;code&gt;Spc .&lt;/code&gt; 是先按下 &lt;code&gt;空格&lt;/code&gt; 键&lt;strong&gt;再&lt;/strong&gt;按下 &lt;code&gt;.&lt;/code&gt; 键。&lt;/p&gt;&lt;p&gt;&lt;code&gt;M-x&lt;/code&gt; 是按下 &lt;code&gt;Alt&lt;/code&gt; 键&lt;strong&gt;同时&lt;/strong&gt;按下 &lt;code&gt;x&lt;/code&gt; 键。&lt;/p&gt;&lt;h4 id=&quot;实际操作&quot;&gt;实际操作&lt;/h4&gt;&lt;p&gt;对于入门而言，使用 &lt;code&gt;S .&lt;/code&gt; 即可打开文件管理，之后就可以选择一个文件进行打开了。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Vim&lt;/code&gt; 编辑模式可能对于入门来说也是有点痛苦，不过初始时掌握 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;:w&lt;/code&gt; 也够用了。&lt;/p&gt;&lt;p&gt;不用特地去记快捷键，使用 &lt;code&gt;M-x&lt;/code&gt; 搜索相应的命令大部分足够了，当知道自己在高频使用某个命令，那么这时候才稍微用一下快捷键并记忆就足够了。&lt;/p&gt;&lt;p&gt;找到自己想要的功能用兴趣做导向是最优的，&lt;code&gt;org-mode&lt;/code&gt; 就是个不错的选择。&lt;/p&gt;&lt;h4 id=&quot;参考教程&quot;&gt;参考教程&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/overmind1980/oeasyvim&quot;&gt;Vim 教程 - Oeasy&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLhXZp00uXBk4np17N39WvB80zgxlZfVwj&quot;&gt;Doom Emacs 视频教程 - Zaiste Programming&lt;/a&gt; &lt;a href=&quot;https://space.bilibili.com/432142040/channel/seriesdetail?sid=432482&quot;&gt;B 站搬运&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org&quot;&gt;一年成为Emacs高手 (像神一样使用编辑器)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://manateelazycat.github.io/emacs/2018/12/11/study-emacs.html&quot;&gt;怎么学习 Emacs ? 达到真正融汇贯通的境界?&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;先写成这样吧，下篇大概会写点 &lt;code&gt;org-roam&lt;/code&gt; 和 &lt;code&gt;org-mode&lt;/code&gt; 相关配置……不过也得等我自己先折腾了，有东西能写了才能写……&lt;/p&gt;</content></entry></feed>