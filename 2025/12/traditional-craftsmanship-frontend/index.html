<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta property="og:title" content="古法手做网页前端项目 — 狐狸反走矣" /><meta property="og:site_name" content="狐狸反走矣" /><meta property="og:image" content="https://blog.southfox.me/favicon.png" /><meta name="fediverse:creator" content="SouthFox@foxsay.southfox.me" /><title>古法手做网页前端项目 — 狐狸反走矣</title><link rel="me" href="https://foxsay.southfox.me/@SouthFox" /><link rel="me" href="https://codeberg.org/southfox" /><script src="/assets/js/lips.min.js"></script><link rel="stylesheet" href="/assets/css/main.css" /><script type="text/x-scheme">(let ((font (or (localStorage.getItem "font") "zpix")) (font-select (document.getElementById "font-select"))) (define (string=? a b) (== (a.cmp b) 0)) (define (loop-set options value) (let loop ((i 0)) (if (> i (- (length options) 1)) i (let ((option (get options i))) (if (string=? option.value value) (option.setAttribute "selected" #t) (loop (+ 1 i))))))) (define (set-font font-name) (localStorage.setItem "font" font-name) (document.documentElement.setAttribute "data-font" font-name) (if font-select (loop-set font-select.options font-name))) (font-select.addEventListener "change" (lambda (event) (set-font event.target.value))) (set-font font))</script><link rel="alternative" href="/feed.xml" title="狐狸反走矣" type="application/atom+xml" /><link rel="alternative" href="/rss2.xml" title="狐狸反走矣" type="application/rss+xml" /></head><body><nav class="nav"><a href="/" class="brand"><span>狐狸反走矣</span></a><input id="bmenub" type="checkbox" class="show" aria-label="open menu" /><label for="bmenub" class="burger pseudo button">☰</label><div class="menu"><a href="/archives/">归档</a><a href="/tags/">标签</a><a href="/search/">搜索</a><a href="/about/">关于</a></div></nav><div class="container flex"><div class="content"><main data-pagefind-body="true"><div><h2>古法手做网页前端项目</h2><h3>by SouthFox</h3><h3 data-pagefind-sort="date">2025-12-21</h3><div><p>马上就是 2026 年了，我仍然用着最基本的浏览器原生 ECMAScript 和 DOM 操作搓一个
前端项目，这是怎么样的匠人精神（并不）啊！</p><span id="more"></span><h2 id="硬造需求">硬造需求</h2><p>又是到了一年的年尾， <a href="https://curiositystream.com/" class="external_link">curiosity stream</a> 这个聚焦纪录片的流媒体平台发了一封邮件说要到了续费的时候了。
恍然发现这个流媒体平台我这一年并没有看多少，主要是官方前端太莫名奇妙了：
用了 DASH <sup><a href="#1" id="1r">1</a></sup> 这个会根据网络状况动态切换视频清晰度的技术，
但是所用的 dash 播放器不会遵守用户的清晰度设定一直锁定在低清晰度。</p><p>一开始我感到奇怪，明明我看油管的 1080P 也是没什么压力怎么到你这就一直在看糊团块呢？安卓 app 端上
看 1080P 也是可以看的，然后我就想着要不离线下载到本地看也不是不行吧。
搜了下发现 <a href="https://github.com/yt-dlp/yt-dlp" class="external_link">yt-dlp</a> 项目支持下载 curiosity stream 的视频。直接下载发现可以很快的速度下载视频，
这下动了心思想着如果直接拿到视频地址放到一个我自己能控制的 dash 播放器会怎么样？</p><p>然后找到了 <a href="https://dashjs.org/" class="external_link">dash.js</a> 这个项目跟着文档立起了最小能工作的项目个最基本的 html 文件：
引入 dashjs 库后在 body 标签里新开一个 script 标签写一点 Javscript 代码，带入到从控制台网络标签中 api
返回结果挖出的 mpd 播放地址。效果令人震惊，dashjs 播放器解析完地址后直接就流畅播起了最高的 2160p 清晰度的视频流！</p><p>这可就有点古怪了，我的网络在 curiosity stream 确实能够跑满但是为什么在官方的网页端只能看低清晰度呢？我
推测可能是官方的网页前端塞满了很多追踪服务，监视着我包括鼠标移动在内的一举一动。这些大批量的网络请求对我这个没做什么优化
的代理服务队列来说是个挑战，然后就拖慢了官方 dash 播放器对网络状况「纸面数据」上的判断，加上无法锁定清晰度的助攻导致我只能
看糊团块了。
我自己手动拿出 mpd 播放地址放到 dashjs 播放器则能够独占所有网络而跑满速度，而且因为用得是最新的 dashjs 播
放器，试了下发现是能够关掉自动切换清晰度设置实现真正锁定清晰度。</p><p>好吧，那么我能够直接从 api 挖出播放地址同时这个由 cloudflare 之类的 CDN 服务托管的播放地址并没有做什么跨域限制，
让我能够随便从什么域名播放的话……那就干脆自己造个代替前端吧。稍微判断了一下需求：播放视频、展示一些推荐条目、点击条目可
以播放这个条目下的视频。这个很简单的场景好像就没必要 npm 或者 react 之类的工具了。</p><h2 id="古法手做">古法手做</h2><p>那么就开始以原生的 ECMAScript 为基础做一个简易前端出来吧。挑了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" class="external_link">MDN</a> 的 Javascript 教
程开始看起，走马观花的的浏览了下，有点像是什么在洗手间忘带手机开始百无聊赖读起沐浴露配料表
一样，读了几章后觉得还是直接上手吧。</p><p>当然就算看起 Javascript 语法教程我也没打算完全用 Javscript 写，因为半年前知道了一个
在 Javascript 上构建 Scheme 语言的库 <a href="https://lips.js.org/" class="external_link">LIPS</a> ，所以这次想着写前端也是有点为了
醋而去包饺子。</p><p>古法手做前端但古得是 Lisp 之法 <sup><a href="#2" id="2r">2</a></sup> 。</p><h3 id="首先是……导包">首先是……导包</h3><p>参照 lips 的文档用 script 标签直接导入就能使用了，不过马上就遇到坑
了： scheme 标准里 <code>import</code> 已经有实际用途了所以 <code>import</code> 函数是用来
导 scheme 相关的包的，不太清楚如何在 lips 的脚本里使用其它导入的 ESM 包。最后翻找
文档翻找 issues 终于找到了能够凑合的实现：</p><pre><code><span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-symbol">js-import</span> <span class="syntax-open">(</span><span class="syntax-symbol">self.eval</span> <span class="syntax-string">&quot;(x) =&gt; import(x)&quot;</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
<span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-symbol">Dashjs</span> <span class="syntax-open">(</span><span class="syntax-symbol">js-import</span> <span class="syntax-string">&quot;https://cdn.jsdelivr.net/npm/dashjs@5.1.0/dist/modern/esm/dash.all.min.js&quot;</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
<span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-symbol">MediaPlayer</span> <span class="syntax-open">(</span><span class="syntax-symbol">Dashjs.MediaPlayer</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
<span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-symbol">player</span> <span class="syntax-open">(</span><span class="syntax-symbol">MediaPlayer.create</span><span class="syntax-close">)</span><span class="syntax-close">)</span></code></pre><p>这样通过调用 <code>eval</code> 这个「逃生门」也是勉强实现了在 lips 下导入并使用模块。</p><h3 id="这何尝不是一种……">这何尝不是一种……</h3><p>然后就是进行一些登录鉴权然后通过 fetch 去请求 api 操作获取到 token 之类的操作。
在 lips 里调用相关函数真得没什么不同，无非就是 f(x) 变成了 (f x) ，例如 JavaScript 里的:</p><pre><code><span class="syntax-symbol">localStorage</span><span class="syntax-operator">.</span><span class="syntax-symbol">setItem</span><span class="syntax-open">(</span><span class="syntax-string">&quot;token&quot;</span><span class="syntax-operator">,</span> <span class="syntax-operator">...</span><span class="syntax-close">)</span><span class="syntax-operator">;</span></code></pre><p>在 lips 里就成为了：</p><pre><code><span class="syntax-open">(</span><span class="syntax-symbol">localStorage.setItem</span> <span class="syntax-string">&quot;token&quot;</span> <span class="syntax-symbol">...</span><span class="syntax-close">)</span></code></pre><p>要用这种形式表达的理由在这篇文章也是讲得很清楚： <a href="/2025/12/an-intuition-for-lisp-syntax-zh/">直观理解 Lisp 语法</a></p><p>lisper 这种将原来在宿主语言上构建一套 lisp 的做法总感觉有点，额，这何尝不是一种 NTR 呢。</p><h3 id="不是jsx而是sxml">不是 jsx 而是 sxml</h3><p>react 搭配 jsx 这种以比较贴近 HTML 的形式去建立节点元素的方式确实比较直观，但是要配上转译器之类的操作 jsx 最后生成
点 ECMAScript 代码的形式还是有点……吓人 <sup><a href="#3" id="3r">3</a></sup> 。</p><p>循其本，如果将 DOM 元素用列表表达，然后里面分成元素节点名字、属性列表、子节点。那么不难注意 <sup><a href="#4" id="4r">4</a></sup> 到这个列表是一个递归
的表现形式，所以之后也是当然的用一个递归函数去处理这个结构，最后转换成一条条对应语句类似：</p><pre><code><span class="syntax-special">const</span> <span class="syntax-symbol">element</span> <span class="syntax-operator">=</span> <span class="syntax-open">[</span><span class="syntax-string">&quot;div&quot;</span><span class="syntax-operator">,</span> <span class="syntax-open">{</span><span class="syntax-symbol">id</span><span class="syntax-operator">:</span> <span class="syntax-string">&quot;foo&quot;</span><span class="syntax-operator">,</span> <span class="syntax-special">class</span><span class="syntax-operator">:</span> <span class="syntax-string">&quot;demo&quot;</span><span class="syntax-close">}</span><span class="syntax-operator">,</span>
                 <span class="syntax-open">[</span><span class="syntax-open">[</span><span class="syntax-string">&quot;h2&quot;</span><span class="syntax-operator">,</span> <span class="syntax-open">{</span><span class="syntax-close">}</span><span class="syntax-operator">,</span> <span class="syntax-string">&quot;Hello&quot;</span><span class="syntax-close">]</span><span class="syntax-operator">,</span>
                  <span class="syntax-open">[</span><span class="syntax-string">&quot;p&quot;</span><span class="syntax-operator">,</span> <span class="syntax-open">{</span><span class="syntax-close">}</span><span class="syntax-operator">,</span> <span class="syntax-string">&quot;Hello, World!&quot;</span><span class="syntax-close">]</span><span class="syntax-close">]</span><span class="syntax-close">]</span><span class="syntax-operator">;</span>
<span class="syntax-comment">// 最后操作成……
</span><span class="syntax-special">let</span> <span class="syntax-symbol">element</span> <span class="syntax-operator">=</span> <span class="syntax-keyword">document</span><span class="syntax-operator">.</span><span class="syntax-symbol">createElement</span><span class="syntax-open">(</span><span class="syntax-string">&quot;div&quot;</span><span class="syntax-close">)</span><span class="syntax-operator">;</span>
<span class="syntax-symbol">element</span><span class="syntax-operator">.</span><span class="syntax-symbol">setAttribute</span><span class="syntax-open">(</span><span class="syntax-string">&quot;id&quot;</span><span class="syntax-operator">,</span> <span class="syntax-string">&quot;foo&quot;</span><span class="syntax-close">)</span><span class="syntax-operator">;</span>
<span class="syntax-symbol">element</span><span class="syntax-operator">.</span><span class="syntax-symbol">setAttribute</span><span class="syntax-open">(</span><span class="syntax-string">&quot;class&quot;</span><span class="syntax-operator">,</span> <span class="syntax-string">&quot;demo&quot;</span><span class="syntax-close">)</span><span class="syntax-operator">;</span>
<span class="syntax-symbol">element</span><span class="syntax-operator">.</span><span class="syntax-symbol">appendChild</span><span class="syntax-open">(</span>
  <span class="syntax-comment">// let element_1 = document.createElement(&quot;h2&quot;);
</span>  <span class="syntax-comment">// element_1.appendChild(document.createTextNode(&quot;h2&quot;));
</span><span class="syntax-close">)</span><span class="syntax-operator">;</span>
<span class="syntax-symbol">element</span><span class="syntax-operator">.</span><span class="syntax-symbol">appendChild</span><span class="syntax-open">(</span>
  <span class="syntax-comment">// let element_2 = document.createElement(&quot;p&quot;);
</span>  <span class="syntax-comment">// element_2.appendChild(document.createTextNode(&quot;Hello, World!&quot;));
</span><span class="syntax-close">)</span><span class="syntax-operator">;</span></code></pre><p>用 lisp 的语法表示相同的元素可以表示成这样的 sxml <sup><a href="#5" id="5r">5</a></sup> ：</p><pre><code><span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-symbol">element</span> <span class="syntax-symbol">'</span><span class="syntax-open">(</span><span class="syntax-symbol">div</span> <span class="syntax-open">(</span><span class="syntax-symbol">@</span> <span class="syntax-open">(</span><span class="syntax-symbol">id</span> <span class="syntax-string">&quot;foo&quot;</span><span class="syntax-close">)</span> <span class="syntax-open">(</span><span class="syntax-symbol">class</span> <span class="syntax-string">&quot;demo&quot;</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
                  <span class="syntax-open">(</span><span class="syntax-symbol">h2</span> <span class="syntax-string">&quot;hello&quot;</span><span class="syntax-close">)</span>
                  <span class="syntax-open">(</span><span class="syntax-symbol">p</span> <span class="syntax-string">&quot;Hello, World!&quot;</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span></code></pre><p>配上这样的解析函数：</p><pre><code><span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-open">(</span><span class="syntax-symbol">make-element</span> <span class="syntax-symbol">elem</span><span class="syntax-close">)</span>
  <span class="syntax-open">(</span><span class="syntax-symbol">document.createElement</span> <span class="syntax-symbol">elem</span><span class="syntax-close">)</span><span class="syntax-close">)</span>

<span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-open">(</span><span class="syntax-symbol">make-text-node</span> <span class="syntax-symbol">text</span><span class="syntax-close">)</span>
  <span class="syntax-open">(</span><span class="syntax-symbol">document.createTextNode</span> <span class="syntax-symbol">text</span><span class="syntax-close">)</span><span class="syntax-close">)</span>

<span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-open">(</span><span class="syntax-symbol">add-event-listener!</span> <span class="syntax-symbol">elem</span> <span class="syntax-symbol">type</span> <span class="syntax-symbol">proc</span><span class="syntax-close">)</span>
  <span class="syntax-open">(</span><span class="syntax-symbol">elem.addEventListener</span> <span class="syntax-symbol">type</span> <span class="syntax-symbol">proc</span><span class="syntax-close">)</span><span class="syntax-close">)</span>

<span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-open">(</span><span class="syntax-symbol">append-child!</span> <span class="syntax-symbol">elem</span> <span class="syntax-symbol">child</span><span class="syntax-close">)</span>
  <span class="syntax-open">(</span><span class="syntax-symbol">elem.appendChild</span> <span class="syntax-symbol">child</span><span class="syntax-close">)</span><span class="syntax-close">)</span>

<span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-open">(</span><span class="syntax-symbol">set-attribute!</span> <span class="syntax-symbol">elem</span> <span class="syntax-symbol">attr</span> <span class="syntax-symbol">val</span><span class="syntax-close">)</span>
  <span class="syntax-open">(</span><span class="syntax-symbol">elem.setAttribute</span> <span class="syntax-open">(</span><span class="syntax-symbol">symbol-&gt;string</span> <span class="syntax-symbol">attr</span><span class="syntax-close">)</span> <span class="syntax-symbol">val</span><span class="syntax-close">)</span><span class="syntax-close">)</span>

<span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-open">(</span><span class="syntax-symbol">sxml-&gt;dom</span> <span class="syntax-symbol">expr</span><span class="syntax-close">)</span>
  <span class="syntax-open">(</span><span class="syntax-special">let*</span> <span class="syntax-open">(</span><span class="syntax-open">(</span><span class="syntax-symbol">have-attrs</span> <span class="syntax-open">(</span><span class="syntax-special">and</span> <span class="syntax-open">(</span><span class="syntax-symbol">not</span> <span class="syntax-open">(</span><span class="syntax-symbol">null?</span> <span class="syntax-open">(</span><span class="syntax-symbol">cdr</span> <span class="syntax-symbol">expr</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
                          <span class="syntax-open">(</span><span class="syntax-symbol">pair?</span> <span class="syntax-open">(</span><span class="syntax-symbol">cadr</span> <span class="syntax-symbol">expr</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
                          <span class="syntax-open">(</span><span class="syntax-symbol">eq?</span> <span class="syntax-open">(</span><span class="syntax-symbol">caadr</span> <span class="syntax-symbol">expr</span><span class="syntax-close">)</span> <span class="syntax-symbol">'@</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
         <span class="syntax-open">(</span><span class="syntax-symbol">attrs</span> <span class="syntax-open">(</span><span class="syntax-special">if</span> <span class="syntax-symbol">have-attrs</span>
                    <span class="syntax-open">(</span><span class="syntax-symbol">cdadr</span> <span class="syntax-symbol">expr</span><span class="syntax-close">)</span>
                    <span class="syntax-symbol">'</span><span class="syntax-open">(</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
         <span class="syntax-open">(</span><span class="syntax-symbol">rest</span> <span class="syntax-open">(</span><span class="syntax-special">if</span> <span class="syntax-symbol">have-attrs</span>
                   <span class="syntax-open">(</span><span class="syntax-symbol">cddr</span> <span class="syntax-symbol">expr</span><span class="syntax-close">)</span>
                   <span class="syntax-open">(</span><span class="syntax-symbol">cdr</span> <span class="syntax-symbol">expr</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
         <span class="syntax-open">(</span><span class="syntax-symbol">symbol</span> <span class="syntax-open">(</span><span class="syntax-symbol">car</span> <span class="syntax-symbol">expr</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
         <span class="syntax-open">(</span><span class="syntax-symbol">name</span> <span class="syntax-open">(</span><span class="syntax-symbol">symbol-&gt;string</span> <span class="syntax-symbol">symbol</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
         <span class="syntax-open">(</span><span class="syntax-symbol">elem</span> <span class="syntax-open">(</span><span class="syntax-symbol">make-element</span> <span class="syntax-open">(</span><span class="syntax-special">if</span> <span class="syntax-open">(</span><span class="syntax-symbol">char-lower-case?</span> <span class="syntax-open">(</span><span class="syntax-symbol">car</span> <span class="syntax-open">(</span><span class="syntax-symbol">string-&gt;list</span> <span class="syntax-symbol">name</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
                                 <span class="syntax-symbol">name</span>
                                 <span class="syntax-symbol">symbol</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
    <span class="syntax-open">(</span><span class="syntax-special">for-each</span> <span class="syntax-open">(</span><span class="syntax-special">lambda</span> <span class="syntax-open">(</span><span class="syntax-symbol">attr</span> <span class="syntax-symbol">val</span><span class="syntax-close">)</span>
                <span class="syntax-open">(</span><span class="syntax-special">if</span> <span class="syntax-open">(</span><span class="syntax-symbol">procedure?</span> <span class="syntax-symbol">val</span><span class="syntax-close">)</span>
                    <span class="syntax-open">(</span><span class="syntax-symbol">add-event-listener!</span> <span class="syntax-symbol">elem</span> <span class="syntax-symbol">attr</span> <span class="syntax-symbol">val</span><span class="syntax-close">)</span>
                    <span class="syntax-open">(</span><span class="syntax-symbol">set-attribute!</span> <span class="syntax-symbol">elem</span> <span class="syntax-symbol">attr</span> <span class="syntax-symbol">val</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
      <span class="syntax-open">(</span><span class="syntax-special">map</span> <span class="syntax-symbol">car</span> <span class="syntax-symbol">attrs</span><span class="syntax-close">)</span>
      <span class="syntax-open">(</span><span class="syntax-special">map</span> <span class="syntax-symbol">cadr</span> <span class="syntax-symbol">attrs</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
    <span class="syntax-open">(</span><span class="syntax-special">if</span> <span class="syntax-open">(</span><span class="syntax-symbol">null?</span> <span class="syntax-symbol">rest</span><span class="syntax-close">)</span>
        <span class="syntax-symbol">'</span><span class="syntax-open">(</span><span class="syntax-close">)</span>
        <span class="syntax-open">(</span><span class="syntax-special">let</span> <span class="syntax-open">(</span><span class="syntax-open">(</span><span class="syntax-symbol">first</span> <span class="syntax-open">(</span><span class="syntax-symbol">car</span> <span class="syntax-symbol">rest</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
          <span class="syntax-open">(</span><span class="syntax-special">if</span> <span class="syntax-open">(</span><span class="syntax-symbol">pair?</span> <span class="syntax-symbol">first</span><span class="syntax-close">)</span>
              <span class="syntax-open">(</span><span class="syntax-special">map</span> <span class="syntax-open">(</span><span class="syntax-special">lambda</span> <span class="syntax-open">(</span><span class="syntax-symbol">expr</span><span class="syntax-close">)</span>
                     <span class="syntax-open">(</span><span class="syntax-symbol">append-child!</span> <span class="syntax-symbol">elem</span> <span class="syntax-open">(</span><span class="syntax-symbol">sxml-&gt;dom</span> <span class="syntax-symbol">expr</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
                   <span class="syntax-symbol">rest</span><span class="syntax-close">)</span>
              <span class="syntax-open">(</span><span class="syntax-symbol">append-child!</span> <span class="syntax-symbol">elem</span> <span class="syntax-open">(</span><span class="syntax-symbol">make-text-node</span> <span class="syntax-symbol">first</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
    <span class="syntax-symbol">elem</span><span class="syntax-close">)</span><span class="syntax-close">)</span></code></pre><p>就能实现通过 sxml 创建出一个 DOM 了！这个解析函数对于没有 lisp 经验的人来说可能有点吓人，不过实际是和上面 JavaScript 语法
的例子是一样的，无非就是用接收的列表第一个元素的符号去 <code>document.createElement</code> ；然后判断列表第二项是否是列表第一个
元素是不是 <code>@</code> （是的话表示有参数）然后拿剩下列表的键值对做循环调用 <code>setAttribute</code> 来处理元素的
属性；然后将第三项剩余节点递归地调用 <code>appendChild</code> 添加到一开始的元素上。</p><p>这个 sxml-&gt;dom 函数我是从 lips 标准库拿出来改成这样的， lips 标准库内的 sxml 相关函数是
为 <code>React.createElement</code> 之类的框架准备的，我将其改成了使用原生的 <code>document.createElement</code> 之类
内建函数来创建一个节点。</p><h3 id="列表中的模板">列表中的模板</h3><p>现在有了 sxml-&gt;dom 函数能够生成一个 DOM ，那么还能做到更多吗？例如一个经典的按钮点击应用：</p><pre><code><span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-open">(</span><span class="syntax-symbol">click-app</span><span class="syntax-close">)</span>
  <span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-symbol">*click*</span> <span class="syntax-symbol">0</span><span class="syntax-close">)</span>
  <span class="syntax-open">(</span><span class="syntax-symbol">sxml-&gt;dom</span> <span class="syntax-symbol">`</span><span class="syntax-open">(</span><span class="syntax-symbol">div</span> <span class="syntax-open">(</span><span class="syntax-symbol">@</span> <span class="syntax-open">(</span><span class="syntax-symbol">id</span> <span class="syntax-string">&quot;container&quot;</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
               <span class="syntax-open">(</span><span class="syntax-symbol">p</span> <span class="syntax-open">(</span><span class="syntax-symbol">@</span> <span class="syntax-open">(</span><span class="syntax-symbol">id</span> <span class="syntax-string">&quot;click&quot;</span><span class="syntax-close">)</span><span class="syntax-close">)</span> <span class="syntax-symbol">,</span><span class="syntax-open">(</span><span class="syntax-symbol">number-&gt;string</span> <span class="syntax-symbol">*click*</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
               <span class="syntax-open">(</span><span class="syntax-symbol">button</span>
                <span class="syntax-open">(</span><span class="syntax-symbol">@</span> <span class="syntax-open">(</span><span class="syntax-symbol">click</span>
                    <span class="syntax-symbol">,</span><span class="syntax-open">(</span><span class="syntax-special">lambda</span> <span class="syntax-open">(</span><span class="syntax-symbol">event</span><span class="syntax-close">)</span>
                       <span class="syntax-open">(</span><span class="syntax-symbol">set!</span> <span class="syntax-symbol">*click*</span> <span class="syntax-open">(</span><span class="syntax-symbol">+</span> <span class="syntax-symbol">1</span> <span class="syntax-symbol">*click*</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
                       <span class="syntax-open">(</span><span class="syntax-symbol">element-replace-with!</span>
                        <span class="syntax-open">(</span><span class="syntax-symbol">get-element-by-id</span> <span class="syntax-string">&quot;click&quot;</span><span class="syntax-close">)</span>
                        <span class="syntax-open">(</span><span class="syntax-symbol">sxml-&gt;dom</span> <span class="syntax-symbol">`</span><span class="syntax-open">(</span><span class="syntax-symbol">p</span> <span class="syntax-open">(</span><span class="syntax-symbol">@</span> <span class="syntax-open">(</span><span class="syntax-symbol">id</span> <span class="syntax-string">&quot;click&quot;</span><span class="syntax-close">)</span><span class="syntax-close">)</span> <span class="syntax-symbol">,</span><span class="syntax-open">(</span><span class="syntax-symbol">number-&gt;string</span> <span class="syntax-symbol">*click*</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
                <span class="syntax-string">&quot;click!&quot;</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span><span class="syntax-close">)</span></code></pre><p>可以看到里面有一些很奇怪的东西，首先就是 sxml-&gt;dom 的参数里列表以 <code>`</code> 开头，而里面的一些列表元素又以 <code>,</code> 开头。
这其实是很多 lisp 里常有的 <strong>准引用</strong> ，可以类比成各类模板中的插值。 <code>`</code> 里所有元素都保持不变，但 <code>,</code> 开头的会被
执行，例如：</p><pre><code><span class="syntax-symbol">`</span><span class="syntax-open">(</span><span class="syntax-symbol">+</span> <span class="syntax-symbol">1</span> <span class="syntax-symbol">2</span> <span class="syntax-symbol">,</span><span class="syntax-open">(</span><span class="syntax-symbol">+</span> <span class="syntax-symbol">1</span> <span class="syntax-symbol">2</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
<span class="syntax-comment">;; =&gt; (+ 1 2 3)
</span>
<span class="syntax-open">(</span><span class="syntax-special">define</span> <span class="syntax-symbol">*click*</span> <span class="syntax-symbol">2</span><span class="syntax-close">)</span>
<span class="syntax-symbol">`</span><span class="syntax-open">(</span><span class="syntax-symbol">p</span> <span class="syntax-open">(</span><span class="syntax-symbol">@</span> <span class="syntax-open">(</span><span class="syntax-symbol">id</span> <span class="syntax-string">&quot;click&quot;</span><span class="syntax-close">)</span><span class="syntax-close">)</span> <span class="syntax-symbol">,</span><span class="syntax-open">(</span><span class="syntax-symbol">number-&gt;string</span> <span class="syntax-symbol">*click*</span><span class="syntax-close">)</span><span class="syntax-close">)</span>
<span class="syntax-comment">;; =&gt; (p (@ (id &quot;click&quot;)) 2))</span></code></pre><p>同时针对 <code>@</code> 属性列表里面的， sxml-&gt;dom 会有这样一段：</p><pre><code><span class="syntax-open">(</span><span class="syntax-special">if</span> <span class="syntax-open">(</span><span class="syntax-symbol">procedure?</span> <span class="syntax-symbol">val</span><span class="syntax-close">)</span>
    <span class="syntax-open">(</span><span class="syntax-symbol">add-event-listener!</span> <span class="syntax-symbol">elem</span> <span class="syntax-symbol">attr</span> <span class="syntax-symbol">val</span><span class="syntax-close">)</span>
    <span class="syntax-open">(</span><span class="syntax-symbol">set-attribute!</span> <span class="syntax-symbol">elem</span> <span class="syntax-symbol">attr</span> <span class="syntax-symbol">val</span><span class="syntax-close">)</span><span class="syntax-close">)</span></code></pre><p>就是当值是一个过程（Scheme 里将函数称为过程）的话那么就用 <code>add-event-listerner!</code> 这个函数设置监听而不是用属性
设置函数设置键值，这样就达成了在属性列表分派 <code>setAttribute</code> 或 <code>addEventListener</code> 函数的效果。</p><p>因为是自己造的轮子所以 render 更新流程就直接写在监听事件的回调函数里面了，
用 <code>get-element-by-id</code> 手动选择元素然后就地更新回去，虽然比较麻烦但至少能用。</p><h2 id="总结">总结</h2><ul><li>项目仓库：<a href="https://codeberg.org/southfox/curioda" class="external_link">southfox/curioda - Codeberg.org</a></li><li>cloudflare pages 部署地址： <a href="https://curioda.pages.dev/" class="external_link">https://curioda.pages.dev/</a></li></ul><p>有了上述说的一些设置也是慢慢磨出了个能用的前端出来，无非就是做点将 token 登录凭证存到 localStorage 啦、api 请求封装啦、
一些 dom 元素操作啦等等，现在是暂时搓出了个能用的项目出来。简陋但是能用，而且播放器全屏后基本都是面对视频所以没必要太在乎
外面的外观……吧。</p><p>这个前端能不能用 react 写？能。这个前端就算用 lips 库写但是可不可以结合 react ？能，甚至标准库就有
将 sxml 配合 <code>React.createElement</code> 函数的支持。
但我还是对在这个浏览器就能直接加载的流程感到满意，也实在体会到了前端开发的「乐趣」，一种修改马上就能得到
反馈的愉悦，不过转念一想，好像跟 REPL <sup><a href="#6" id="6r">6</a></sup> 差不多啊。</p><h2 id="Bonus">Bonus</h2><p>lips 是一个可以从外部导入的 js 库，那么它能不能在一些更……有趣的地方运行呢？例如 Tampermonkey 这种运行用户自定
义脚本的地方，捣鼓了一下发现真行。</p><pre><code><span class="syntax-comment">// ==UserScript==
</span><span class="syntax-comment">// @name         New Userscript
</span><span class="syntax-comment">// @namespace    http://tampermonkey.net/
</span><span class="syntax-comment">// @version      2025-12-20
</span><span class="syntax-comment">// @description  try to take over the world!
</span><span class="syntax-comment">// @author       You
</span><span class="syntax-comment">// @match        https://*/*
</span><span class="syntax-comment">// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
</span><span class="syntax-comment">// @require      https://cdn.jsdelivr.net/npm/lips@beta/dist/lips.min.js
</span><span class="syntax-comment">// @grant        none
</span><span class="syntax-comment">// ==/UserScript==
</span>
<span class="syntax-special">const</span> <span class="syntax-symbol">script</span> <span class="syntax-operator">=</span> <span class="syntax-string">`
(alert &quot;Hello World&quot;)
`</span><span class="syntax-operator">;</span>

<span class="syntax-open">(</span><span class="syntax-special">async</span> <span class="syntax-special">function</span><span class="syntax-open">(</span><span class="syntax-close">)</span> <span class="syntax-open">{</span>
    <span class="syntax-string">'use strict'</span><span class="syntax-operator">;</span>
    <span class="syntax-special">const</span> <span class="syntax-symbol">exec</span> <span class="syntax-operator">=</span> <span class="syntax-symbol">lips</span><span class="syntax-operator">.</span><span class="syntax-symbol">exec</span><span class="syntax-operator">;</span>
    <span class="syntax-special">await</span> <span class="syntax-symbol">exec</span><span class="syntax-open">(</span><span class="syntax-symbol">script</span><span class="syntax-close">)</span><span class="syntax-operator">;</span>
<span class="syntax-close">}</span><span class="syntax-close">)</span><span class="syntax-open">(</span><span class="syntax-close">)</span><span class="syntax-operator">;</span></code></pre><p>以上就是一个最小 Tampermonkey 里的运行 lips 最小概念验证脚本了，不过试了试
因为 lips 里面的 <code>new Function()</code> 黑魔法，在一些有特别严格设置 CSP 地方是无法运行的，不过
依然也是解锁了新的应用场景，不清楚之后我能不能用上呢。</p><h2 id="脚注">脚注</h2><p><sup><a href="#1r" id="1">1</a></sup> <a href="https://zh.wikipedia.org/zh-cn/%E5%9F%BA%E4%BA%8EHTTP%E7%9A%84%E5%8A%A8%E6%80%81%E8%87%AA%E9%80%82%E5%BA%94%E6%B5%81" class="external_link">基于HTTP的动态自适应流 - 维基百科，自由的百科全书</a></p><p><sup><a href="#2r" id="2">2</a></sup> 笑点解析：哪怕是 Scheme 也是 1975 年就发布了 <a href="https://zh.wikipedia.org/zh-cn/LISP" class="external_link">LISP - 维基百科，自由的百科全书</a></p><p><sup><a href="#3r" id="3">3</a></sup> <a href="https://pomb.us/build-your-own-react/" class="external_link">Build your own React</a></p><p><sup><a href="#4r" id="4">4</a></sup> 真不难注意！因为 HTML 文档本身就是这样的嵌套的列表结构</p><p><sup><a href="#5r" id="5">5</a></sup> 之前写的文章也提到了 sxml ，本身也有点 lisp 教学的意思在里面：<a href="/2025/09/hello-haunt/">Hello Haunt, 又一次换了博客框架</a></p><p><sup><a href="#6r" id="6">6</a></sup> <a href="https://zh.wikipedia.org/zh-cn/%E8%AF%BB%E5%8F%96-%E6%B1%82%E5%80%BC-%E8%BE%93%E5%87%BA%E5%BE%AA%E7%8E%AF" class="external_link">读取-求值-输出循环 - 维基百科，自由的百科全书</a></p></div></div></main><div class="pagination"><a class="btn" href="/2025/12/fox-thinking-10/">← 上一页</a><a class="btn" href="/"> 主页 </a><a class="btn" href="/2025/12/an-intuition-for-lisp-syntax-zh/">下一页 →</a></div><div class="comment"><blockquote>如不想授权 Giscus 应用，也可以点击下方<strong>左上角数字</strong>直接跳转到 Github Discussions 进行评论。</blockquote><script src="https://giscus.app/client.js" data-repo="SouthFox-D/SouthFox-D.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkyMjg3NDM0MjQ=" data-category="博客评论" data-category-id="DIC_kwDODaJZAM4CA7bf" data-mapping="specific" data-term="2025/12/traditional-craftsmanship-frontend/" data-reactions-enabled="0" data-emit-metadata="0" data-input-position="top" data-theme="dark_dimmed" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async=""></script></div></div><div class="sidebar"><div class="widget"><h4>链接</h4><ul><li><a href="/friends/">友链</a></li><li><a href="https://www.travellings.cn/train.html">开往</a></li><li><a href="https://foreverblog.cn/go.html">虫洞</a></li><li><a href="/feed.xml">订阅（Atom)</a></li><li><a href="/rss2.xml">订阅（Rss)</a></li><li><a href="https://www.lisperati.com/logo.html"><img src="/assets/img/lisplogo_warning2_128.png" alt="Lisp logo warning" /></a></li><li><a href="https://www.fsf.org/appeal"><img src="/assets/img/6838639.png" alt="FSF appeal" /></a></li></ul><div><a href="https://xn--sr8hvo.ws/previous">←</a><a href="https://xn--sr8hvo.ws">IndieWeb Webring 💍</a><a href="https://xn--sr8hvo.ws/next">→</a></div><div><a href="https://fediring.net/previous?host=blog.southfox.me">←</a><a href="https://fediring.net">Fediring 💍</a><a href="https://fediring.net/next?host=blog.southfox.me">→</a></div></div><div class="widget"><h4>设置</h4><div><label for="font-select">字体设置：</label><select id="font-select"><option value="plain">普通</option><option value="zpix">像素</option></select></div></div><div class="widget"><h4>标签</h4><ul><li><a href="/tag/Lisp">Lisp</a></li><li><a href="/tag/前端">前端</a></li><li><a href="/tag/技术">技术</a></li><li><a href="/tag/JavaScript">JavaScript</a></li></ul></div><div class="widget"><h4>目录</h4><ul><li><a href="#硬造需求">硬造需求</a></li><li><a href="#古法手做">古法手做</a></li><li><a href="#首先是……导包">首先是……导包</a></li><li><a href="#这何尝不是一种……">这何尝不是一种……</a></li><li><a href="#不是jsx而是sxml">不是 jsx 而是 sxml</a></li><li><a href="#列表中的模板">列表中的模板</a></li><li><a href="#总结">总结</a></li><li><a href="#Bonus">Bonus</a></li><li><a href="#脚注">脚注</a></li></ul></div></div></div><footer class="footer"><div class="copyright"><div><p>© SouthFox 2026 ,Font by <a href="https://github.com/SolidZORO/zpix-pixel-font">Zpix</a></p></div><div><p>Power by <a href="https://dthompson.us/projects/haunt.html">haunt</a> ,source can be found <a href="https://git.southfox.me/southfox/blog">here</a></p></div></div></footer></body></html>